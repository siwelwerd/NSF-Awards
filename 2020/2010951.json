{
 "awd_id": "2010951",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Small: Mechanical Verification of QBF Results",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032922585",
 "po_email": "pprabhak@nsf.gov",
 "po_sign_block_name": "Pavithra Prabhakar",
 "awd_eff_date": "2019-11-02",
 "awd_exp_date": "2021-07-31",
 "tot_intn_awd_amt": 196608.0,
 "awd_amount": 196608.0,
 "awd_min_amd_letter_date": "2020-01-08",
 "awd_max_amd_letter_date": "2020-01-08",
 "awd_abstract_narration": "Many important industrial applications, such as verification and synthesis problems, can be efficiently solved by satisfiability (SAT) solvers.  However, this approach involves translating the original problem into SAT that typically results in generating dozens to thousands of nearly identical copies of subproblems.  The quantified Boolean formula (QBF) formalism provides a convenient framework to compactly translate many of these interesting problems. For example, software verification and hardware synthesis problems can be translated into QBF, while avoiding generating these nearly identical copies.  Hence, QBF facilities a compact representation of crucial problems in computer science.\r\n\r\nThe expressiveness of QBF comes at a price: it is hard validate the results produced by these solvers.  The existing approaches for addressing this problem all have disadvantages.  Prevalent approaches involve costly validation algorithms and limit the used techniques.  A recent technological advancement, known as clausal proofs, takes care of most problems.  However, efficiently checking clausal proofs is complicated, thus trusting the results of one complex program (a QBF solver) depends on the correctness of another complex program (the checker).  To boost confidence in the results of QBF solvers, a mechanically-verified checker is required.  This research develops a uniform, complete, and trustworthy framework for QBF solving which is urgently needed for the scientific and industrial application of QBF solvers.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Marienus",
   "pi_last_name": "Heule",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Marienus Heule",
   "pi_email_addr": "marijn@cmu.edu",
   "nsf_id": "000689986",
   "pi_start_date": "2020-01-08",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Carnegie-Mellon University",
  "inst_street_address": "5000 FORBES AVE",
  "inst_street_address_2": "",
  "inst_city_name": "PITTSBURGH",
  "inst_state_code": "PA",
  "inst_state_name": "Pennsylvania",
  "inst_phone_num": "4122688746",
  "inst_zip_code": "152133815",
  "inst_country_name": "United States",
  "cong_dist_code": "12",
  "st_cong_dist_code": "PA12",
  "org_lgl_bus_name": "CARNEGIE MELLON UNIVERSITY",
  "org_prnt_uei_num": "U3NKNFLNQ613",
  "org_uei_num": "U3NKNFLNQ613"
 },
 "perf_inst": {
  "perf_inst_name": "Carnegie-Mellon University",
  "perf_str_addr": "5000 Forbes Ave WQED Bldg",
  "perf_city_name": "Pittsburgh",
  "perf_st_code": "PA",
  "perf_st_name": "Pennsylvania",
  "perf_zip_code": "152133815",
  "perf_ctry_code": "US",
  "perf_cong_dist": "12",
  "perf_st_cong_dist": "PA12",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "8206",
   "pgm_ref_txt": "Formal Methods and Verification"
  }
 ],
 "app_fund": [
  {
   "app_code": "0116",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001617DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2016,
   "fund_oblg_amt": 196608.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><div class=\"page\" title=\"Page 2\">\n<div class=\"layoutArea\">\n<div class=\"column\">\n<p>Automated reasoning tools have become very powerful to solve a broad range of problems. However, these tools also became more and more complicated. To have confidence in their correctness, we need a method to validate their results. This project focused on a validation method for tools that solve&nbsp;quantified Boolean formulas (QBF). QBF&nbsp;provides a convenient framework to compactly encode many interesting problems, including&nbsp;model checking and hardware synthesis. The expressiveness of QBF comes at a price: it is hard validate results by QBF solvers. The existing approaches for addressing this problem all have disadvantages. Prevalent approaches involve using only a subset of state-of-the-art solver techniques and validation algorithms require exponential running time.&nbsp;</p>\n</div>\n</div>\n</div>\n<p>Key outcomes of the project are all related to QRAT, a recent proof system to validate QBF results. First, we showed how to produce QRAT proofs even when combining different preprocessing and solving techniques. Second, we demonstrated how to extract useful information out of these proofs, in particular Skolem functions. This information is crucial for various applications. Third, we developed new preprocessing techniques for QBF that were inspired by the QRAT proof system. Forth, we studied to relationship between QRAT and other strong proof systems for QBFs, resulting in some interesting simulation results. Finally, we developed a QBF solver that is radically different compared to existing ones. This solver is able to solve some problems that are too hard for alternative approaches. Moreover, all reasoning in this solver is logged as QRAT proofs. By checking these proofs, we can have full confidence in the correctness of the results.&nbsp;</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 02/06/2022<br>\n\t\t\t\t\tModified by: Marienus&nbsp;Heule</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\n\n\n\nAutomated reasoning tools have become very powerful to solve a broad range of problems. However, these tools also became more and more complicated. To have confidence in their correctness, we need a method to validate their results. This project focused on a validation method for tools that solve quantified Boolean formulas (QBF). QBF provides a convenient framework to compactly encode many interesting problems, including model checking and hardware synthesis. The expressiveness of QBF comes at a price: it is hard validate results by QBF solvers. The existing approaches for addressing this problem all have disadvantages. Prevalent approaches involve using only a subset of state-of-the-art solver techniques and validation algorithms require exponential running time. \n\n\n\n\nKey outcomes of the project are all related to QRAT, a recent proof system to validate QBF results. First, we showed how to produce QRAT proofs even when combining different preprocessing and solving techniques. Second, we demonstrated how to extract useful information out of these proofs, in particular Skolem functions. This information is crucial for various applications. Third, we developed new preprocessing techniques for QBF that were inspired by the QRAT proof system. Forth, we studied to relationship between QRAT and other strong proof systems for QBFs, resulting in some interesting simulation results. Finally, we developed a QBF solver that is radically different compared to existing ones. This solver is able to solve some problems that are too hard for alternative approaches. Moreover, all reasoning in this solver is logged as QRAT proofs. By checking these proofs, we can have full confidence in the correctness of the results. \n\n\t\t\t\t\tLast Modified: 02/06/2022\n\n\t\t\t\t\tSubmitted by: Marienus Heule"
 }
}