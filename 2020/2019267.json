{
 "awd_id": "2019267",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "FMitF: Track II: Lifting the SMACK Verifier to Production Software",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032922585",
 "po_email": "pprabhak@nsf.gov",
 "po_sign_block_name": "Pavithra Prabhakar",
 "awd_eff_date": "2020-10-01",
 "awd_exp_date": "2023-09-30",
 "tot_intn_awd_amt": 100000.0,
 "awd_amount": 100000.0,
 "awd_min_amd_letter_date": "2020-06-17",
 "awd_max_amd_letter_date": "2020-06-17",
 "awd_abstract_narration": "Software is ubiquitous nowadays.  Software systems run devices ranging from pacemakers, phones, and computers, all the way to trucks, airplanes, and smart power grids. These systems are extremely complex and hard to implement correctly, and errors in them can have very serious consequences. Therefore, developers need readily available tools to help them ensure the correctness of software systems. This project aims to improve and extend one such tool, called SMACK, and enable for it to be used as a part of the regular software-development practice to help developers create better software.\r\n\r\nSMACK is used both by researchers in academia and industry practitioners. Researchers use it since it enables easy experimentation with new verification algorithms and techniques. Practitioners use it since it is a stable software verifier that works on small- to medium-sized software systems. The proposed features and additions will further increase SMACK's capabilities to drive novel software-verification research and the adoption of software verification in industry practice. The project will also increase the reproducibility of software-verification research by producing a large number of benchmarks, and promote software-verification education through the development of teaching modules and tutorials.\r\n\r\nThe project is split into three main tasks: supporting more source-language features, verifying large software systems, and enabling adjustable scalability and precision of verification. Supporting modern source-language features, such as special parallelism- and security-related instructions, requires inventing models for them that are appropriate for verification. Verifying large software systems leads to the development of novel verification algorithms and implementations, such as the ones that leverage massive parallelism available in machines nowadays.  Finally, having adjustable scalability and precision requires empirical exploration of various options in this space, which furthers the understanding of which verification techniques work on real-world software systems.\r\n\r\nThe goal of the project is to build an industry-strength software verifier that keeps up with the development of verification technology and software practices. Hence, the approximate lifetime of SMACK is expected to extend far beyond the scope of this project, into the range of 10-15 years. SMACK has been available as a permissively-licensed open-source project on GitHub (https://github.com/smackers/smack) for eight years already, and it also leverages popular open-source projects such as the low level virtual machine (LLVM) compiler infrastructure. The plan to ensure its longevity is to continue embracing the open-source community through public bug reports, development subtasks, and peer code reviews.\r\n\r\nThis award reflects NSF's statutory mission and has been deemed worthy of support through evaluation using the Foundation's intellectual merit and broader impacts review criteria.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Zvonimir",
   "pi_last_name": "Rakamaric",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Zvonimir Rakamaric",
   "pi_email_addr": "zvonimir@cs.utah.edu",
   "nsf_id": "000623290",
   "pi_start_date": "2020-06-17",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Utah",
  "inst_street_address": "201 PRESIDENTS CIR",
  "inst_street_address_2": "",
  "inst_city_name": "SALT LAKE CITY",
  "inst_state_code": "UT",
  "inst_state_name": "Utah",
  "inst_phone_num": "8015816903",
  "inst_zip_code": "841129049",
  "inst_country_name": "United States",
  "cong_dist_code": "01",
  "st_cong_dist_code": "UT01",
  "org_lgl_bus_name": "UNIVERSITY OF UTAH",
  "org_prnt_uei_num": "",
  "org_uei_num": "LL8GLEVH6MG3"
 },
 "perf_inst": {
  "perf_inst_name": "University of Utah",
  "perf_str_addr": "50 Central Campus Dr",
  "perf_city_name": "Salt Lake City",
  "perf_st_code": "UT",
  "perf_st_name": "Utah",
  "perf_zip_code": "841129205",
  "perf_ctry_code": "US",
  "perf_cong_dist": "01",
  "perf_st_cong_dist": "UT01",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "094Y00",
   "pgm_ele_name": "FMitF: Formal Methods in the F"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "071Z",
   "pgm_ref_txt": "FMitF-Formal Methods in the Field"
  },
  {
   "pgm_ref_code": "8206",
   "pgm_ref_txt": "Formal Methods and Verification"
  }
 ],
 "app_fund": [
  {
   "app_code": "0120",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01002021DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2020,
   "fund_oblg_amt": 100000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>The main goal of the project has been to improve SMACK by advancing several key areas to support a greater swath of software systems and software verification researchers: additional source language features and tunable scalability and precision. As additional source language features, we focused on expanding&nbsp;<span><span>SMACK's</span></span>&nbsp;support for multi-language verification. We in particular focused on supporting Rust, as the key up-and-coming language in the software systems area. Here, we implemented more stable support for floating-point computations in Rust in SMACK. We leveraged this to perform a case study of equivalence checking of the mathematical&nbsp;library&nbsp;<span><span>libm</span></span>&nbsp;that is implemented in both C and Rust.</p>\n<p>On the tunable scalability and precision front, we extended SMACK with support for portfolio solving, where several&nbsp;<span><span>backend</span></span>&nbsp;verifiers with varying characteristics and heuristics can be run in parallel. Moreover, we worked on fine-tuning them for particular verification problems of interest. We picked implementations of compression algorithms as particularly interesting due to the verification scalability challenges related to their usage of low-level&nbsp;<span><span>bitvector</span></span>&nbsp;and memory operations. Here, we combined SMACK with the available&nbsp;<span><span>SMAC</span></span>&nbsp;tool for the automatic tuning of the available&nbsp;<span><span>backend</span></span>&nbsp;verifier heuristics parameters. Using&nbsp;<span><span>SMAC</span></span>&nbsp;we managed to improve the performance of SMACK on compression routines by picking more optimal heuristics for this domain.</p>\n<p>&nbsp;</p><br>\n<p>\n Last Modified: 08/04/2024<br>\nModified by: Zvonimir&nbsp;Rakamaric</p></div>\n<div class=\"porSideCol\"\n></div>\n</div>\n",
  "por_txt_cntn": "\n\nThe main goal of the project has been to improve SMACK by advancing several key areas to support a greater swath of software systems and software verification researchers: additional source language features and tunable scalability and precision. As additional source language features, we focused on expandingSMACK'ssupport for multi-language verification. We in particular focused on supporting Rust, as the key up-and-coming language in the software systems area. Here, we implemented more stable support for floating-point computations in Rust in SMACK. We leveraged this to perform a case study of equivalence checking of the mathematicallibrarylibmthat is implemented in both C and Rust.\n\n\nOn the tunable scalability and precision front, we extended SMACK with support for portfolio solving, where severalbackendverifiers with varying characteristics and heuristics can be run in parallel. Moreover, we worked on fine-tuning them for particular verification problems of interest. We picked implementations of compression algorithms as particularly interesting due to the verification scalability challenges related to their usage of low-levelbitvectorand memory operations. Here, we combined SMACK with the availableSMACtool for the automatic tuning of the availablebackendverifier heuristics parameters. UsingSMACwe managed to improve the performance of SMACK on compression routines by picking more optimal heuristics for this domain.\n\n\n\t\t\t\t\tLast Modified: 08/04/2024\n\n\t\t\t\t\tSubmitted by: ZvonimirRakamaric\n"
 }
}