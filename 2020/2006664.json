{
 "awd_id": "2006664",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "AF: Small: Sparsity in Local Computation",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032922182",
 "po_email": "pbrass@nsf.gov",
 "po_sign_block_name": "Peter Brass",
 "awd_eff_date": "2020-07-01",
 "awd_exp_date": "2023-06-30",
 "tot_intn_awd_amt": 300000.0,
 "awd_amount": 300000.0,
 "awd_min_amd_letter_date": "2020-06-22",
 "awd_max_amd_letter_date": "2020-06-22",
 "awd_abstract_narration": "Consider a setting in which inputs to and outputs from a computational problem are so large that there is not enough time to read them in their entirety.  However, if  a user is interested only in small parts of the output at any given time, it may be possible to provide partial answers to the user in much less time than it would take to compute the whole answer, and even, perhaps, less than the time necessary to read the whole input.  Such fast algorithms that compute only the specific parts of the output needed by the user are referred to as \"local computation algorithms\" (LCAs).  There have been many successes at designing such algorithms for a variety of problems.  However, most of these successes have been for inputs that are in some sense \"sparse\" -- for example, for social networks in which the average number of \"friends\" is small, or optimization problems in which at each decision point there are few possibilities to choose from.  This project aims to broaden the scope of these techniques to the more common \"dense\" scenario.  This project will include the organization of a regular workshop \"Workshop on Local Algorithms (WOLA),\" as well as incorporate training for graduate students, research opportunities for undergraduates, and produce material that is incorporated into the investigator's \"Sublinear Time Algorithms\" course.\r\n\r\nIn more detail, the goal of the proposed research is to develop new tools for designing LCAs.  A main focus of this project is on techniques for designing LCAs for dense problems via sparsification techniques.  One success of the field of algorithms has been to show that many computations on dense graphs can be performed by first finding a sparse graph which has approximately the same solution as the dense graph, and then solving the problem on the sparse graph.  This project investigates such techniques in the setting of LCAs.  Furthermore, this project studies how to do such sparsification in a local manner -- without solving the whole problem up front.  For example, this project will develop fast LCAs which allow a user to determine which edges are part of a sparse approximating subgraph of the original graph.  The research will mine rich sources of techniques from distributed algorithms, massively parallel computation, and sublinear algorithms.  A wide range of optimization problems will be considered, including problems related to finding sparse subgraphs which capture the essential connectivity features of the input graph, coloring, and the class of problems captured by covering and packing linear programs.\r\n\r\nThis award reflects NSF's statutory mission and has been deemed worthy of support through evaluation using the Foundation's intellectual merit and broader impacts review criteria.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Ronitt",
   "pi_last_name": "Rubinfeld",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Ronitt Rubinfeld",
   "pi_email_addr": "ronitt@csail.mit.edu",
   "nsf_id": "000322655",
   "pi_start_date": "2020-06-22",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Massachusetts Institute of Technology",
  "inst_street_address": "77 MASSACHUSETTS AVE",
  "inst_street_address_2": "",
  "inst_city_name": "CAMBRIDGE",
  "inst_state_code": "MA",
  "inst_state_name": "Massachusetts",
  "inst_phone_num": "6172531000",
  "inst_zip_code": "021394301",
  "inst_country_name": "United States",
  "cong_dist_code": "07",
  "st_cong_dist_code": "MA07",
  "org_lgl_bus_name": "MASSACHUSETTS INSTITUTE OF TECHNOLOGY",
  "org_prnt_uei_num": "E2NYLCDML6V1",
  "org_uei_num": "E2NYLCDML6V1"
 },
 "perf_inst": {
  "perf_inst_name": "Massachusetts Institute Of Technology",
  "perf_str_addr": "77 Massachusetts Ave",
  "perf_city_name": "Cambridge",
  "perf_st_code": "MA",
  "perf_st_name": "Massachusetts",
  "perf_zip_code": "021394307",
  "perf_ctry_code": "US",
  "perf_cong_dist": "07",
  "perf_st_cong_dist": "MA07",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779600",
   "pgm_ele_name": "Algorithmic Foundations"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7926",
   "pgm_ref_txt": "ALGORITHMS"
  }
 ],
 "app_fund": [
  {
   "app_code": "0120",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01002021DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2020,
   "fund_oblg_amt": 300000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Intellectual merit:</p>\n<p>This project studies the setting in which inputs to and outputs from a computational problem are so large, that there is no time to read them in their entirety. However, if a user is only interested in small parts of the output at any given time, it may be possible to provide partial answers to the user in time that is much more efficient than what it would take to compute the whole answer, and even, perhaps, faster than the time necessary to read the whole input. Such fast algorithms that compute only the specific parts of the output needed by the user are referred to as local computation algorithms (LCAs).<br /><br />This project has shown that LCAs can be important in the context of learning: While nearly optimal learning algorithms for monotone Boolean functions have been known since the mid-1990's, the hypothesis returned by the learning algorithms were not necessarily monotone themselves.&nbsp; An algorithm that returns a hypothesis that is a member of the class of functions being learned is referred to as ``proper\".&nbsp; This project has developed the first agnostic proper learning algorithm for&nbsp; monotone Boolean functions whose running time is nearly that of the previous nonproper algorithms.&nbsp;&nbsp; This achieved via a new connection with LCAs, by showing that LCAs for the classic graph matching problem can be used as a key&nbsp; component to design algorithms which can correct functions to make them monotone in a \"local\" manner.&nbsp; In further improvements, this project has shown that the scope of LCAs has been extended to solve certain convex optimization problems.<br /><br />An important set of problems that occurs in algorithms for social networks and for biological networks is to count the number of motifs, which are&nbsp; small fixed subgraphs. Examples of motifs that are of interest include edges,triangles and four-cycles.&nbsp;&nbsp; This project has developed new sublinear time algorithms for motif counting.&nbsp;&nbsp; First, a new sublinear time algorithm is given that uses a combinatorial decomposition of the graph to speed up the motif counting algorithms. Second, a new one-pass streaming algorithm, using sublinear space, for estimating the number of triangles and four cycles is given.&nbsp; The latter algorithm uses a \"learned oracle\" which indicates which edges might be in many triangles (resp. four-cycles) to gain efficiency and improved accuracy.&nbsp; Third, improved algorithms for sampling multiple edges in a graph are given which are more efficient than performing several instantiations<br />of an algorithm that samples one edge at a time.<br /><br />Recent work shows that the expressive power of Graph Neural Networks (GNNs) in distinguishing non-isomorphic graphs is exactly the same as that of the Weisfeiler-Lehman (WL) graph test. In particular, the WL test can be simulated by GNNs, as it is a locally computable test. However, those simulations involve neural networks that are of size polynomial or even exponential in the number of graph nodes n,&nbsp; as well as feature vectors of length linear in n. This project presents an improved simulation of the WL test on GNNs with exponentially lower complexity, and shows that the new construction is nearly optimal.<br /><br />A second thrust explored by this project is to find fast local ways of testing distributional assumptions of learning algorithms. Many important high dimensional function classes have fast agnostic learning&nbsp; algorithms when strong assumptions on the distribution of examples can be made, such as Gaussianity or uniformity over the domain.&nbsp; How can one be sufficiently confident that the data indeed satisfies the distributional assumption, so that one can trust in&nbsp; the output quality of the agnostic learning algorithm? Unfortunately, directly testing that the distribution satisfies the distributional assumption requires too many samples. This project introduces the framework of tester-learner pairs (T,A), such that a tester T is applied to the sample distribution, and if T passes, then one can safely trust the output of the&nbsp; agnostic learner A on the data.&nbsp;&nbsp;&nbsp; Note that the tester T is allowed to pass input distributions that do not satisfy the distributional assumption, as long as the algorithm is guaranteed to perform well on the input distribution.&nbsp; The project shows that this paradigm can be applied to the classical problem of agnostically learning halfspaces under the&nbsp; standard Gaussian distribution and the Boolean hypercube,&nbsp; presenting&nbsp; tester-learner pairs with combined run-times that are competitive with the best known agnostic learning algorithm.&nbsp;&nbsp; Thus, very little overhead is required for safely using these algorithms that make distributional assumptions. Several more recent works by others have extended the scope of the framework to apply to a number of other agnostic learning problems.</p>\n<p>&nbsp;</p>\n<p>Broader Impacts:</p>\n<p>The project has organized the yearly \"Workshop on Local Algorithms\" (WOLA) as a long term way of bringing together the communities of researchers in sublinear time, streaming, distributed and parallel algorithms that have similar goals but a variety of approaches and techniques.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 10/14/2023<br>\n\t\t\t\t\tModified by: Ronitt&nbsp;Rubinfeld</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nIntellectual merit:\n\nThis project studies the setting in which inputs to and outputs from a computational problem are so large, that there is no time to read them in their entirety. However, if a user is only interested in small parts of the output at any given time, it may be possible to provide partial answers to the user in time that is much more efficient than what it would take to compute the whole answer, and even, perhaps, faster than the time necessary to read the whole input. Such fast algorithms that compute only the specific parts of the output needed by the user are referred to as local computation algorithms (LCAs).\n\nThis project has shown that LCAs can be important in the context of learning: While nearly optimal learning algorithms for monotone Boolean functions have been known since the mid-1990's, the hypothesis returned by the learning algorithms were not necessarily monotone themselves.  An algorithm that returns a hypothesis that is a member of the class of functions being learned is referred to as ``proper\".  This project has developed the first agnostic proper learning algorithm for  monotone Boolean functions whose running time is nearly that of the previous nonproper algorithms.   This achieved via a new connection with LCAs, by showing that LCAs for the classic graph matching problem can be used as a key  component to design algorithms which can correct functions to make them monotone in a \"local\" manner.  In further improvements, this project has shown that the scope of LCAs has been extended to solve certain convex optimization problems.\n\nAn important set of problems that occurs in algorithms for social networks and for biological networks is to count the number of motifs, which are  small fixed subgraphs. Examples of motifs that are of interest include edges,triangles and four-cycles.   This project has developed new sublinear time algorithms for motif counting.   First, a new sublinear time algorithm is given that uses a combinatorial decomposition of the graph to speed up the motif counting algorithms. Second, a new one-pass streaming algorithm, using sublinear space, for estimating the number of triangles and four cycles is given.  The latter algorithm uses a \"learned oracle\" which indicates which edges might be in many triangles (resp. four-cycles) to gain efficiency and improved accuracy.  Third, improved algorithms for sampling multiple edges in a graph are given which are more efficient than performing several instantiations\nof an algorithm that samples one edge at a time.\n\nRecent work shows that the expressive power of Graph Neural Networks (GNNs) in distinguishing non-isomorphic graphs is exactly the same as that of the Weisfeiler-Lehman (WL) graph test. In particular, the WL test can be simulated by GNNs, as it is a locally computable test. However, those simulations involve neural networks that are of size polynomial or even exponential in the number of graph nodes n,  as well as feature vectors of length linear in n. This project presents an improved simulation of the WL test on GNNs with exponentially lower complexity, and shows that the new construction is nearly optimal.\n\nA second thrust explored by this project is to find fast local ways of testing distributional assumptions of learning algorithms. Many important high dimensional function classes have fast agnostic learning  algorithms when strong assumptions on the distribution of examples can be made, such as Gaussianity or uniformity over the domain.  How can one be sufficiently confident that the data indeed satisfies the distributional assumption, so that one can trust in  the output quality of the agnostic learning algorithm? Unfortunately, directly testing that the distribution satisfies the distributional assumption requires too many samples. This project introduces the framework of tester-learner pairs (T,A), such that a tester T is applied to the sample distribution, and if T passes, then one can safely trust the output of the  agnostic learner A on the data.    Note that the tester T is allowed to pass input distributions that do not satisfy the distributional assumption, as long as the algorithm is guaranteed to perform well on the input distribution.  The project shows that this paradigm can be applied to the classical problem of agnostically learning halfspaces under the  standard Gaussian distribution and the Boolean hypercube,  presenting  tester-learner pairs with combined run-times that are competitive with the best known agnostic learning algorithm.   Thus, very little overhead is required for safely using these algorithms that make distributional assumptions. Several more recent works by others have extended the scope of the framework to apply to a number of other agnostic learning problems.\n\n \n\nBroader Impacts:\n\nThe project has organized the yearly \"Workshop on Local Algorithms\" (WOLA) as a long term way of bringing together the communities of researchers in sublinear time, streaming, distributed and parallel algorithms that have similar goals but a variety of approaches and techniques.\n\n\t\t\t\t\tLast Modified: 10/14/2023\n\n\t\t\t\t\tSubmitted by: Ronitt Rubinfeld"
 }
}