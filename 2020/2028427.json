{
 "awd_id": "2028427",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "PPoSS: Planning: CP2: Towards Systems Correctness Checkability and Performance Predictability at Scale",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032925197",
 "po_email": "mmcclure@nsf.gov",
 "po_sign_block_name": "Marilyn McClure",
 "awd_eff_date": "2020-09-01",
 "awd_exp_date": "2022-08-31",
 "tot_intn_awd_amt": 247993.0,
 "awd_amount": 247993.0,
 "awd_min_amd_letter_date": "2020-08-21",
 "awd_max_amd_letter_date": "2020-10-14",
 "awd_abstract_narration": "As a critical backend for many of today's applications and services, large-scale distributed systems must be highly reliable.  In the last couple of years the field witnessed a phenomenal scale of deployment; Google is known to run clusters with thousands of machines each, Apple deploys over 100,000 database machines, and Netflix runs tens of database clusters with 500 nodes each.  This new era of cloud-scale distributed systems has given birth to a new class of faults, scalability faults---faults whose symptoms surface in large-scale deployments but not necessarily in small/medium-scale deployments.  The CP2 project is proposed to solve the problem of correctness checkability and performance predictability of systems at extreme scale.  Specifically the project will analyze over 500 real-world scalability faults in over a dozen large-scale systems, develop a single-machine scale-checking framework that allows developers to test large distributed code on one or a few machines, and provide groundwork for compute- and I/O-performance predictability of large-scale jobs on both existing and future architectures.  These tasks will advance debugging, testing, learning, and prediction methods both on traditional hardware platforms and emerging ones and ultimately lead to correct-by-construction development methods. The CP2 project will have impact in multiple disciplines including systems (cloud/datacenter systems reliability), programming languages/compilers (new static/dynamic analysis techniques), architecture (compute/storage prediction for heterogeneous hardware), algorithms (the use of learning methods), and high-performance computing (benchmarking of HPC systems/applications).\r\n\r\nIn terms of societal benefits, the CP2 project addresses paramount issues mentioned in the NSF Strategic Plan for 2018-2022.  More specifically, society increasingly depends on complicated systems that are products of human ingenuity, including ecosystems of large and complex software with millions of lines of code running on thousands of machines.  CP2 will address the challenges of understanding and predicting the behavior of such systems.  Furthermore, as society\u2019s reliance on complex systems grows, learning about their robustness and understanding how to strengthen them are of increasing importance.  In terms of education, the CP2 project gives unique hands-on research and education with cutting-edge systems technology in which students will be trained to operate software on a large number of machines and analyze their performance and correctness.  The results of the CP2 project will be released through the classic medium of publication, through the development of numerous software artifacts which will be open-sourced, and finally through collaboration with various industry partners to help shape the next generation of large-scale systems.\r\n\r\nThis award reflects NSF's statutory mission and has been deemed worthy of support through evaluation using the Foundation's intellectual merit and broader impacts review criteria.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Haryadi",
   "pi_last_name": "Gunawi",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Haryadi Gunawi",
   "pi_email_addr": "haryadi@cs.uchicago.edu",
   "nsf_id": "000626546",
   "pi_start_date": "2020-08-21",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Shan",
   "pi_last_name": "Lu",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Shan Lu",
   "pi_email_addr": "shanlu@cs.uchicago.edu",
   "nsf_id": "000552962",
   "pi_start_date": "2020-08-21",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Henry",
   "pi_last_name": "Hoffmann",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Henry Hoffmann",
   "pi_email_addr": "hankhoffmann@cs.uchicago.edu",
   "nsf_id": "000642777",
   "pi_start_date": "2020-08-21",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Chicago",
  "inst_street_address": "5801 S ELLIS AVE",
  "inst_street_address_2": "",
  "inst_city_name": "CHICAGO",
  "inst_state_code": "IL",
  "inst_state_name": "Illinois",
  "inst_phone_num": "7737028669",
  "inst_zip_code": "606375418",
  "inst_country_name": "United States",
  "cong_dist_code": "01",
  "st_cong_dist_code": "IL01",
  "org_lgl_bus_name": "UNIVERSITY OF CHICAGO",
  "org_prnt_uei_num": "ZUE9HKT2CLC9",
  "org_uei_num": "ZUE9HKT2CLC9"
 },
 "perf_inst": {
  "perf_inst_name": "University of Chicago",
  "perf_str_addr": "5730 S Ellis Avenue",
  "perf_city_name": "Chicago",
  "perf_st_code": "IL",
  "perf_st_name": "Illinois",
  "perf_zip_code": "606371468",
  "perf_ctry_code": "US",
  "perf_cong_dist": "01",
  "perf_st_cong_dist": "IL01",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "042Y00",
   "pgm_ele_name": "PPoSS-PP of Scalable Systems"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "026Z",
   "pgm_ref_txt": "NSCI: National Strategic Computing Initi"
  }
 ],
 "app_fund": [
  {
   "app_code": "0120",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01002021DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2020,
   "fund_oblg_amt": 247993.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>The CP2 project is proposed to solve the problem of correctness checkability (CC) and performance predictability (PP) of systems at extreme scale.&nbsp; This project produces several outcomes given the execution of the sub-projects below. <br /><br />On correctness checkability, we analyzed hundreds real-world scalability faults in over a dozen of large scale systems.&nbsp; Among these bugs, we dived into cancellation bugs [OSDI '22].&nbsp; Modern software applications need to sometimes prematurely terminate or cancel a task, either to accommodate a conflicting task, to manage system resources, or in response to system or user events.&nbsp; We studied 62 cancel-feature requests and 156 cancel-related bugs across 13 popular distributed and concurrent systems written in Java, C#, and Go to understand why task cancel is needed, what are the challenges in implementing task cancel, and how severe are cancel-related failures.&nbsp; Guided by the study, we generalized a few cancel-related anti-patterns and implemented static checkers that found many code snippets matching these anti-patterns in the latest versions of these popular systems. <br /><br />In another project, SVIEW, which is currently under submission, we built a framework for identifying and analyzing potential scalability faults in large-scale distributed systems.&nbsp; SVIEW combines instrumentation and statistical concepts to identify dimensional code fragments (DCFs), pieces of code whose number of executions (e.g., loop iterations) is positively correlated with the increase in size of one or more system dimensions, with static analysis modules that detect faulty code patterns involving the DCFs.&nbsp; We apply SVIEW to 4 popular distributed systems, identify hundreds of DCFs and use our analysis modules to detect known and unknown scalability faults <br /><br />On performance predictability, we performed three projects.&nbsp; The first one is about negative-unlabeled learning for online datacenter straggler prediction (NURD) [MLSys '22].&nbsp; Datacenters execute large computational jobs where a job completes when all its tasks finish.&nbsp; Accurately predicting straggling tasks would enable proactive intervention.&nbsp; To predict stragglers accurately and early without labeled positive examples or assumptions on latency distributions, we built a novel Negative-Unlabeled learning approach with Reweighting and Distribution-compensation that only trains on negative and unlabeled streaming data. The key idea is to train a predictor using finished tasks of non-stragglers to predict latency for unlabeled running tasks, and then reweight each unlabeled task&rsquo;s prediction based on a weighting function of its feature space. We evaluate NURD on two production traces from Google and Alibaba, and find that compared to the best baseline approach, NURD produces 2&ndash;11 percentage point increases in the F1 score in terms of prediction accuracy, and 4.7&ndash;8.8 percentage point improvements in job completion time. <br /><br />In another project, we consider application developers who must continuously port code to new hardware. Consequently, much work has sought to predict application performance on new hardware. However, obtaining accurate performance predictions using only data from existing architectures has proven surprisingly difficult.&nbsp; Here we investigate a purely data-driven approach to predicting performance of a new architecture by using data collected from an old architecture.&nbsp; We profile a number of applications on an NVIDIA P100 and construct models to predict performance (specifically, memory behavior and IPC) of those same applications on an NVIDIA V100.&nbsp; We find that data from just eight of 112 performance counters are sufficient to (a) classify whether a compute-bound P100 application becomes memory bound on the V100 (with 99% accuracy), (b) predict achieved memory bandwidth with 6.8% mean absolute error for total memory throughput above 0.5 Vb/s, and (c) predict IPC with a mean absolute error of 8.82%. <br /><br />In the last project, we looked into the fact that machine learning-based performance models are increasingly being used to build critical job scheduling and application optimization decisions.&nbsp; Owing to the complexity and heterogeneity of production HPC systems, they are susceptible to hardware degradation, replacement, and/or software patches, which can lead to drift in the data distribution that can adversely affect the performance models. To this end, we develop continually learning performance models [MLFS '23] that account for the distribution drift, alleviate catastrophic forgetting, and improve generalizability. Our best model was able to retain accuracy, regardless of having to learn the new distribution of data inflicted by system changes, while demonstrating a 2&times; improvement in the prediction accuracy of the whole data sequence in comparison to the naive approach. <br /><br />Broader Impact: In terms of societal benefits, the NSF Strategic Plan for 2018-2022 states that \"society increasingly depends on complicated systems that are products of humanity&rsquo;s ingenuity [including ecosystems of large and complex] software with millions of lines of code&rdquo; and \"understanding and predicting the behavior of such systems is just as challenging as understanding the natural world\" and furthermore \"as society&rsquo;s reliance on complex systems grows, learning about their robustness and understanding how to strengthen them are of increasing importance.\" Our project addresses these problems.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 01/03/2023<br>\n\t\t\t\t\tModified by: Haryadi&nbsp;Gunawi</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nThe CP2 project is proposed to solve the problem of correctness checkability (CC) and performance predictability (PP) of systems at extreme scale.  This project produces several outcomes given the execution of the sub-projects below. \n\nOn correctness checkability, we analyzed hundreds real-world scalability faults in over a dozen of large scale systems.  Among these bugs, we dived into cancellation bugs [OSDI '22].  Modern software applications need to sometimes prematurely terminate or cancel a task, either to accommodate a conflicting task, to manage system resources, or in response to system or user events.  We studied 62 cancel-feature requests and 156 cancel-related bugs across 13 popular distributed and concurrent systems written in Java, C#, and Go to understand why task cancel is needed, what are the challenges in implementing task cancel, and how severe are cancel-related failures.  Guided by the study, we generalized a few cancel-related anti-patterns and implemented static checkers that found many code snippets matching these anti-patterns in the latest versions of these popular systems. \n\nIn another project, SVIEW, which is currently under submission, we built a framework for identifying and analyzing potential scalability faults in large-scale distributed systems.  SVIEW combines instrumentation and statistical concepts to identify dimensional code fragments (DCFs), pieces of code whose number of executions (e.g., loop iterations) is positively correlated with the increase in size of one or more system dimensions, with static analysis modules that detect faulty code patterns involving the DCFs.  We apply SVIEW to 4 popular distributed systems, identify hundreds of DCFs and use our analysis modules to detect known and unknown scalability faults \n\nOn performance predictability, we performed three projects.  The first one is about negative-unlabeled learning for online datacenter straggler prediction (NURD) [MLSys '22].  Datacenters execute large computational jobs where a job completes when all its tasks finish.  Accurately predicting straggling tasks would enable proactive intervention.  To predict stragglers accurately and early without labeled positive examples or assumptions on latency distributions, we built a novel Negative-Unlabeled learning approach with Reweighting and Distribution-compensation that only trains on negative and unlabeled streaming data. The key idea is to train a predictor using finished tasks of non-stragglers to predict latency for unlabeled running tasks, and then reweight each unlabeled task\u2019s prediction based on a weighting function of its feature space. We evaluate NURD on two production traces from Google and Alibaba, and find that compared to the best baseline approach, NURD produces 2&ndash;11 percentage point increases in the F1 score in terms of prediction accuracy, and 4.7&ndash;8.8 percentage point improvements in job completion time. \n\nIn another project, we consider application developers who must continuously port code to new hardware. Consequently, much work has sought to predict application performance on new hardware. However, obtaining accurate performance predictions using only data from existing architectures has proven surprisingly difficult.  Here we investigate a purely data-driven approach to predicting performance of a new architecture by using data collected from an old architecture.  We profile a number of applications on an NVIDIA P100 and construct models to predict performance (specifically, memory behavior and IPC) of those same applications on an NVIDIA V100.  We find that data from just eight of 112 performance counters are sufficient to (a) classify whether a compute-bound P100 application becomes memory bound on the V100 (with 99% accuracy), (b) predict achieved memory bandwidth with 6.8% mean absolute error for total memory throughput above 0.5 Vb/s, and (c) predict IPC with a mean absolute error of 8.82%. \n\nIn the last project, we looked into the fact that machine learning-based performance models are increasingly being used to build critical job scheduling and application optimization decisions.  Owing to the complexity and heterogeneity of production HPC systems, they are susceptible to hardware degradation, replacement, and/or software patches, which can lead to drift in the data distribution that can adversely affect the performance models. To this end, we develop continually learning performance models [MLFS '23] that account for the distribution drift, alleviate catastrophic forgetting, and improve generalizability. Our best model was able to retain accuracy, regardless of having to learn the new distribution of data inflicted by system changes, while demonstrating a 2&times; improvement in the prediction accuracy of the whole data sequence in comparison to the naive approach. \n\nBroader Impact: In terms of societal benefits, the NSF Strategic Plan for 2018-2022 states that \"society increasingly depends on complicated systems that are products of humanity\u2019s ingenuity [including ecosystems of large and complex] software with millions of lines of code\" and \"understanding and predicting the behavior of such systems is just as challenging as understanding the natural world\" and furthermore \"as society\u2019s reliance on complex systems grows, learning about their robustness and understanding how to strengthen them are of increasing importance.\" Our project addresses these problems.\n\n\t\t\t\t\tLast Modified: 01/03/2023\n\n\t\t\t\t\tSubmitted by: Haryadi Gunawi"
 }
}