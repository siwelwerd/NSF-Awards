{
 "awd_id": "1953933",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SaTC: CORE: Small: Collaborative: Deep and Efficient Dynamic Analysis of Operating System Kernels",
 "cfda_num": "47.070",
 "org_code": "05050000",
 "po_phone": "7032927841",
 "po_email": "sgreensp@nsf.gov",
 "po_sign_block_name": "Sol Greenspan",
 "awd_eff_date": "2020-07-15",
 "awd_exp_date": "2024-06-30",
 "tot_intn_awd_amt": 250000.0,
 "awd_amount": 250000.0,
 "awd_min_amd_letter_date": "2020-07-09",
 "awd_max_amd_letter_date": "2020-07-09",
 "awd_abstract_narration": "The objective of this project is to improve the security of operating system (OS) kernels through deep analysis and testing. OS kernels are the foundation of computer systems such as personal computers, smartphones, servers, as well as the Internet infrastructure in general. Modern OS kernels are enormously complex and contain a large number of security vulnerabilities that slip through the testing phase onto end devices. Unfortunately, the state-of-the-art testing solution is insufficient as deeper parts of the OS remain hard-to-reach and therefore largely untested. The project aims to solve this precise issue by developing a set of innovative dynamic analysis and testing techniques that will greatly improve the security and quality of OS kernels. The results will benefit the security of virtually all computing devices.  \r\n\r\nThe state-of-the-art testing technique for OS kernels is called fuzz testing, which generates random inputs in the hope that they will exercise various parts of the kernel code. It has two unique bottlenecks: (1) space bottlenecks that prevent the fuzzer from reaching desired code blocks and triggering potential vulnerabilities, i.e., dependencies among syscalls, and (2) time bottlenecks that force the fuzzer to stop its execution for some period of time, resulting in wasted fuzz time, i.e., repetitive reboots where the same bugs are triggered repetitively. The project will develop a set of program analysis techniques to improve fuzz testing of OS kernels by making the fuzzer more intelligent in resolving dependencies and by helping it avoid repetitive reboots.\r\n\r\nThis award reflects NSF's statutory mission and has been deemed worthy of support through evaluation using the Foundation's intellectual merit and broader impacts review criteria.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CNS",
 "org_div_long_name": "Division Of Computer and Network Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Zhiyun",
   "pi_last_name": "Qian",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Zhiyun Qian",
   "pi_email_addr": "zhiyun.qian@ucr.edu",
   "nsf_id": "000677475",
   "pi_start_date": "2020-07-09",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of California-Riverside",
  "inst_street_address": "200 UNIVERSTY OFC BUILDING",
  "inst_street_address_2": "",
  "inst_city_name": "RIVERSIDE",
  "inst_state_code": "CA",
  "inst_state_name": "California",
  "inst_phone_num": "9518275535",
  "inst_zip_code": "925210001",
  "inst_country_name": "United States",
  "cong_dist_code": "39",
  "st_cong_dist_code": "CA39",
  "org_lgl_bus_name": "REGENTS OF THE UNIVERSITY OF CALIFORNIA AT RIVERSIDE",
  "org_prnt_uei_num": "",
  "org_uei_num": "MR5QC5FCAVH5"
 },
 "perf_inst": {
  "perf_inst_name": "University of California, Riverside",
  "perf_str_addr": "900 University Avenue",
  "perf_city_name": "Riverside",
  "perf_st_code": "CA",
  "perf_st_name": "California",
  "perf_zip_code": "925210001",
  "perf_ctry_code": "US",
  "perf_cong_dist": "39",
  "perf_st_cong_dist": "CA39",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "806000",
   "pgm_ele_name": "Secure &Trustworthy Cyberspace"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "025Z",
   "pgm_ref_txt": "SaTC: Secure and Trustworthy Cyberspace"
  },
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  }
 ],
 "app_fund": [
  {
   "app_code": "0120",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01002021DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2020,
   "fund_oblg_amt": 250000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p><span id=\"docs-internal-guid-491b52c4-7fff-43cb-825f-885dc922c354\">\n<p dir=\"ltr\"><span>The objective of this project was to improve the security of operating system (OS) kernels through deep analysis and testing. OS kernels are the foundation of computer systems such as personal computers, smartphones, servers, as well as the Internet infrastructure in general. Modern OS kernels are enormously complex and contain a large number of security vulnerabilities that slip through the testing phase onto end devices. Unfortunately, the state-of-the-art testing solution is insufficient as deeper parts of the OS remain hard to reach and therefore largely untested. The project aimed to solve this precise issue by developing a set of innovative dynamic analysis and testing techniques that will greatly improve the security and quality of OS kernels. The results will benefit the security of virtually all computing devices.</span></p>\n<p dir=\"ltr\"><span>The team conducted studies and built systems to achieve this goal.</span></p>\n<p dir=\"ltr\"><span>First, we worked on dependency-oriented fuzzing. We presented a comprehensive measurement study to understand the prevalence of dependencies and more importantly the root causes of failures in satisfying dependencies during fuzzing. We showed that even for well-fuzzed kernel modules, unresolved dependencies still account for 59% - 88% of the uncovered branches. Furthermore, we showed that the dependency challenge is only a symptom rather than the root cause of failing to achieve more coverage. By distilling and summarizing our findings, we believe the research provided valuable guidance for future research in kernel fuzzing.</span></p>\n<p dir=\"ltr\"><span>Second, we developed a static analysis solution called SyzDescribe that can automatically identify certain types of syscall dependencies, i.e., one syscall returning a file descriptor and another subsequently using it. We presented a detailed analysis and modeling of the Linux kernel programming convention. In particular, we studied how kernel drivers are initialized and syscall handlers are set up during the process. By applying the static analysis solution over 100 Linux kernel drivers, we extracted the syscall descriptions regarding a given kernel driver, including the syscall dependencies, which are encoded in the descriptions for better fuzzing.&nbsp; We showed that the syscall descriptions produced by SyzDescribe are competitive to manually-curated ones, and much better than prior work.</span></p>\n<p dir=\"ltr\"><span>Third, we also developed a solution to systematically analyze syscall handlers and recover argument types, value ranges for syscall interfaces. We presented a detailed analysis approach that has an advanced symbolic pointer reasoning component. This allowed us to recover more complete syscall descriptions, as demonstrated in 10 drivers whose descriptions generated by SyzDescribe were known to have room for improvement.</span></p>\n<p dir=\"ltr\"><span>Fourth, we worked on reboot-free fuzzing. We introduced bowknots, an instrumentation that can be added to each bug location in order to undo the bug trigger. Moreover, we introduced Hecaton, a tool that can mostly automatically generate bowknots.</span></p>\n<p dir=\"ltr\"><span>Fifth, we developed a dynamic analysis tool, SyzRetrospector, to understand the performance of Syzbot (the state-of-the-art continuous fuzzer from Google), over the past 6 years. SyzRetrospector goes back in time to analyze when a bug was actually findable and uses that to calculate a more accurate performance metric for Syzbot. We analyzed 559 bugs using about 10,000 CPU hours. We found that bugs are hidden for an average of 331.17 days before Syzbot is even able to find them. We further presented findings on the behaviors of revealing factors, how some bugs are harder to reveal than others, the trends in delays over the past 6 years, and how bug location relates to delays. We also provided key takeaways for improving Syzbot&rsquo;s delays.</span></p>\n<p dir=\"ltr\"><span>Finally, our experience with the analysis and fuzzing of commodity operating systems and their kernels have helped us identify the reasons behind bugs and vulnerabilities in them, which are security concerns. Therefore, we worked on several directions to built more secure operating system-based solution such as OctopOS (a secure operating system running a physically-isolated hardware), Hora (an operating system that can provide a strong periodic availability guarantee), ProvCam (a secure camera that executes its own software stack including driver), and GLeeFuzz (a fuzzer for the WebGL interface).</span></p>\n<br /></span></p>\n<p>&nbsp;</p><br>\n<p>\n Last Modified: 10/28/2024<br>\nModified by: Zhiyun&nbsp;Qian</p></div>\n<div class=\"porSideCol\"\n></div>\n</div>\n",
  "por_txt_cntn": "\n\n\n\n\nThe objective of this project was to improve the security of operating system (OS) kernels through deep analysis and testing. OS kernels are the foundation of computer systems such as personal computers, smartphones, servers, as well as the Internet infrastructure in general. Modern OS kernels are enormously complex and contain a large number of security vulnerabilities that slip through the testing phase onto end devices. Unfortunately, the state-of-the-art testing solution is insufficient as deeper parts of the OS remain hard to reach and therefore largely untested. The project aimed to solve this precise issue by developing a set of innovative dynamic analysis and testing techniques that will greatly improve the security and quality of OS kernels. The results will benefit the security of virtually all computing devices.\n\n\nThe team conducted studies and built systems to achieve this goal.\n\n\nFirst, we worked on dependency-oriented fuzzing. We presented a comprehensive measurement study to understand the prevalence of dependencies and more importantly the root causes of failures in satisfying dependencies during fuzzing. We showed that even for well-fuzzed kernel modules, unresolved dependencies still account for 59% - 88% of the uncovered branches. Furthermore, we showed that the dependency challenge is only a symptom rather than the root cause of failing to achieve more coverage. By distilling and summarizing our findings, we believe the research provided valuable guidance for future research in kernel fuzzing.\n\n\nSecond, we developed a static analysis solution called SyzDescribe that can automatically identify certain types of syscall dependencies, i.e., one syscall returning a file descriptor and another subsequently using it. We presented a detailed analysis and modeling of the Linux kernel programming convention. In particular, we studied how kernel drivers are initialized and syscall handlers are set up during the process. By applying the static analysis solution over 100 Linux kernel drivers, we extracted the syscall descriptions regarding a given kernel driver, including the syscall dependencies, which are encoded in the descriptions for better fuzzing. We showed that the syscall descriptions produced by SyzDescribe are competitive to manually-curated ones, and much better than prior work.\n\n\nThird, we also developed a solution to systematically analyze syscall handlers and recover argument types, value ranges for syscall interfaces. We presented a detailed analysis approach that has an advanced symbolic pointer reasoning component. This allowed us to recover more complete syscall descriptions, as demonstrated in 10 drivers whose descriptions generated by SyzDescribe were known to have room for improvement.\n\n\nFourth, we worked on reboot-free fuzzing. We introduced bowknots, an instrumentation that can be added to each bug location in order to undo the bug trigger. Moreover, we introduced Hecaton, a tool that can mostly automatically generate bowknots.\n\n\nFifth, we developed a dynamic analysis tool, SyzRetrospector, to understand the performance of Syzbot (the state-of-the-art continuous fuzzer from Google), over the past 6 years. SyzRetrospector goes back in time to analyze when a bug was actually findable and uses that to calculate a more accurate performance metric for Syzbot. We analyzed 559 bugs using about 10,000 CPU hours. We found that bugs are hidden for an average of 331.17 days before Syzbot is even able to find them. We further presented findings on the behaviors of revealing factors, how some bugs are harder to reveal than others, the trends in delays over the past 6 years, and how bug location relates to delays. We also provided key takeaways for improving Syzbots delays.\n\n\nFinally, our experience with the analysis and fuzzing of commodity operating systems and their kernels have helped us identify the reasons behind bugs and vulnerabilities in them, which are security concerns. Therefore, we worked on several directions to built more secure operating system-based solution such as OctopOS (a secure operating system running a physically-isolated hardware), Hora (an operating system that can provide a strong periodic availability guarantee), ProvCam (a secure camera that executes its own software stack including driver), and GLeeFuzz (a fuzzer for the WebGL interface).\n\n\n\n\n\t\t\t\t\tLast Modified: 10/28/2024\n\n\t\t\t\t\tSubmitted by: ZhiyunQian\n"
 }
}