{
 "awd_id": "2008369",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Small: Programming with Semantic Revision Requests",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927885",
 "po_email": "abanerje@nsf.gov",
 "po_sign_block_name": "Anindya Banerjee",
 "awd_eff_date": "2020-06-01",
 "awd_exp_date": "2024-05-31",
 "tot_intn_awd_amt": 499234.0,
 "awd_amount": 499234.0,
 "awd_min_amd_letter_date": "2020-05-22",
 "awd_max_amd_letter_date": "2020-05-22",
 "awd_abstract_narration": "Software development today is a social process, and the workflow of\r\nprogrammers is increasingly centered around discussing program\r\nrevisions - that is, artifacts that document small, incremental program\r\nchanges. Meanwhile, traditional research on testing, debugging, and analyzing\r\nprograms focuses on one program version at a time, ignoring any preceding or\r\nsucceeding versions of the same software artifact. The project's novelties\r\nare a foundational examination of program revisions and the investigation of\r\nautomated techniques that cooperatively assist software-engineering teams\r\nwith reasoning about them. The project's impacts are to enhance the way\r\nengineering teams collaboratively evolve their software and thus enable them\r\nto more effectively create secure and reliable software on which society\r\ndepends.\r\n\r\nThe project's core contribution is defining the notion of a \"semantic\r\nrevision request\" that enables treating program revisions as first-class\r\nentities for debugging and analysis tools. A semantic view of program\r\nrevisions enables programmers to run or analyze the program revision (both\r\nbefore and after a change simultaneously), not merely each of the two program\r\nversions, as supported by today's conventional tools. By focusing on\r\ndebugging and analyzing program revisions - not their individual program\r\nversions - the resulting tools come closer to capturing the intent of the\r\nprogrammer as they develop and commit program changes. The intended broader\r\nimpact from a technical perspective is that these executable and analyzable\r\nspecifications will supplement, or even replace, informal descriptions about\r\nhow software systems evolve, by providing an unambiguous way to communicate\r\nhigh-level programmer intent.\r\n\r\nThis award reflects NSF's statutory mission and has been deemed worthy of support through evaluation using the Foundation's intellectual merit and broader impacts review criteria.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Bor-Yuh Evan",
   "pi_last_name": "Chang",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Bor-Yuh Evan Chang",
   "pi_email_addr": "evan.chang@colorado.edu",
   "nsf_id": "000512429",
   "pi_start_date": "2020-05-22",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Colorado at Boulder",
  "inst_street_address": "3100 MARINE ST",
  "inst_street_address_2": "STE 481 572 UCB",
  "inst_city_name": "Boulder",
  "inst_state_code": "CO",
  "inst_state_name": "Colorado",
  "inst_phone_num": "3034926221",
  "inst_zip_code": "803090001",
  "inst_country_name": "United States",
  "cong_dist_code": "02",
  "st_cong_dist_code": "CO02",
  "org_lgl_bus_name": "THE REGENTS OF THE UNIVERSITY OF COLORADO",
  "org_prnt_uei_num": "",
  "org_uei_num": "SPVKK1RC2MZ3"
 },
 "perf_inst": {
  "perf_inst_name": "University of Colorado Boulder",
  "perf_str_addr": "3100 Marine St, Room 481, 572 UC",
  "perf_city_name": "Boulder",
  "perf_st_code": "CO",
  "perf_st_name": "Colorado",
  "perf_zip_code": "803031058",
  "perf_ctry_code": "US",
  "perf_cong_dist": "02",
  "perf_st_cong_dist": "CO02",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7943",
   "pgm_ref_txt": "PROGRAMMING LANGUAGES"
  }
 ],
 "app_fund": [
  {
   "app_code": "0120",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01002021DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2020,
   "fund_oblg_amt": 499234.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>The goal of this project is to address a fundamental challenge in software development: understanding and verifying program revisions. Existing techniques to help developers reason automatically about their software typically considers the \"before\" and \"after\" versions of the program independently. However, this approach does not capture how modern software engineering works --- where engineers incrementally review revisions to an existing code base. This project investigates analyzing program revisions as first-class entities, enabling developers to reason about both versions simultaneously and gain deeper insights into how a change affects program behavior.</p>\n<p><br />Initially, the project focused on laying the groundwork for analyzing program revisions through incremental and demand-driven program analysis. The primary goal was to create techniques that could reuse results from analyzing the old version while targeting the reasoning on the new version to specific changes in question. The result was the Demanded Abstract Interpretation (DAI) framework, which provides an incremental and demand-driven approach to abstract interpretation, making it possible to reuse the same abstract domains from a classical batch analysis in a new incremental and demand-driven engine. A key result was doing so with a guarantee of being consistent with a from-scratch analysis result.</p>\n<p><br />Then, the project expanded on the initial framework by investigating the complexities of interprocedural analysis, that is, analysis that respects the procedural abstraction of software development, with an incremental and demand-driven analysis framework. By focusing on techniques for making summary-based interprocedural analysis demanded, the project arrived at an approach for incremental and demand-driven interprocedural analysis that again made it possible to reuse the same abstract domains from a classical batch analysis in a new incremental and demand-driven engine while guaranteeing from-scratch consistent results.</p>\n<p><br />Subsequently, the project pivoted slightly toward addressing the specific challenges posed by event-driven systems, such as mobile applications, which have become increasingly prevalent in modern software development. These systems often involve complex, asynchronous interactions between the app code and a large, opaque framework, making them particularly difficult to analyze. The project developed message history logics, a novel technique for reasoning about how an app interacts with its framework context. Unlike traditional approaches that require eager, up-front modeling of all possible interactions, message history logics allow the system to incrementally build a model of interactions as needed to verify specific properties or goals. This approach enabled the project to successfully demonstrate the identification bugs in a \"before\" version and the verification of the fix of the \"after\" version in several real, reported issues in open-source Android applications. All of these issues involve complex, multi-object and multi-callback interactions that were beyond the scope of prior approaches.</p><br>\n<p>\n Last Modified: 11/10/2024<br>\nModified by: Bor-Yuh Evan&nbsp;Chang</p></div>\n<div class=\"porSideCol\"\n></div>\n</div>\n",
  "por_txt_cntn": "\n\nThe goal of this project is to address a fundamental challenge in software development: understanding and verifying program revisions. Existing techniques to help developers reason automatically about their software typically considers the \"before\" and \"after\" versions of the program independently. However, this approach does not capture how modern software engineering works --- where engineers incrementally review revisions to an existing code base. This project investigates analyzing program revisions as first-class entities, enabling developers to reason about both versions simultaneously and gain deeper insights into how a change affects program behavior.\n\n\n\nInitially, the project focused on laying the groundwork for analyzing program revisions through incremental and demand-driven program analysis. The primary goal was to create techniques that could reuse results from analyzing the old version while targeting the reasoning on the new version to specific changes in question. The result was the Demanded Abstract Interpretation (DAI) framework, which provides an incremental and demand-driven approach to abstract interpretation, making it possible to reuse the same abstract domains from a classical batch analysis in a new incremental and demand-driven engine. A key result was doing so with a guarantee of being consistent with a from-scratch analysis result.\n\n\n\nThen, the project expanded on the initial framework by investigating the complexities of interprocedural analysis, that is, analysis that respects the procedural abstraction of software development, with an incremental and demand-driven analysis framework. By focusing on techniques for making summary-based interprocedural analysis demanded, the project arrived at an approach for incremental and demand-driven interprocedural analysis that again made it possible to reuse the same abstract domains from a classical batch analysis in a new incremental and demand-driven engine while guaranteeing from-scratch consistent results.\n\n\n\nSubsequently, the project pivoted slightly toward addressing the specific challenges posed by event-driven systems, such as mobile applications, which have become increasingly prevalent in modern software development. These systems often involve complex, asynchronous interactions between the app code and a large, opaque framework, making them particularly difficult to analyze. The project developed message history logics, a novel technique for reasoning about how an app interacts with its framework context. Unlike traditional approaches that require eager, up-front modeling of all possible interactions, message history logics allow the system to incrementally build a model of interactions as needed to verify specific properties or goals. This approach enabled the project to successfully demonstrate the identification bugs in a \"before\" version and the verification of the fix of the \"after\" version in several real, reported issues in open-source Android applications. All of these issues involve complex, multi-object and multi-callback interactions that were beyond the scope of prior approaches.\t\t\t\t\tLast Modified: 11/10/2024\n\n\t\t\t\t\tSubmitted by: Bor-Yuh EvanChang\n"
 }
}