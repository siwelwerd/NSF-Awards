{
 "awd_id": "2028733",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "Collaborative Research: PPoSS: Planning: Fixpoint: an operating system and architecture for data-centric computing",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032925197",
 "po_email": "mmcclure@nsf.gov",
 "po_sign_block_name": "Marilyn McClure",
 "awd_eff_date": "2020-10-01",
 "awd_exp_date": "2022-09-30",
 "tot_intn_awd_amt": 125000.0,
 "awd_amount": 125000.0,
 "awd_min_amd_letter_date": "2020-08-25",
 "awd_max_amd_letter_date": "2020-10-14",
 "awd_abstract_narration": "Computer operating systems run programs that read input data and produce output data. However, today's operating systems generally don't keep track of enough information to make sure that the process of generating a given piece of data can be reproduced, especially when the program that produced it may have considered input that came over the network, from a mutable file on disk, or from a non-deterministic phenomenon such as thread scheduling. This project will design a new kind of operating system, called Fixpoint, that explicitly represents and names computations on data: each invocation of a program, in terms of its minimal data-dependencies, in a reproducible content-addressed manner. If successful, the project will have a significant impact on how computer systems are used every day. By making all computation reproducible by default and trivially shareable, Fixpoint can improve scientific reproducibility and as a consequence increase the public's confidence in scientific results. \r\n\r\nThe hypothesis of this project is that by changing the way software is represented, substantial benefits can be unlocked in the areas of scalability, security, efficiency, performance, and reproducibility. Fixpoint's operating-system-visible dataflow will give it an ability to take advantage of massive transient parallelism, which means that parallel tasks that effectively require batch-processing today -- submitting jobs to servers and waiting hours -- will become near real-time. This will change the kinds of operations that people expect to do interactively at a computer. Errors discovered in data, even after the fact, can be backed out of computations that depend on them, similar to recalculating a spreadsheet today.\r\n\r\nThis award reflects NSF's statutory mission and has been deemed worthy of support through evaluation using the Foundation's intellectual merit and broader impacts review criteria.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Keith",
   "pi_last_name": "Winstein",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Keith Winstein",
   "pi_email_addr": "keithw@cs.stanford.edu",
   "nsf_id": "000682184",
   "pi_start_date": "2020-08-25",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "David",
   "pi_last_name": "Mazi\u00e8res",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "David Mazi\u00e8res",
   "pi_email_addr": "dm-list-sup-nsf14@scs.stanford.edu",
   "nsf_id": "000100121",
   "pi_start_date": "2020-08-25",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Stanford University",
  "inst_street_address": "450 JANE STANFORD WAY",
  "inst_street_address_2": "",
  "inst_city_name": "STANFORD",
  "inst_state_code": "CA",
  "inst_state_name": "California",
  "inst_phone_num": "6507232300",
  "inst_zip_code": "943052004",
  "inst_country_name": "United States",
  "cong_dist_code": "16",
  "st_cong_dist_code": "CA16",
  "org_lgl_bus_name": "THE LELAND STANFORD JUNIOR UNIVERSITY",
  "org_prnt_uei_num": "",
  "org_uei_num": "HJD6G4D6TJY5"
 },
 "perf_inst": {
  "perf_inst_name": "Stanford University",
  "perf_str_addr": "450 Jane Stanford Way",
  "perf_city_name": "Stanford",
  "perf_st_code": "CA",
  "perf_st_name": "California",
  "perf_zip_code": "943059025",
  "perf_ctry_code": "US",
  "perf_cong_dist": "16",
  "perf_st_cong_dist": "CA16",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "042Y00",
   "pgm_ele_name": "PPoSS-PP of Scalable Systems"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "026Z",
   "pgm_ref_txt": "NSCI: National Strategic Computing Initi"
  }
 ],
 "app_fund": [
  {
   "app_code": "0120",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01002021DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2020,
   "fund_oblg_amt": 125000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>In this planning-grant project, we explored putting <em>computation</em> at the center of what networked computers and cloud services do for their users. We envision a shared representation of a computation: a deterministic procedure, run in an environment of well-specified dependencies. This suggests an end-to-end argument for serverless computing, shifting the service model from &ldquo;renting CPUs by the second&rdquo; to &ldquo;providing the unambiguously correct result of a computation.&rdquo; Accountability to these higher-level abstractions could permit agility and innovation on other axes.</p>\n<p>While classical &ldquo;infrastructure-as-a-service&rdquo; cloud computing involves renting a virtual server and paying by the second, current &ldquo;function-as-a-service&rdquo; offerings provide almost the same service model: renting an x86 or ARM worker and paying by the tenth of a second until a task completes. Providers have little visibility into client dataflow, which translates into inefficient placement and poor utilization. When most jobs spend most of their time waiting for bytes to arrive from across the network, even a clever provider has little ability (or incentive) to improve the situation.<br /><br />In this project, we explored the idea that the root cause of these challenges is an underconstrained notion of networked computation. We developed a research agenda centered around what we call &ldquo;computation-centric networking&rdquo;: the idea that a networked service&rsquo;s job is primarily to provide answers to computations and would benefit from (1) fine-grained visibility into application dataflow, (2) an objective, common notion of correctness, and (3) a separation between I/O and compute, with delineated nondeterminism.</p>\n<p>In our view, successfully realizing this vision would:<br />&bull; let networked systems track the computational relationships between artifacts, so that sharing a reproducible pipeline is as simple as a git push / git pull / &ldquo;git reproduce\",<br />&bull; guarantee reproducibility of server-side algorithms that process data on a user&rsquo;s behalf,<br />&bull; allow rerunning a computational pipeline with modified code or data, to discover the consequences of, and clean up after, an intrusion, and<br />&bull; benefit &ldquo;serverless&rdquo; providers and customers. Providers would have the flexibility to schedule and place jobs in a way that minimizes dataflow and maximizes utilization, as long as they reach the correct answer. If the customer chooses to double-check a result and finds the provider was mistaken, they&rsquo;d be able to collect from the provider&rsquo;s insurance. That, in turn, might free the customer to bid jobs out to competing providers. Our theory is akin to an end-to-end argument [ 21]: accountability to one high-level abstraction (correctness) can create agility on other axes.<br /><br />We have begun to design and implement a framework for computation-centric networking, which we call Fixpoint. We are defining a low-level, lightweight<br />representation for deterministic computations-on-named-data,<br />known as &ldquo;Fix.&rdquo; To represent the relationships between code<br />and data, Fix defines an addressing scheme that allows data to<br />be identified either in terms of its contents (similar to systems<br />like Git, BitTorrent, and IPFS) or by referring to a deter-<br />ministic computation that computes it. The Fixpoint system<br />includes a compiler that transforms Fix into raw machine<br />codelets, and runtime engines that evaluate such codelets on<br />various platforms: multicore computers, clusters, and server-<br />less computing platforms.</p>\n<p>Our preliminary benchmarks have found that these abstrac-<br />tions are lightweight enough to let Fixpoint provide isolation<br />and reproducibility with overhead close to an ordinary virtual<br />function call. On a recent x86-64 CPU and Linux kernel, Fix-<br />point&rsquo;s invocation overhead is about 37&times; faster than vforking a<br />process, and about 531&times; faster than record-replay techniques<br />such as rr. The raw invocation overhead is roughly 50 ns,<br />about 5&times; as slow as a virtual function call in C++.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 07/14/2023<br>\n\t\t\t\t\tModified by: Keith&nbsp;Winstein</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nIn this planning-grant project, we explored putting computation at the center of what networked computers and cloud services do for their users. We envision a shared representation of a computation: a deterministic procedure, run in an environment of well-specified dependencies. This suggests an end-to-end argument for serverless computing, shifting the service model from \"renting CPUs by the second\" to \"providing the unambiguously correct result of a computation.\" Accountability to these higher-level abstractions could permit agility and innovation on other axes.\n\nWhile classical \"infrastructure-as-a-service\" cloud computing involves renting a virtual server and paying by the second, current \"function-as-a-service\" offerings provide almost the same service model: renting an x86 or ARM worker and paying by the tenth of a second until a task completes. Providers have little visibility into client dataflow, which translates into inefficient placement and poor utilization. When most jobs spend most of their time waiting for bytes to arrive from across the network, even a clever provider has little ability (or incentive) to improve the situation.\n\nIn this project, we explored the idea that the root cause of these challenges is an underconstrained notion of networked computation. We developed a research agenda centered around what we call \"computation-centric networking\": the idea that a networked service\u2019s job is primarily to provide answers to computations and would benefit from (1) fine-grained visibility into application dataflow, (2) an objective, common notion of correctness, and (3) a separation between I/O and compute, with delineated nondeterminism.\n\nIn our view, successfully realizing this vision would:\n&bull; let networked systems track the computational relationships between artifacts, so that sharing a reproducible pipeline is as simple as a git push / git pull / \"git reproduce\",\n&bull; guarantee reproducibility of server-side algorithms that process data on a user\u2019s behalf,\n&bull; allow rerunning a computational pipeline with modified code or data, to discover the consequences of, and clean up after, an intrusion, and\n&bull; benefit \"serverless\" providers and customers. Providers would have the flexibility to schedule and place jobs in a way that minimizes dataflow and maximizes utilization, as long as they reach the correct answer. If the customer chooses to double-check a result and finds the provider was mistaken, they\u2019d be able to collect from the provider\u2019s insurance. That, in turn, might free the customer to bid jobs out to competing providers. Our theory is akin to an end-to-end argument [ 21]: accountability to one high-level abstraction (correctness) can create agility on other axes.\n\nWe have begun to design and implement a framework for computation-centric networking, which we call Fixpoint. We are defining a low-level, lightweight\nrepresentation for deterministic computations-on-named-data,\nknown as \"Fix.\" To represent the relationships between code\nand data, Fix defines an addressing scheme that allows data to\nbe identified either in terms of its contents (similar to systems\nlike Git, BitTorrent, and IPFS) or by referring to a deter-\nministic computation that computes it. The Fixpoint system\nincludes a compiler that transforms Fix into raw machine\ncodelets, and runtime engines that evaluate such codelets on\nvarious platforms: multicore computers, clusters, and server-\nless computing platforms.\n\nOur preliminary benchmarks have found that these abstrac-\ntions are lightweight enough to let Fixpoint provide isolation\nand reproducibility with overhead close to an ordinary virtual\nfunction call. On a recent x86-64 CPU and Linux kernel, Fix-\npoint\u2019s invocation overhead is about 37&times; faster than vforking a\nprocess, and about 531&times; faster than record-replay techniques\nsuch as rr. The raw invocation overhead is roughly 50 ns,\nabout 5&times; as slow as a virtual function call in C++.\n\n\t\t\t\t\tLast Modified: 07/14/2023\n\n\t\t\t\t\tSubmitted by: Keith Winstein"
 }
}