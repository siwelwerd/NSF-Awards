{
 "awd_id": "1812522",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SaTC: CORE: Small: verifying security for data non-interference",
 "cfda_num": "47.070",
 "org_code": "05050000",
 "po_phone": "7032922981",
 "po_email": "pregalia@nsf.gov",
 "po_sign_block_name": "Phillip Regalia",
 "awd_eff_date": "2018-09-01",
 "awd_exp_date": "2022-08-31",
 "tot_intn_awd_amt": 500000.0,
 "awd_amount": 500000.0,
 "awd_min_amd_letter_date": "2018-08-10",
 "awd_max_amd_letter_date": "2018-08-10",
 "awd_abstract_narration": "Many security problems today stem from bugs in software. Although there has been significant effort in reducing bugs through better testing, fuzzing, model checking, and so on, subtle bugs remain and continue to be exploited. This proposal explores the use of formal verification to prove security of a file system implementation along with an example application in the form of a mail server. Machine-checked verification is a powerful approach that can eliminate a large class of bugs in software by proving that an implementation meets a precise specification. As long as the specification rules out a certain class of bugs, the machine-checked proof will ensure no such bugs can exist in the implementation. This project develops techniques for proving security of sophisticated applications, such as proving that a mail server will not inappropriately disclose confidential email messages. At the high level, the impact of this work will be a more secure software infrastructure.\r\n\r\nThe key technical challenge that this project focuses on is data confidentiality. The project explores approaches for specifying confidentiality of systems software, including a mail server and a POSIX file system, as well as a framework for implementation and  machine-checked verification of confidentiality properties for these applications.  The project also develops common infrastructure that such applications depend on, including a formal security specification for a POSIX file system and verified implementations of a mail server and a file system with proofs of security, which will be useful to the broader community. Finally, part of the project involves developing course modules focused on machine-checked proofs of correctness and security for systems software.\r\n\r\nThis award reflects NSF's statutory mission and has been deemed worthy of support through evaluation using the Foundation's intellectual merit and broader impacts review criteria.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CNS",
 "org_div_long_name": "Division Of Computer and Network Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Nickolai",
   "pi_last_name": "Zeldovich",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Nickolai Zeldovich",
   "pi_email_addr": "nickolai@csail.mit.edu",
   "nsf_id": "000520788",
   "pi_start_date": "2018-08-10",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Marinus",
   "pi_last_name": "Kaashoek",
   "pi_mid_init": "F",
   "pi_sufx_name": "",
   "pi_full_name": "Marinus F Kaashoek",
   "pi_email_addr": "kaashoek@lcs.mit.edu",
   "nsf_id": "000098539",
   "pi_start_date": "2018-08-10",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Robert",
   "pi_last_name": "Morris",
   "pi_mid_init": "T",
   "pi_sufx_name": "",
   "pi_full_name": "Robert T Morris",
   "pi_email_addr": "rtm@csail.mit.edu",
   "nsf_id": "000471357",
   "pi_start_date": "2018-08-10",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Adam",
   "pi_last_name": "Chlipala",
   "pi_mid_init": "J",
   "pi_sufx_name": "",
   "pi_full_name": "Adam J Chlipala",
   "pi_email_addr": "adamc@csail.mit.edu",
   "nsf_id": "000610723",
   "pi_start_date": "2018-08-10",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Massachusetts Institute of Technology",
  "inst_street_address": "77 MASSACHUSETTS AVE",
  "inst_street_address_2": "",
  "inst_city_name": "CAMBRIDGE",
  "inst_state_code": "MA",
  "inst_state_name": "Massachusetts",
  "inst_phone_num": "6172531000",
  "inst_zip_code": "021394301",
  "inst_country_name": "United States",
  "cong_dist_code": "07",
  "st_cong_dist_code": "MA07",
  "org_lgl_bus_name": "MASSACHUSETTS INSTITUTE OF TECHNOLOGY",
  "org_prnt_uei_num": "E2NYLCDML6V1",
  "org_uei_num": "E2NYLCDML6V1"
 },
 "perf_inst": {
  "perf_inst_name": "Massachusetts Institute of Technology",
  "perf_str_addr": "",
  "perf_city_name": "",
  "perf_st_code": "MA",
  "perf_st_name": "Massachusetts",
  "perf_zip_code": "021394307",
  "perf_ctry_code": "US",
  "perf_cong_dist": "07",
  "perf_st_cong_dist": "MA07",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "806000",
   "pgm_ele_name": "Secure &Trustworthy Cyberspace"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "025Z",
   "pgm_ref_txt": "SaTC: Secure and Trustworthy Cyberspace"
  },
  {
   "pgm_ref_code": "7434",
   "pgm_ref_txt": "CNCI"
  },
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  }
 ],
 "app_fund": [
  {
   "app_code": "0118",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001819DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2018,
   "fund_oblg_amt": 500000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p><span> Many security problems today stem from bugs in software. &nbsp;Although there has been significant effort to reduce bugs through better testing, fuzzing, model checking, and so on, subtle bugs remain and continue to be exploited. &nbsp;A powerful approach, taken by this project, is to use machine-checked formal verification to rule out whole classes of bugs.&nbsp; With formal verification, a rigorous machine-checked proof ensures that the implementation of the system precisely meets its specification, which means there are no bugs that can violate the spec and lead to a security vulnerability.</span><br /><br /><span>One key contribution of this project lies in formulating a way of&nbsp;</span><span>specifying what it means for storage systems, like a file system,&nbsp;</span><span>to keep data confidential. &nbsp;The most common approach for specifying&nbsp;</span><span>confidentiality, called non-interference, is too strict for realistic&nbsp;</span><span>file systems, because some information (such as the amount of disk&nbsp;</span><span>space used, or the names of files) might be allowed to leak from one&nbsp;</span><span>user to another, even if the contents of the files themselves are&nbsp;</span><span>protected. &nbsp;Confidentiality definitions have also had trouble handling&nbsp;</span><span>non-deterministic systems, such as a computer that might crash at any&nbsp;</span><span>moment due to a power outage. &nbsp;This project led to a new formulation&nbsp;</span><span>of confidentiality, which we call data non-interference, that enables&nbsp;</span><span>specifying the security guarantees of a file system, as well as a new&nbsp;</span><span>oracle-based specification approach for reasoning about confidentiality&nbsp;</span><span>in the presence of non-determinism. &nbsp;Based on these ideas, we were able&nbsp;</span><span>to build two prototype implementations of file systems, running on Linux,&nbsp;</span><span>that come with machine-checked proofs of confidentiality.&nbsp; These specification and verification techniques may lead to formally verified storage systems in the future, ensuring the absence of bugs that leak confidential data.</span><br /><br /><span>A second contribution of this project lies in verifying hardware security&nbsp;</span><span>modules (HSMs, such as a USB security key). &nbsp;The main challenge we focused on was that HSMs can have subtle vulnerabilities called timing channels, where an adversary can infer sensitive information based on how long it takes the secure device to respond to certain requests. &nbsp;These types of attacks are particularly important for HSMs, like a USB security key, that could be plugged into a compromised host computer. &nbsp;We developed a new approach for verifying the correctness and security of the entire HSM, including both the hardware implementation and the software running on top of it. &nbsp;By considering the hardware and the software together, at the level of hardware clock cycles, our approach can ensure the absence of software bugs, hardware bugs, as well as timing channels, in the overall implementation. &nbsp;In particular, we developed a new security definition that enables us to capture the overall behavior of an HSM with a concise, abstract specification that defines what operations the HSM should perform, combined with a new framework for mostly-automated proofs under this new definition. &nbsp;As a demonstration of this approach, we verified several example HSMs, including a password hashing device and a one-time-password authentication device.&nbsp; These ideas may enable future hardware security modules that come with formal proofs of security, ensuring that there are no hardware or software bugs, including timing channels, that can violate security guarantees.</span></p><br>\n<p>\n\t\t\t\t      \tLast Modified: 12/22/2022<br>\n\t\t\t\t\tModified by: Nickolai&nbsp;Zeldovich</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\n Many security problems today stem from bugs in software.  Although there has been significant effort to reduce bugs through better testing, fuzzing, model checking, and so on, subtle bugs remain and continue to be exploited.  A powerful approach, taken by this project, is to use machine-checked formal verification to rule out whole classes of bugs.  With formal verification, a rigorous machine-checked proof ensures that the implementation of the system precisely meets its specification, which means there are no bugs that can violate the spec and lead to a security vulnerability.\n\nOne key contribution of this project lies in formulating a way of specifying what it means for storage systems, like a file system, to keep data confidential.  The most common approach for specifying confidentiality, called non-interference, is too strict for realistic file systems, because some information (such as the amount of disk space used, or the names of files) might be allowed to leak from one user to another, even if the contents of the files themselves are protected.  Confidentiality definitions have also had trouble handling non-deterministic systems, such as a computer that might crash at any moment due to a power outage.  This project led to a new formulation of confidentiality, which we call data non-interference, that enables specifying the security guarantees of a file system, as well as a new oracle-based specification approach for reasoning about confidentiality in the presence of non-determinism.  Based on these ideas, we were able to build two prototype implementations of file systems, running on Linux, that come with machine-checked proofs of confidentiality.  These specification and verification techniques may lead to formally verified storage systems in the future, ensuring the absence of bugs that leak confidential data.\n\nA second contribution of this project lies in verifying hardware security modules (HSMs, such as a USB security key).  The main challenge we focused on was that HSMs can have subtle vulnerabilities called timing channels, where an adversary can infer sensitive information based on how long it takes the secure device to respond to certain requests.  These types of attacks are particularly important for HSMs, like a USB security key, that could be plugged into a compromised host computer.  We developed a new approach for verifying the correctness and security of the entire HSM, including both the hardware implementation and the software running on top of it.  By considering the hardware and the software together, at the level of hardware clock cycles, our approach can ensure the absence of software bugs, hardware bugs, as well as timing channels, in the overall implementation.  In particular, we developed a new security definition that enables us to capture the overall behavior of an HSM with a concise, abstract specification that defines what operations the HSM should perform, combined with a new framework for mostly-automated proofs under this new definition.  As a demonstration of this approach, we verified several example HSMs, including a password hashing device and a one-time-password authentication device.  These ideas may enable future hardware security modules that come with formal proofs of security, ensuring that there are no hardware or software bugs, including timing channels, that can violate security guarantees.\n\n\t\t\t\t\tLast Modified: 12/22/2022\n\n\t\t\t\t\tSubmitted by: Nickolai Zeldovich"
 }
}