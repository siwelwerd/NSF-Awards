{
 "awd_id": "1817272",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "Understanding Semidefinite Programming Duality Using Elementary Reformulations",
 "cfda_num": "47.049",
 "org_code": "03040000",
 "po_phone": "7032922113",
 "po_email": "ygorb@nsf.gov",
 "po_sign_block_name": "Yuliya Gorb",
 "awd_eff_date": "2018-08-01",
 "awd_exp_date": "2022-07-31",
 "tot_intn_awd_amt": 150000.0,
 "awd_amount": 150000.0,
 "awd_min_amd_letter_date": "2018-07-18",
 "awd_max_amd_letter_date": "2018-07-18",
 "awd_abstract_narration": "Semidefinite programs (SDPs) are some of the most versatile, useful, and interesting  optimization problems to emerge in the last few decades. They find uses in engineering, economics, and machine learning, to name just a few areas. In the last few decades thousands of papers have been published on SDPs. However, SDPs are often pathological: they may not attain their optimal values, and/or their optimal value may differ from that of their dual. Such SDPs  often defeat even  the best SDP solvers, which fail or report an incorrect solution.  Can we understand these pathologies using something as simple as row operations inherited from Gaussian elimination? The project aims to answer this question affirmatively and lead to both theoretical and computational advances in semidefinite programming, and more broadly, in convex optimization. The PI will broadly disseminate the results, both in international and domestic conferences, and by training doctoral students. \r\n \r\nA linear system of equations can be pathological in the sense that it may not have a solution. We can understand this pathology by  transforming the system into a standard form that contains an impossible equation. The transformation is based on elementary row operations. The proposed project aims to use the same operations to transform SDPs into a canonical form, from which their pathology  (say positive duality gap) is easy to see. Thus, on the theoretical side  the project will show that elementary row operations - a staple tool in linear algebra - are useful to understand a much more general class of problems, SDPs, and even more broadly, convex optimization problems. On the computational side the project will develop a useful problem library to test SDP solvers, and other conic optimization solvers. Thus, besides developing theory, the project will contribute to the development of solution methods.\r\n\r\nThis award reflects NSF's statutory mission and has been deemed worthy of support through evaluation using the Foundation's intellectual merit and broader impacts review criteria.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "MPS",
 "org_dir_long_name": "Directorate for Mathematical and Physical Sciences",
 "div_abbr": "DMS",
 "org_div_long_name": "Division Of Mathematical Sciences",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Gabor",
   "pi_last_name": "Pataki",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Gabor Pataki",
   "pi_email_addr": "gabor@unc.edu",
   "nsf_id": "000207364",
   "pi_start_date": "2018-07-18",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of North Carolina at Chapel Hill",
  "inst_street_address": "104 AIRPORT DR STE 2200",
  "inst_street_address_2": "",
  "inst_city_name": "CHAPEL HILL",
  "inst_state_code": "NC",
  "inst_state_name": "North Carolina",
  "inst_phone_num": "9199663411",
  "inst_zip_code": "275995023",
  "inst_country_name": "United States",
  "cong_dist_code": "04",
  "st_cong_dist_code": "NC04",
  "org_lgl_bus_name": "UNIVERSITY OF NORTH CAROLINA AT CHAPEL HILL",
  "org_prnt_uei_num": "D3LHU66KBLD5",
  "org_uei_num": "D3LHU66KBLD5"
 },
 "perf_inst": {
  "perf_inst_name": "University of North Carolina at Chapel Hill",
  "perf_str_addr": "",
  "perf_city_name": "Chapel Hill",
  "perf_st_code": "NC",
  "perf_st_name": "North Carolina",
  "perf_zip_code": "275993260",
  "perf_ctry_code": "US",
  "perf_cong_dist": "04",
  "perf_st_cong_dist": "NC04",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "127100",
   "pgm_ele_name": "COMPUTATIONAL MATHEMATICS"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "9263",
   "pgm_ref_txt": "COMPUTATIONAL SCIENCE & ENGING"
  }
 ],
 "app_fund": [
  {
   "app_code": "0118",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001819DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2018,
   "fund_oblg_amt": 150000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Semidefinite programs (SDPs) are some of the most versatile, useful, and interesting&nbsp;optimization problems to emerge in the last few decades. They find uses in engineering, economics, and machine learning, to name just a few areas. In the last few decades thousands of papers have been published on SDPs. However, SDPs are often pathological: they may not attain their optimal values, and/or their optimal value may differ from that of their dual. Such SDPs&nbsp;&nbsp;often defeat even&nbsp;&nbsp;the best SDP solvers, which fail or report an incorrect solution.&nbsp;&nbsp;Can we understand these pathologies&nbsp;&nbsp;using something as simple as row operations inherited from Gaussian elimination? This was the goal of the project.</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>Accomplishments:</p>\n<p>&nbsp;</p>\n<p>1) In &ldquo;Characterizing bad semidefinite programs: normal forms and short proofs&rdquo; the PI showed that elementary row operations give a shorter and more elegant proof of a characterization of badly behaved feasible semidefinite systems. The paper was published in SIAM Review, the premier journal of SIAM:&nbsp;it reaches the diverse audience of all 17 SIAM journals.</p>\n<p>&nbsp;</p>\n<p>2) The paper:&nbsp;&nbsp;\"Sieve-SDP: a simple facial reduction algorithm to preprocess semidefinite programs\"&nbsp;gives&nbsp;a practical twist on the main idea of the project.&nbsp;This paper is now published in Mathematical Programming Computation.&nbsp;&nbsp;</p>\n<p>&nbsp;</p>\n<p>The project is about reformulating SDPs into normal forms that makes their pathological behavior obvious. The \"Sieve-SDP\" paper shows that many SDPs, surprisingly, do not even have to be reformulated. Precisely,&nbsp;&nbsp;they are already in a normal form, and their infeasibility or lack of strict feasibility is easy to recognize by a Matlab code with a few lines, which only uses Cholesky factorization. Hence it is very accurate, stable, and fast: running Sieve-SDP takes less than 1 % of the time that it takes an SDP solver to solve the problem.</p>\n<p>The software is posted on github, and has been used by several researchers.</p>\n<p>3) The paper: &ldquo;A simplified treatment of Ramana&rsquo;s exact dual for semidefinite programming&rdquo; was published in Optimization Letters.</p>\n<p>Ramana's dual is a fundamental result in SDP duality: it is a dual with extra variable and constraints, which always attains its optimal value and has zero duality gap with the primal. It also leads to a number of fundamental results in complexity theory.&nbsp;</p>\n<p>In our paper we give a shorter proof of its correctness (plus a lot of illustration, motivation and examples) which is based only on two ingredients: 1) just one basic duality result in SDP 2) elementary linear algebra.</p>\n<p>4) The paper &ldquo;An echelon form of weakly infeasible semidefinite programs, and bad projections of the psd cone&rdquo; was published in Foundations of Computational Mathematics.</p>\n<p>A weakly infeasible SDP is defined by an affine subspace that has zero distance to the cone of positive semidefinite matrices, but does not intersect it. That is, it approaches the semidefinite cone asymptotically in the same manner as a hyperbola approaches a coordinate axis without ever touching it.</p>\n<p>&nbsp;</p>\n<p>Here we prove that every weakly infeasible SDP can be brought to a normal form, which 1) makes the weak infeasibility easy to recognize 2) permits us to construct any weakly infeasible SDP by an elementary combinatorial algorithm</p>\n<p>5) On positive duality gaps in semidefinite programming\".&nbsp;</p>\n<p>Positive duality gaps are usually seen as the most difficult and most interesting pathology in SDP. Such SDPs&nbsp; are in striking contrast with linear programs, which do not have a duality gap. SDPs with positive duality gaps&nbsp; are usually unsolvable, and are not well understood.&nbsp;</p>\n<p>This paper completely characterizes two variable SDPs with positive duality gaps. It also shows that the structure that causes positive duality gaps often appears in SDPs with more variables: thus the two variable case helps us understand positive duality gaps in higher dimensions as well.</p>\n<p>6) How do exponential size solutions arise in semidefinite programming?&rdquo;.</p>\n<p>&nbsp;This paper addressed a fundamental&nbsp;&nbsp;problem: as a famous&nbsp;&nbsp;example of Khachiyan shows, there are SDPs in which any feasible solution must have exponential size in the size of the input. Here by ``size&rdquo; we mean the number of bits necessary to store the solution.</p>\n<p>&nbsp;Such large solutions are a major obstacle to solving a long standing open problem, whether we can decide feasibility of an SDP in polynomial time. After all, if it takes exponential space to even write down a solution, we cannot expect to be able to compute it in polynomial time.</p>\n<p>&nbsp;This paper made progress on two questions: 1) are such large solutions common in SDPs? 2) can we somehow represent them in polynomial space?</p>\n<p>&nbsp;As to 1), we showed that a linear transformation puts any strictly feasible SDP into a Khachiyan type SDP in which the leading variables are large. As to 2), we showed that in all such Khachiyan type SDPs, we can certify that an exponential size solution ``exists&rdquo; without having to compute it.</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 11/16/2022<br>\n\t\t\t\t\tModified by: Gabor&nbsp;Pataki</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nSemidefinite programs (SDPs) are some of the most versatile, useful, and interesting optimization problems to emerge in the last few decades. They find uses in engineering, economics, and machine learning, to name just a few areas. In the last few decades thousands of papers have been published on SDPs. However, SDPs are often pathological: they may not attain their optimal values, and/or their optimal value may differ from that of their dual. Such SDPs  often defeat even  the best SDP solvers, which fail or report an incorrect solution.  Can we understand these pathologies  using something as simple as row operations inherited from Gaussian elimination? This was the goal of the project.\n\n \n\n \n\nAccomplishments:\n\n \n\n1) In \"Characterizing bad semidefinite programs: normal forms and short proofs\" the PI showed that elementary row operations give a shorter and more elegant proof of a characterization of badly behaved feasible semidefinite systems. The paper was published in SIAM Review, the premier journal of SIAM: it reaches the diverse audience of all 17 SIAM journals.\n\n \n\n2) The paper:  \"Sieve-SDP: a simple facial reduction algorithm to preprocess semidefinite programs\" gives a practical twist on the main idea of the project. This paper is now published in Mathematical Programming Computation.  \n\n \n\nThe project is about reformulating SDPs into normal forms that makes their pathological behavior obvious. The \"Sieve-SDP\" paper shows that many SDPs, surprisingly, do not even have to be reformulated. Precisely,  they are already in a normal form, and their infeasibility or lack of strict feasibility is easy to recognize by a Matlab code with a few lines, which only uses Cholesky factorization. Hence it is very accurate, stable, and fast: running Sieve-SDP takes less than 1 % of the time that it takes an SDP solver to solve the problem.\n\nThe software is posted on github, and has been used by several researchers.\n\n3) The paper: \"A simplified treatment of Ramana\u2019s exact dual for semidefinite programming\" was published in Optimization Letters.\n\nRamana's dual is a fundamental result in SDP duality: it is a dual with extra variable and constraints, which always attains its optimal value and has zero duality gap with the primal. It also leads to a number of fundamental results in complexity theory. \n\nIn our paper we give a shorter proof of its correctness (plus a lot of illustration, motivation and examples) which is based only on two ingredients: 1) just one basic duality result in SDP 2) elementary linear algebra.\n\n4) The paper \"An echelon form of weakly infeasible semidefinite programs, and bad projections of the psd cone\" was published in Foundations of Computational Mathematics.\n\nA weakly infeasible SDP is defined by an affine subspace that has zero distance to the cone of positive semidefinite matrices, but does not intersect it. That is, it approaches the semidefinite cone asymptotically in the same manner as a hyperbola approaches a coordinate axis without ever touching it.\n\n \n\nHere we prove that every weakly infeasible SDP can be brought to a normal form, which 1) makes the weak infeasibility easy to recognize 2) permits us to construct any weakly infeasible SDP by an elementary combinatorial algorithm\n\n5) On positive duality gaps in semidefinite programming\". \n\nPositive duality gaps are usually seen as the most difficult and most interesting pathology in SDP. Such SDPs  are in striking contrast with linear programs, which do not have a duality gap. SDPs with positive duality gaps  are usually unsolvable, and are not well understood. \n\nThis paper completely characterizes two variable SDPs with positive duality gaps. It also shows that the structure that causes positive duality gaps often appears in SDPs with more variables: thus the two variable case helps us understand positive duality gaps in higher dimensions as well.\n\n6) How do exponential size solutions arise in semidefinite programming?\".\n\n This paper addressed a fundamental  problem: as a famous  example of Khachiyan shows, there are SDPs in which any feasible solution must have exponential size in the size of the input. Here by ``size\" we mean the number of bits necessary to store the solution.\n\n Such large solutions are a major obstacle to solving a long standing open problem, whether we can decide feasibility of an SDP in polynomial time. After all, if it takes exponential space to even write down a solution, we cannot expect to be able to compute it in polynomial time.\n\n This paper made progress on two questions: 1) are such large solutions common in SDPs? 2) can we somehow represent them in polynomial space?\n\n As to 1), we showed that a linear transformation puts any strictly feasible SDP into a Khachiyan type SDP in which the leading variables are large. As to 2), we showed that in all such Khachiyan type SDPs, we can certify that an exponential size solution ``exists\" without having to compute it.\n\n \n\n \n\n \n\n \n\n \n\n\t\t\t\t\tLast Modified: 11/16/2022\n\n\t\t\t\t\tSubmitted by: Gabor Pataki"
 }
}