{
 "awd_id": "1646235",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "CPS: Synergy: Collaborative Research: TickTalk: Timing API for Federated Cyberphysical Systems",
 "cfda_num": "47.070",
 "org_code": "05050000",
 "po_phone": null,
 "po_email": "",
 "po_sign_block_name": "Sandip Roy",
 "awd_eff_date": "2018-10-01",
 "awd_exp_date": "2021-09-30",
 "tot_intn_awd_amt": 448797.0,
 "awd_amount": 448797.0,
 "awd_min_amd_letter_date": "2018-09-13",
 "awd_max_amd_letter_date": "2021-09-14",
 "awd_abstract_narration": "The goal of this research is to enable a broad spectrum of programmers to successfully create apps for distributed computing systems including smart and connected communities, or for systems that require tight coordination or synchronization of time. Creating an application for, say, a smart intersection necessitates gathering information from multiple sources, e.g., cameras, traffic sensors, and passing vehicles; performing distributed computation; and then triggering some action, such as a warning. This requires synchronization and coordination amongst multiple interacting devices including systems that are Internet of Things (IoT) devices that may be connected to safety critical infrastructure. Rather than burden the programmer with understanding and dealing with this complexity, we seek a new programming language, sensor and actuator architecture, and communications networks that can take the programmer's statements of \"what to do\" and \"when to do\", and translate these into \"how to do\" by managing mechanisms for synchronization, power, and communication. This approach will enable more rapid development of these types of systems and can have significant economic development impact.\r\n\r\nThe proposed approach has four parts: (1) creating a new programming language that embeds the notion of timing islands -- groups of devices that cooperate and are occasionally synchronized; (2) creating a network-wide runtime system that distributes and coordinates the action of code blocks -- portions of the program -- across devices; (3) extending the capabilities of communication networks to improve the ability to synchronize devices and report the quality of synchronization back to the runtime system, enabling adaptive program behavior; and (4) extending device hardware architecture to support synchronization and time-respecting operation.\r\n\r\nThis award reflects NSF's statutory mission and has been deemed worthy of support through evaluation using the Foundation's intellectual merit and broader impacts review criteria.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CNS",
 "org_div_long_name": "Division Of Computer and Network Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Former Principal Investigator",
   "pi_first_name": "Robert",
   "pi_last_name": "Iannucci",
   "pi_mid_init": "A",
   "pi_sufx_name": "",
   "pi_full_name": "Robert A Iannucci",
   "pi_email_addr": "bob@rail.com",
   "nsf_id": "000653655",
   "pi_start_date": "2018-09-13",
   "pi_end_date": "2021-09-14"
  },
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Carlee",
   "pi_last_name": "Joe-Wong",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Carlee Joe-Wong",
   "pi_email_addr": "cjoewong@andrew.cmu.edu",
   "nsf_id": "000736588",
   "pi_start_date": "2021-09-14",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Carnegie-Mellon University",
  "inst_street_address": "5000 FORBES AVE",
  "inst_street_address_2": "",
  "inst_city_name": "PITTSBURGH",
  "inst_state_code": "PA",
  "inst_state_name": "Pennsylvania",
  "inst_phone_num": "4122688746",
  "inst_zip_code": "152133815",
  "inst_country_name": "United States",
  "cong_dist_code": "12",
  "st_cong_dist_code": "PA12",
  "org_lgl_bus_name": "CARNEGIE MELLON UNIVERSITY",
  "org_prnt_uei_num": "U3NKNFLNQ613",
  "org_uei_num": "U3NKNFLNQ613"
 },
 "perf_inst": {
  "perf_inst_name": "Carnegie-Mellon University",
  "perf_str_addr": "NASA Ames Research Park",
  "perf_city_name": "Moffett Field",
  "perf_st_code": "CA",
  "perf_st_name": "California",
  "perf_zip_code": "940350001",
  "perf_ctry_code": "US",
  "perf_cong_dist": "18",
  "perf_st_cong_dist": "CA18",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "791800",
   "pgm_ele_name": "CPS-Cyber-Physical Systems"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7918",
   "pgm_ref_txt": "CYBER-PHYSICAL SYSTEMS (CPS)"
  },
  {
   "pgm_ref_code": "8235",
   "pgm_ref_txt": "CPS-Synergy"
  }
 ],
 "app_fund": [
  {
   "app_code": "0118",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001819DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2018,
   "fund_oblg_amt": 448797.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p class=\"Default\">The Internet-of-Things (IoT) promises to provide an ever-growing supply of Internet-connected devices that can collect, analyze, and respond to data about their environments. Applications enabled by the IoT include autonomous driving, in which vehicles must detect and avoid collisions with nearby vehicles, and environmental monitoring, in which sensors can collect and display information, such as current noise or ambient temperature levels, about the surrounding environment. Programming such applications, however, often requires specialized knowledge. In particular, many IoT applications naturally involve multiple physical devices, such as multiple sensors or a sensor and a separate server. Coordinating across these devices, then, may require knowledge of distributed systems and networking, particularly if applications must execute in a time-sensitive manner. Ensuring that data from multiple sensors is collected at approximately the same time, for example, may require synchronizing device clocks, which is nontrivial and energy-consuming at fine time granularities. Indeed, many IoT devices are also energy-constrained, which more generally requires application programmers to be aware of the energy consumption of their applications?often not the case, especially if the programmer does not know the specific hardware on which an application will be run. Such specialized knowledge threatens to bottleneck the widespread deployment of IoT programs, by making their development difficult.</p>\n<p class=\"Default\">TickTalk includes new language, system, network, and device mechanisms for programmers to easily specify and enforce timing constraints. The first part of the project addressed the specific device- and network-level challenge of designing low-power mechanisms for synchronizing clocks on different physical devices. The main insight is to carefully model delays associated with data transmitted between a given pair of devices, which allows this data to be used for synchronizing clocks on these devices. These synchronization methods, which we call LongShoT, allow TickTalk to execute fine-grained synchronization if required by an application.</p>\n<p class=\"Default\">In addition to clock synchronization, many applications may have deadlines by which they need to be completed. Thus, at the system level, we designed a framework for representing application programs that cleanly slices them into atomic computation units and codifies their timing constraints (e.g., deadlines by which computations should be completed). This representation allows the program to be easily distributed across multiple hardware devices, e.g., across multiple sensors. We further define a protocol for exchanging information between computation units, which carries information about timing constraints and the order in which computations should be executed. Programs written in this framework can then be optimized to meet timing constraints, e.g., by splitting individual computation units across sufficiently fast physical devices. If timing constraints cannot be met, we design fallback mechanisms that detect that the constraint will be missed and instead execute backup code to avoid catastrophic application failure.</p>\n<p class=\"Default\">Finally, at the language level, we developed an initial prototype of the language mechanisms that has been packaged together and released as TTPython, which runs on Python3. Our language extends the usual Python programming language, allowing programmers to easily specify application timing constraints by adapting their existing Python programs into the TickTalk framework. Once written in TTPython, programs can take advantage of the system, network, and device mechanisms developed to enforce timing constraints in a low-power fashion.</p>\n<p>The project additionally facilitated several educational activities. Two courses at CMU made extensive use of low-power synchronization mechanisms developed during the project: one on Wireless Device Architectures and one on Connected Embedded Systems. Five graduate students and one undergraduate student worked on the project over the past three years. The students participated in weekly all-hands meetings as well as individual research meetings with their faculty advisors. Thus, they gained experience in working on a team with diverse backgrounds and managing a large technical project. The public-facing nature of the TTPython open-source release and CPS IoT Week Student Design Competition further trained the students in presenting their research and demonstrating its practical value to a range of audiences.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 02/07/2022<br>\n\t\t\t\t\tModified by: Carlee&nbsp;Joe-Wong</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "The Internet-of-Things (IoT) promises to provide an ever-growing supply of Internet-connected devices that can collect, analyze, and respond to data about their environments. Applications enabled by the IoT include autonomous driving, in which vehicles must detect and avoid collisions with nearby vehicles, and environmental monitoring, in which sensors can collect and display information, such as current noise or ambient temperature levels, about the surrounding environment. Programming such applications, however, often requires specialized knowledge. In particular, many IoT applications naturally involve multiple physical devices, such as multiple sensors or a sensor and a separate server. Coordinating across these devices, then, may require knowledge of distributed systems and networking, particularly if applications must execute in a time-sensitive manner. Ensuring that data from multiple sensors is collected at approximately the same time, for example, may require synchronizing device clocks, which is nontrivial and energy-consuming at fine time granularities. Indeed, many IoT devices are also energy-constrained, which more generally requires application programmers to be aware of the energy consumption of their applications?often not the case, especially if the programmer does not know the specific hardware on which an application will be run. Such specialized knowledge threatens to bottleneck the widespread deployment of IoT programs, by making their development difficult.\nTickTalk includes new language, system, network, and device mechanisms for programmers to easily specify and enforce timing constraints. The first part of the project addressed the specific device- and network-level challenge of designing low-power mechanisms for synchronizing clocks on different physical devices. The main insight is to carefully model delays associated with data transmitted between a given pair of devices, which allows this data to be used for synchronizing clocks on these devices. These synchronization methods, which we call LongShoT, allow TickTalk to execute fine-grained synchronization if required by an application.\nIn addition to clock synchronization, many applications may have deadlines by which they need to be completed. Thus, at the system level, we designed a framework for representing application programs that cleanly slices them into atomic computation units and codifies their timing constraints (e.g., deadlines by which computations should be completed). This representation allows the program to be easily distributed across multiple hardware devices, e.g., across multiple sensors. We further define a protocol for exchanging information between computation units, which carries information about timing constraints and the order in which computations should be executed. Programs written in this framework can then be optimized to meet timing constraints, e.g., by splitting individual computation units across sufficiently fast physical devices. If timing constraints cannot be met, we design fallback mechanisms that detect that the constraint will be missed and instead execute backup code to avoid catastrophic application failure.\nFinally, at the language level, we developed an initial prototype of the language mechanisms that has been packaged together and released as TTPython, which runs on Python3. Our language extends the usual Python programming language, allowing programmers to easily specify application timing constraints by adapting their existing Python programs into the TickTalk framework. Once written in TTPython, programs can take advantage of the system, network, and device mechanisms developed to enforce timing constraints in a low-power fashion.\n\nThe project additionally facilitated several educational activities. Two courses at CMU made extensive use of low-power synchronization mechanisms developed during the project: one on Wireless Device Architectures and one on Connected Embedded Systems. Five graduate students and one undergraduate student worked on the project over the past three years. The students participated in weekly all-hands meetings as well as individual research meetings with their faculty advisors. Thus, they gained experience in working on a team with diverse backgrounds and managing a large technical project. The public-facing nature of the TTPython open-source release and CPS IoT Week Student Design Competition further trained the students in presenting their research and demonstrating its practical value to a range of audiences.\n\n\t\t\t\t\tLast Modified: 02/07/2022\n\n\t\t\t\t\tSubmitted by: Carlee Joe-Wong"
 }
}