{
 "awd_id": "1816922",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "AF: Small: Relaxed Distributed Data Structures: Implementations and Applications",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": null,
 "po_email": "",
 "po_sign_block_name": "A. Funda Ergun",
 "awd_eff_date": "2018-10-01",
 "awd_exp_date": "2022-09-30",
 "tot_intn_awd_amt": 396999.0,
 "awd_amount": 396999.0,
 "awd_min_amd_letter_date": "2018-08-27",
 "awd_max_amd_letter_date": "2018-08-27",
 "awd_abstract_narration": "Society has become increasing reliant on distributed computing systems, from search engines to mobile telephony to electronic commerce to social media, and the future is likely to bring autonomous vehicles and more.  Yet distributed systems are notoriously hard to design so that they are correct, let alone efficient.  One way to construct distributed applications that are easier to verify as correct is to use shared memory for inter-process communication instead of more low-level techniques, as that contributes to better structured code.  Although shared memory is a convenient abstraction, it is not generally provided in large-scale distributed systems; instead, the processes keep individual copies of the data and communicate by sending messages to keep the copies consistent.  This project will contribute to making shared memory applications more reliable and efficient by developing and analyzing shared data abstractions that have relaxed semantics and thus can exhibit a trade-off between performance and specification.  In addition to training graduate students, the project will include a focus on involving domestic undergraduate students, especially women and under-represented minorities, in research through summer as well as academic-year experiences, with the goal of increasing the numbers that attend graduate school in computing related fields.  \r\n\r\nStrongly consistent implementations of shared objects with strict semantics are provably expensive, fueling interest in relaxations. The objectives of the project are: to find optimally efficient algorithms to implement shared objects, focusing on relaxing specifications of both data types and consistency conditions; to understand the relationships between relaxing a type and relaxing a condition; and, to characterize applications that can exploit the relaxations.  Current performance analyses of shared object implementations in message-passing systems have numerous gaps: upper and lower bounds are not tight, some classes of operations are not considered, other metrics have not been studied, and mostly only overly-pessimistic worst-case analyses are known.  The project will focus on tight amortized analyses of algorithms for relaxed data types and seek a complete characterization.  Currently, relaxation of consistency conditions and relaxation of data type specifications have been considered independently; the project will seek to understand the relationships and trade offs between them to ease the task of the programmer.  Distributed systems in which processors enter and leave dynamically, such as peer-to-peer networks, data centers, and social networks, are typically asynchronous and crash-prone.  Characterizing churn patterns that allow implementations of relaxed shared objects would make it easier to determine if a particular situation can support them.  Many opportunities remain for characterizing classes of applications that can exploit relaxed data structures and/or relaxed consistency conditions; this would show which circumstances can benefit from savings obtained from relaxation.\r\n\r\nThis award reflects NSF's statutory mission and has been deemed worthy of support through evaluation using the Foundation's intellectual merit and broader impacts review criteria.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Jennifer",
   "pi_last_name": "Welch",
   "pi_mid_init": "L",
   "pi_sufx_name": "",
   "pi_full_name": "Jennifer L Welch",
   "pi_email_addr": "welch@cse.tamu.edu",
   "nsf_id": "000365769",
   "pi_start_date": "2018-08-27",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Texas A&M Engineering Experiment Station",
  "inst_street_address": "3124 TAMU",
  "inst_street_address_2": "",
  "inst_city_name": "COLLEGE STATION",
  "inst_state_code": "TX",
  "inst_state_name": "Texas",
  "inst_phone_num": "9798626777",
  "inst_zip_code": "778433124",
  "inst_country_name": "United States",
  "cong_dist_code": "10",
  "st_cong_dist_code": "TX10",
  "org_lgl_bus_name": "TEXAS A&M ENGINEERING EXPERIMENT STATION",
  "org_prnt_uei_num": "QD1MX6N5YTN4",
  "org_uei_num": "QD1MX6N5YTN4"
 },
 "perf_inst": {
  "perf_inst_name": "Texas A&M Engineering Experiment Station",
  "perf_str_addr": "H.R. Bright Building",
  "perf_city_name": "College Station",
  "perf_st_code": "TX",
  "perf_st_name": "Texas",
  "perf_zip_code": "778453112",
  "perf_ctry_code": "US",
  "perf_cong_dist": "10",
  "perf_st_cong_dist": "TX10",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "287800",
   "pgm_ele_name": "Special Projects - CCF"
  },
  {
   "pgm_ele_code": "779600",
   "pgm_ele_name": "Algorithmic Foundations"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7926",
   "pgm_ref_txt": "ALGORITHMS"
  },
  {
   "pgm_ref_code": "7934",
   "pgm_ref_txt": "PARAL/DISTRIBUTED ALGORITHMS"
  },
  {
   "pgm_ref_code": "9102",
   "pgm_ref_txt": "WOMEN, MINORITY, DISABLED, NEC"
  }
 ],
 "app_fund": [
  {
   "app_code": "0118",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001819DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2018,
   "fund_oblg_amt": 396999.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Society has become increasing reliant on distributed computing systems, from search engines to autonomous vehicles.&nbsp; Yet distributed systems are notoriously hard to design so that they are correct, let alone efficient.&nbsp; One way to construct distributed applications that are easier to verify is to use shared memory for inter-process communication, instead of more low-level techniques, as that contributes to better structured code.&nbsp; Although shared memory is a convenient abstraction, it is not generally provided in large-scale distributed systems; instead, the processes keep individual copies of the data and communicate by sending messages to keep the copies consistent.&nbsp; This project contributed to making shared memory applications more reliable and efficient.<br /><br />Our first result was quantifying the tradeoff between the times required for reading and writing a shared large register that is implemented using minimum-sized registers.&nbsp; Specifically, we showed that if the implemented read time is as small as possible, then the implemented write time must be at least as long as the read time.<br /><br />Randomization is a powerful tool for developing simple and efficient distributed programs.&nbsp; Randomized programs that use \"atomic\" shared objects (meaning their operations occur instantaneously) have some desired probabilistic behavior.&nbsp; Prior work has shown that implemented shared objects that replace the atomic shared objects in such programs must satisfy a restrictive property called \"strong linearizability\" (SL) in order to preserve the desired probabilistic behavior.&nbsp; We showed that it is impossible to implement SL versions of several popular shared objects in failure-prone message-passing systems.&nbsp; On the positive side, we showed that randomized distributed programs do not always need SL objects: specifically, we showed how to modify a wide class of object implementations that are not SL so that program using them have approximately the same probabilistic behavior as with atomic objects.<br /><br />We also considered distributed systems in which processes enter and leave dynamically (a phenomenon called \"churn\"), such as peer-to-peer networks, data centers, and social networks.&nbsp; For systems subject to a limited amount of non-stop churn, we showed that a particular data structure called the \"store-collect object\" is a useful primitive for building numerous other shared objects, which in turn can be used for popular middle-ware services, while hiding the complexity caused by the churn.<br /><br /><br /></p><br>\n<p>\n\t\t\t\t      \tLast Modified: 01/13/2023<br>\n\t\t\t\t\tModified by: Jennifer&nbsp;L&nbsp;Welch</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nSociety has become increasing reliant on distributed computing systems, from search engines to autonomous vehicles.  Yet distributed systems are notoriously hard to design so that they are correct, let alone efficient.  One way to construct distributed applications that are easier to verify is to use shared memory for inter-process communication, instead of more low-level techniques, as that contributes to better structured code.  Although shared memory is a convenient abstraction, it is not generally provided in large-scale distributed systems; instead, the processes keep individual copies of the data and communicate by sending messages to keep the copies consistent.  This project contributed to making shared memory applications more reliable and efficient.\n\nOur first result was quantifying the tradeoff between the times required for reading and writing a shared large register that is implemented using minimum-sized registers.  Specifically, we showed that if the implemented read time is as small as possible, then the implemented write time must be at least as long as the read time.\n\nRandomization is a powerful tool for developing simple and efficient distributed programs.  Randomized programs that use \"atomic\" shared objects (meaning their operations occur instantaneously) have some desired probabilistic behavior.  Prior work has shown that implemented shared objects that replace the atomic shared objects in such programs must satisfy a restrictive property called \"strong linearizability\" (SL) in order to preserve the desired probabilistic behavior.  We showed that it is impossible to implement SL versions of several popular shared objects in failure-prone message-passing systems.  On the positive side, we showed that randomized distributed programs do not always need SL objects: specifically, we showed how to modify a wide class of object implementations that are not SL so that program using them have approximately the same probabilistic behavior as with atomic objects.\n\nWe also considered distributed systems in which processes enter and leave dynamically (a phenomenon called \"churn\"), such as peer-to-peer networks, data centers, and social networks.  For systems subject to a limited amount of non-stop churn, we showed that a particular data structure called the \"store-collect object\" is a useful primitive for building numerous other shared objects, which in turn can be used for popular middle-ware services, while hiding the complexity caused by the churn.\n\n\n\n\n\t\t\t\t\tLast Modified: 01/13/2023\n\n\t\t\t\t\tSubmitted by: Jennifer L Welch"
 }
}