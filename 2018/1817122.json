{
 "awd_id": "1817122",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SaTC: CORE: Small: Machine Learning for Effective Fuzz Testing",
 "cfda_num": "47.070",
 "org_code": "05050000",
 "po_phone": "7032927841",
 "po_email": "sgreensp@nsf.gov",
 "po_sign_block_name": "Sol Greenspan",
 "awd_eff_date": "2018-10-01",
 "awd_exp_date": "2022-09-30",
 "tot_intn_awd_amt": 500000.0,
 "awd_amount": 500000.0,
 "awd_min_amd_letter_date": "2018-08-27",
 "awd_max_amd_letter_date": "2018-08-27",
 "awd_abstract_narration": "In recent years, fuzz testing has evolved as one of the most effective testing techniques for finding security vulnerabilities and correctness bugs in real-world software systems.  It has been used successfully by major software companies for security testing and quality assurance.   State-of-the-art fuzz testing tools have found numerous security vulnerabilities and bugs in widely used software such as Web browsers, network tools, image processors, popular system libraries, C compilers, and interpreters.\r\n\r\nFuzz testing works by generating random input data for a program under test.  A key reason behind its huge popularity is that it has low computation overhead compared to other sophisticated techniques such as dynamic symbolic execution.  While fuzz testing has been highly successful in practice, it has been mostly implemented in ad-hoc ways by incorporating a collection of hacks and best practices. As such, fuzz testing techniques usually generate many redundant test inputs and take several days to weeks to find bugs. For complex input formats, such as for random C program inputs for a C compiler, a huge amount of manual tuning is required to make fuzz testing generate valid test inputs.  This project proposes to make fuzz testing smarter and more effective by applying machine learning with customizable testing objectives. The proposed techniques will use probabilistic machine learning models, such as n-grams, recurrent neural networks (RNN), recursive neural networks, or multi-armed bandits, to generate inputs from scratch or to mutate a set of seed inputs.  The model will be trained in such a way that the inputs generated by it will maximize the custom testing objective. We expect that such a model will generate fewer redundant inputs and can be customized to user-provided testing objectives. This project aims to contribute to the development of reliable, secure, and trustworthy software.  The tools and techniques developed in this project will make it easier for programmers to write correct and secure programs.\r\n\r\nThis award reflects NSF's statutory mission and has been deemed worthy of support through evaluation using the Foundation's intellectual merit and broader impacts review criteria.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CNS",
 "org_div_long_name": "Division Of Computer and Network Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Koushik",
   "pi_last_name": "Sen",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Koushik Sen",
   "pi_email_addr": "ksen@eecs.berkeley.edu",
   "nsf_id": "000490260",
   "pi_start_date": "2018-08-27",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Dawn",
   "pi_last_name": "Song",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Dawn Song",
   "pi_email_addr": "dawnsong@cs.berkeley.edu",
   "nsf_id": "000079467",
   "pi_start_date": "2018-08-27",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of California-Berkeley",
  "inst_street_address": "1608 4TH ST STE 201",
  "inst_street_address_2": "",
  "inst_city_name": "BERKELEY",
  "inst_state_code": "CA",
  "inst_state_name": "California",
  "inst_phone_num": "5106433891",
  "inst_zip_code": "947101749",
  "inst_country_name": "United States",
  "cong_dist_code": "12",
  "st_cong_dist_code": "CA12",
  "org_lgl_bus_name": "REGENTS OF THE UNIVERSITY OF CALIFORNIA, THE",
  "org_prnt_uei_num": "",
  "org_uei_num": "GS3YEVSS12N6"
 },
 "perf_inst": {
  "perf_inst_name": "University of California-Berkeley",
  "perf_str_addr": "",
  "perf_city_name": "Berkeley",
  "perf_st_code": "CA",
  "perf_st_name": "California",
  "perf_zip_code": "947201776",
  "perf_ctry_code": "US",
  "perf_cong_dist": "12",
  "perf_st_cong_dist": "CA12",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "806000",
   "pgm_ele_name": "Secure &Trustworthy Cyberspace"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "025Z",
   "pgm_ref_txt": "SaTC: Secure and Trustworthy Cyberspace"
  },
  {
   "pgm_ref_code": "7434",
   "pgm_ref_txt": "CNCI"
  },
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  }
 ],
 "app_fund": [
  {
   "app_code": "0118",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001819DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2018,
   "fund_oblg_amt": 500000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p><span id=\"docs-internal-guid-c9b135cc-7fff-889b-a919-09ade35abdce\"> </span></p>\n<p dir=\"ltr\"><span>Fuzz testing is one of the most effective techniques for finding security and correctness bugs in real-world software systems.&nbsp; It works by generating random input data for a program under test.&nbsp; A key reason behind its huge popularity is its low computation overhead compared to other sophisticated techniques, such as dynamic symbolic execution.&nbsp; While fuzz testing has been highly successful in practice, it has been primarily implemented in ad-hoc ways by incorporating a collection of hacks and best practices.&nbsp; As such, fuzz testing techniques usually generate many redundant test inputs and take several days to weeks to find bugs. For complex input formats, such as for random C program inputs for a C compiler, a huge amount of manual tuning is required to make fuzz testing generate valid test inputs.</span></p>\n<p>&nbsp;</p>\n<p dir=\"ltr\"><span>In this project, we have developed ground-breaking automated test generation techniques which can find deep correctness and security bugs as well as pathological performance and resource usage bugs in real-world software. Such bugs were beyond the reach of existing automated testing techniques. A key insight behind our work is that if one could learn effective heuristics either via human guidance or machine learning, one can dramatically improve the effectiveness and efficiency of automated testing&nbsp; Moreover, we showed that the same techniques could be used to synthesize programs from input/output examples or demonstrations. Our research contributions have made fuzz testing smarter and dramatically more effective for real-world software. Our research has won several ACM SIGSOFT Awards. We have released all the testing and program synthesis tools into the public domain so that other researchers and practitioners can build on top of our research.&nbsp; Our testing tools have been adopted by large tech firms and have been commercialized by security-oriented startups.&nbsp; Four Ph.D. students who worked on the project have taken prestigious positions at top schools (e.g., CMU) and startups.&nbsp;</span></p>\n<p><br /><br /><br /></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 03/01/2023<br>\n\t\t\t\t\tModified by: Koushik&nbsp;Sen</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\n \nFuzz testing is one of the most effective techniques for finding security and correctness bugs in real-world software systems.  It works by generating random input data for a program under test.  A key reason behind its huge popularity is its low computation overhead compared to other sophisticated techniques, such as dynamic symbolic execution.  While fuzz testing has been highly successful in practice, it has been primarily implemented in ad-hoc ways by incorporating a collection of hacks and best practices.  As such, fuzz testing techniques usually generate many redundant test inputs and take several days to weeks to find bugs. For complex input formats, such as for random C program inputs for a C compiler, a huge amount of manual tuning is required to make fuzz testing generate valid test inputs.\n\n \nIn this project, we have developed ground-breaking automated test generation techniques which can find deep correctness and security bugs as well as pathological performance and resource usage bugs in real-world software. Such bugs were beyond the reach of existing automated testing techniques. A key insight behind our work is that if one could learn effective heuristics either via human guidance or machine learning, one can dramatically improve the effectiveness and efficiency of automated testing  Moreover, we showed that the same techniques could be used to synthesize programs from input/output examples or demonstrations. Our research contributions have made fuzz testing smarter and dramatically more effective for real-world software. Our research has won several ACM SIGSOFT Awards. We have released all the testing and program synthesis tools into the public domain so that other researchers and practitioners can build on top of our research.  Our testing tools have been adopted by large tech firms and have been commercialized by security-oriented startups.  Four Ph.D. students who worked on the project have taken prestigious positions at top schools (e.g., CMU) and startups. \n\n\n\n\n\n\n \n\n \n\n\t\t\t\t\tLast Modified: 03/01/2023\n\n\t\t\t\t\tSubmitted by: Koushik Sen"
 }
}