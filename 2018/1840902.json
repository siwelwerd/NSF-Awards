{
 "awd_id": "1840902",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "EAGER: Decomposing Operating Systems for Better Control over Policy and Privacy",
 "cfda_num": "47.070",
 "org_code": "05050000",
 "po_phone": null,
 "po_email": "",
 "po_sign_block_name": "Matt Mutka",
 "awd_eff_date": "2018-10-01",
 "awd_exp_date": "2020-09-30",
 "tot_intn_awd_amt": 200000.0,
 "awd_amount": 200000.0,
 "awd_min_amd_letter_date": "2018-08-04",
 "awd_max_amd_letter_date": "2018-08-04",
 "awd_abstract_narration": "Mobile personal and internet connected devices (called Internet of Things (IoT) devices), provide functionality including communication, image/audio capture, location determination, and biometric sensing.  The enhanced functionality of these devices has enabled two new classes of attacks: data breaches from malicious software applications and Operating Systems (OS) compromises, and large scale Distributed Denial of Service (DDoS) attacks.  These attacks often result from users not being able to control the actions of their devices.  Some actions might be in direct contradiction to the users' wishes. This project addresses the problem of mismatch between device functionality and user policy by introducing a new software layer that mediates access to low-level computing hardware.\r\n\r\nThe project designs a new \"Policy Kernel\" that mediates with hardware and existing \"Functionality Kernels\".  To demonstrate the policy-kernel's versatility, the proposed work includes implementation of prototype applications that address privacy leaks in mobile devices, DDoS prevention in IoT devices, and maintaining device integrity even if the functionality kernel is compromised.  The policy kernel selectively intercepts all hardware access by existing kernels, and ensures that the user policy is not violated.  Applying the user policy requires the policy kernel to be able to disable access to hardware selectively, and to transform or reduce the resolution of data returned by hardware devices.\r\n\r\nThe ability to apply user policy unambiguously and securely will solve, perhaps, the biggest emerging problem for personal- and IoT devices. Prototype applications will demonstrate the versatility and potential of the proposed work: enabling functionality for important scenarios that, for now, must be accepted on `\"faith\".  The proposed design relieves device manufacturers from having to anticipate how their product will be used, where it might be placed, who will use it, and what sensitive data it might inadvertently collect.  Such a design can provide a foundation for how secure and privacy-preserving system software for personal- and IoT devices is built.\r\n\r\nThe policy kernel source code, along with application code will be publicly available.  All research results will be disseminated via conference and journal publications.  All code, data, analysis tools, and publications will be online at https://www.cs.umd.edu/projects/secpath.\r\n\r\nThis award reflects NSF's statutory mission and has been deemed worthy of support through evaluation using the Foundation's intellectual merit and broader impacts review criteria.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CNS",
 "org_div_long_name": "Division Of Computer and Network Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Samrat",
   "pi_last_name": "Bhattacharjee",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Samrat Bhattacharjee",
   "pi_email_addr": "bobby@cs.umd.edu",
   "nsf_id": "000261786",
   "pi_start_date": "2018-08-04",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Maryland, College Park",
  "inst_street_address": "3112 LEE BUILDING",
  "inst_street_address_2": "",
  "inst_city_name": "COLLEGE PARK",
  "inst_state_code": "MD",
  "inst_state_name": "Maryland",
  "inst_phone_num": "3014056269",
  "inst_zip_code": "207425100",
  "inst_country_name": "United States",
  "cong_dist_code": "04",
  "st_cong_dist_code": "MD04",
  "org_lgl_bus_name": "UNIVERSITY OF MARYLAND, COLLEGE PARK",
  "org_prnt_uei_num": "NPU8ULVAAS23",
  "org_uei_num": "NPU8ULVAAS23"
 },
 "perf_inst": {
  "perf_inst_name": "University of Maryland College Park",
  "perf_str_addr": "",
  "perf_city_name": "",
  "perf_st_code": "MD",
  "perf_st_name": "Maryland",
  "perf_zip_code": "207425141",
  "perf_ctry_code": "US",
  "perf_cong_dist": "04",
  "perf_st_cong_dist": "MD04",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "735400",
   "pgm_ele_name": "CSR-Computer Systems Research"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7916",
   "pgm_ref_txt": "EAGER"
  }
 ],
 "app_fund": [
  {
   "app_code": "0118",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001819DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2018,
   "fund_oblg_amt": 200000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p class=\"p1\"><span class=\"s1\">Personal smart devices provide users with powerful capabilities for</span></p>\n<p class=\"p1\"><span class=\"s1\">communication, productivity, health, education, and entertainment; many of</span></p>\n<p class=\"p1\"><span class=\"s1\">these applications and services operate over sensitive data related to the</span></p>\n<p class=\"p1\"><span class=\"s1\">user (e.g., recorded audio, location, finances). Naturally, this sensitive</span></p>\n<p class=\"p1\"><span class=\"s1\">data is the target of many attacks, ranging from malicious applications to</span></p>\n<p class=\"p1\"><span class=\"s1\">compromises of the platform software (OS, privileged services, etc.).</span></p>\n<p class=\"p1\"><span class=\"s1\">Unfortunately, the amount of control users have on this data is limited.</span></p>\n<p class=\"p1\"><span class=\"s1\">First, existing systems do not provide support for users to express their</span></p>\n<p class=\"p1\"><span class=\"s1\">policies either due to incomplete settings (e.g., cannot prevent app access</span></p>\n<p class=\"p1\"><span class=\"s1\">to motion sensors on Android) or limited expressivity (e.g., can</span></p>\n<p class=\"p1\"><span class=\"s1\">enable/disable location, but not adjust data resolution). Second, even when</span></p>\n<p class=\"p1\"><span class=\"s1\">there is support for a desired policy, there is little to no assurance that</span></p>\n<p class=\"p1\"><span class=\"s1\">it is being enforced; large platforms, such as in the case of smart devices,</span></p>\n<p class=\"p1\"><span class=\"s1\">have been shown to be hard to secure as a whole.</span></p>\n<p class=\"p2\"><span class=\"s1\">&nbsp;</span></p>\n<p class=\"p1\"><span class=\"s1\">We have developed a new, isolated enforcement layer (AIO) that enables</span></p>\n<p class=\"p1\"><span class=\"s1\">transparency and expressive, end-to-end control over the software that</span></p>\n<p class=\"p1\"><span class=\"s1\">collects, processes, and shares I/O data. AIO provides a framework</span></p>\n<p class=\"p1\"><span class=\"s1\">that allows users to directly specify and reason about high level data</span></p>\n<p class=\"p1\"><span class=\"s1\">disposition policies, e.g., &ldquo;my touchscreen PIN input should only be</span></p>\n<p class=\"p1\"><span class=\"s1\">available to the bank server&rdquo;. AIO ensures that these policies are</span></p>\n<p class=\"p1\"><span class=\"s1\">enforced regardless of the behavior or compromise of platform</span></p>\n<p class=\"p1\"><span class=\"s1\">software, including the OS. AIO inherently recognizes and supports</span></p>\n<p class=\"p1\"><span class=\"s1\">many mutually distrusting principals (e.g., device manufacturer,</span></p>\n<p class=\"p1\"><span class=\"s1\">user), providing a means for: 1) scoping trust to each principal, 2)</span></p>\n<p class=\"p1\"><span class=\"s1\">safely composing software from multiple principals, and 3) enabling</span></p>\n<p class=\"p1\"><span class=\"s1\">more-privileged principals enforce policies over paths constructed by</span></p>\n<p class=\"p1\"><span class=\"s1\">less-privileged principals. Policies can be used to construct and</span></p>\n<p class=\"p1\"><span class=\"s1\">compose various forms of assurance over I/O data, such as</span></p>\n<p class=\"p1\"><span class=\"s1\">confidentiality and provenance; AIO provides a way to prove these</span></p>\n<p class=\"p1\"><span class=\"s1\">assurances through (remote) attestation.</span></p>\n<p class=\"p1\"><span class=\"s1\">To give applications the ability to choose abstractions that best meet</span></p>\n<p class=\"p1\"><span class=\"s1\">their individual needs, we have further developed a new Operating</span></p>\n<p class=\"p1\"><span class=\"s1\">System deconstructoin principle called the null-Kernel.<span>&nbsp; </span>The</span></p>\n<p class=\"p1\"><span class=\"s1\">null-Kernel makes it possible to expose multiple abstractions for the</span></p>\n<p class=\"p1\"><span class=\"s1\">same underlying resource simultaneously. The difficulty in exposing</span></p>\n<p class=\"p1\"><span class=\"s1\">low and high level abstractions simultaneously is one of</span></p>\n<p class=\"p1\"><span class=\"s1\">interference. With few exceptions, all abstractions have a set of</span></p>\n<p class=\"p1\"><span class=\"s1\">invariants that must be maintained for the abstraction to offer a</span></p>\n<p class=\"p1\"><span class=\"s1\">useful contract with its callers. If multiple high level abstractions</span></p>\n<p class=\"p1\"><span class=\"s1\">are built on top of the same low level abstraction (e.g., two separate</span></p>\n<p class=\"p1\"><span class=\"s1\">file systems using the same block device) we need a mechanism to</span></p>\n<p class=\"p1\"><span class=\"s1\">prevent interference between different high level abstractions. A</span></p>\n<p class=\"p1\"><span class=\"s1\">traditional OS achieves this by specifying how abstractions may be</span></p>\n<p class=\"p1\"><span class=\"s1\">used a priori and requiring a supervisory process (i.e., the kernel)</span></p>\n<p class=\"p1\"><span class=\"s1\">to enforce usage. Unfortunately, a priori specifications cannot meet</span></p>\n<p class=\"p1\"><span class=\"s1\">the needs of all applications and must have embedded within them their</span></p>\n<p class=\"p1\"><span class=\"s1\">own design trade-offs.</span></p>\n<p class=\"p2\"><span class=\"s1\">&nbsp;</span></p>\n<p class=\"p1\"><span class=\"s1\">The null-Kernel architecture specifies that abstractions be specified</span></p>\n<p class=\"p1\"><span class=\"s1\">in terms of extensible capabilities, with which it is safe to expose</span></p>\n<p class=\"p1\"><span class=\"s1\">multiple abstractions over the same resources. Other OS architectures</span></p>\n<p class=\"p1\"><span class=\"s1\">use capabilities, but they too are defined in terms of existing</span></p>\n<p class=\"p1\"><span class=\"s1\">abstractions a priori. Instead, we suggest that capabilities be</span></p>\n<p class=\"p1\"><span class=\"s1\">defined and enforced by the abstractions they protect. New</span></p>\n<p class=\"p1\"><span class=\"s1\">abstractions that expose hitherto undefined capabilities are created</span></p>\n<p class=\"p1\"><span class=\"s1\">as needed and are built on top of the existing abstractions. The</span></p>\n<p class=\"p1\"><span class=\"s1\">null-Kernel is not defined in terms of what does and does not execute</span></p>\n<p class=\"p1\"><span class=\"s1\">in supervisor mode. The only constraint specified by the null-Kernel</span></p>\n<p class=\"p1\"><span class=\"s1\">is that capabilities are enforced and that abstractions maintain all</span></p>\n<p class=\"p1\"><span class=\"s1\">invariants between calls, and we note that this can be achieved</span></p>\n<p class=\"p1\"><span class=\"s1\">without mode switches when hardware or language features make this</span></p>\n<p class=\"p1\"><span class=\"s1\">possible.</span></p>\n<p class=\"p2\"><span class=\"s1\">&nbsp;</span></p>\n<p class=\"p2\"><span class=\"s1\">&nbsp;</span></p>\n<p class=\"p2\"><span class=\"s1\">&nbsp;</span></p>\n<p>&nbsp;</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 11/12/2020<br>\n\t\t\t\t\tModified by: Samrat&nbsp;Bhattacharjee</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "Personal smart devices provide users with powerful capabilities for\ncommunication, productivity, health, education, and entertainment; many of\nthese applications and services operate over sensitive data related to the\nuser (e.g., recorded audio, location, finances). Naturally, this sensitive\ndata is the target of many attacks, ranging from malicious applications to\ncompromises of the platform software (OS, privileged services, etc.).\nUnfortunately, the amount of control users have on this data is limited.\nFirst, existing systems do not provide support for users to express their\npolicies either due to incomplete settings (e.g., cannot prevent app access\nto motion sensors on Android) or limited expressivity (e.g., can\nenable/disable location, but not adjust data resolution). Second, even when\nthere is support for a desired policy, there is little to no assurance that\nit is being enforced; large platforms, such as in the case of smart devices,\nhave been shown to be hard to secure as a whole.\n \nWe have developed a new, isolated enforcement layer (AIO) that enables\ntransparency and expressive, end-to-end control over the software that\ncollects, processes, and shares I/O data. AIO provides a framework\nthat allows users to directly specify and reason about high level data\ndisposition policies, e.g., \"my touchscreen PIN input should only be\navailable to the bank server\". AIO ensures that these policies are\nenforced regardless of the behavior or compromise of platform\nsoftware, including the OS. AIO inherently recognizes and supports\nmany mutually distrusting principals (e.g., device manufacturer,\nuser), providing a means for: 1) scoping trust to each principal, 2)\nsafely composing software from multiple principals, and 3) enabling\nmore-privileged principals enforce policies over paths constructed by\nless-privileged principals. Policies can be used to construct and\ncompose various forms of assurance over I/O data, such as\nconfidentiality and provenance; AIO provides a way to prove these\nassurances through (remote) attestation.\nTo give applications the ability to choose abstractions that best meet\ntheir individual needs, we have further developed a new Operating\nSystem deconstructoin principle called the null-Kernel.  The\nnull-Kernel makes it possible to expose multiple abstractions for the\nsame underlying resource simultaneously. The difficulty in exposing\nlow and high level abstractions simultaneously is one of\ninterference. With few exceptions, all abstractions have a set of\ninvariants that must be maintained for the abstraction to offer a\nuseful contract with its callers. If multiple high level abstractions\nare built on top of the same low level abstraction (e.g., two separate\nfile systems using the same block device) we need a mechanism to\nprevent interference between different high level abstractions. A\ntraditional OS achieves this by specifying how abstractions may be\nused a priori and requiring a supervisory process (i.e., the kernel)\nto enforce usage. Unfortunately, a priori specifications cannot meet\nthe needs of all applications and must have embedded within them their\nown design trade-offs.\n \nThe null-Kernel architecture specifies that abstractions be specified\nin terms of extensible capabilities, with which it is safe to expose\nmultiple abstractions over the same resources. Other OS architectures\nuse capabilities, but they too are defined in terms of existing\nabstractions a priori. Instead, we suggest that capabilities be\ndefined and enforced by the abstractions they protect. New\nabstractions that expose hitherto undefined capabilities are created\nas needed and are built on top of the existing abstractions. The\nnull-Kernel is not defined in terms of what does and does not execute\nin supervisor mode. The only constraint specified by the null-Kernel\nis that capabilities are enforced and that abstractions maintain all\ninvariants between calls, and we note that this can be achieved\nwithout mode switches when hardware or language features make this\npossible.\n \n \n \n\n \n\n\t\t\t\t\tLast Modified: 11/12/2020\n\n\t\t\t\t\tSubmitted by: Samrat Bhattacharjee"
 }
}