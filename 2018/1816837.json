{
 "awd_id": "1816837",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Small: Principled Compiling and Linking for Multi-Language Software",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927885",
 "po_email": "abanerje@nsf.gov",
 "po_sign_block_name": "Anindya Banerjee",
 "awd_eff_date": "2018-10-01",
 "awd_exp_date": "2022-09-30",
 "tot_intn_awd_amt": 449802.0,
 "awd_amount": 505802.0,
 "awd_min_amd_letter_date": "2018-06-04",
 "awd_max_amd_letter_date": "2022-06-15",
 "awd_abstract_narration": "When building large software systems, programmers should be able to use the best language for each part of the system.  But when a component written in one language becomes part of a multi-language system, it may interoperate with components that have features that don't exist in the original language.  This affects programmers when they refactor code (i.e., make changes that should result in equivalent behavior).  Since programs interact after compilation to a common target, programmers have to understand details of linking and target-level interaction when reasoning about correctly refactoring source components.  Unfortunately, there are no software toolchains available today that support single-language reasoning when components are used in a multi-language system.  This project will develop principled software toolchains for building multi-language software.  The project's novelties include (1) designing language extensions that allow programmers to specify how they wish to interoperate (or link) with conceptual features absent from their language through a mechanism called linking types, and (2) developing compilers that formally guarantee that any reasoning the programmer does at source level is justified after compilation to the target.  The project has the potential for tremendous impact on the software development landscape as it will allow programmers to use a language close to their problem domain and provide them with software toolchains that make it easy to compose components written in different languages into a multi-language software system.\r\n\r\nThe project will evaluate the idea of linking types by extending ML with linking types for interaction with Rust, a language with first-class control, and a normalizing language, and developing type preserving compilers to a common typed LLVM-like target language.  The project will design a rich dependently typed LLVM-like target language that can encapsulate effects from different source languages to support fully abstract compilation from these languages.  The project will also investigate reporting of cross-language type errors to aid programmers when composing components written in different languages.\r\n\r\nThis award reflects NSF's statutory mission and has been deemed worthy of support through evaluation using the Foundation's intellectual merit and broader impacts review criteria.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Amal",
   "pi_last_name": "Ahmed",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Amal Ahmed",
   "pi_email_addr": "amal@ccs.neu.edu",
   "nsf_id": "000573498",
   "pi_start_date": "2018-06-04",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Northeastern University",
  "inst_street_address": "360 HUNTINGTON AVE",
  "inst_street_address_2": "",
  "inst_city_name": "BOSTON",
  "inst_state_code": "MA",
  "inst_state_name": "Massachusetts",
  "inst_phone_num": "6173735600",
  "inst_zip_code": "021155005",
  "inst_country_name": "United States",
  "cong_dist_code": "07",
  "st_cong_dist_code": "MA07",
  "org_lgl_bus_name": "NORTHEASTERN UNIVERSITY",
  "org_prnt_uei_num": "",
  "org_uei_num": "HLTMVS2JZBS6"
 },
 "perf_inst": {
  "perf_inst_name": "Northeastern University",
  "perf_str_addr": "360 Huntington Ave",
  "perf_city_name": "Boston",
  "perf_st_code": "MA",
  "perf_st_name": "Massachusetts",
  "perf_zip_code": "021155005",
  "perf_ctry_code": "US",
  "perf_cong_dist": "07",
  "perf_st_cong_dist": "MA07",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7943",
   "pgm_ref_txt": "PROGRAMMING LANGUAGES"
  },
  {
   "pgm_ref_code": "8206",
   "pgm_ref_txt": "Formal Methods and Verification"
  },
  {
   "pgm_ref_code": "9102",
   "pgm_ref_txt": "WOMEN, MINORITY, DISABLED, NEC"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  }
 ],
 "app_fund": [
  {
   "app_code": "",
   "app_name": "",
   "app_symb_id": "",
   "fund_code": "01002223DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0118",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001819DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0119",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001920DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0120",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01002021DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0121",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01002122DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2018,
   "fund_oblg_amt": 449802.0
  },
  {
   "fund_oblg_fiscal_yr": 2019,
   "fund_oblg_amt": 16000.0
  },
  {
   "fund_oblg_fiscal_yr": 2020,
   "fund_oblg_amt": 8000.0
  },
  {
   "fund_oblg_fiscal_yr": 2021,
   "fund_oblg_amt": 16000.0
  },
  {
   "fund_oblg_fiscal_yr": 2022,
   "fund_oblg_amt": 16000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>When building large-scale software systems, programmers should be able to usedifferent languages for different parts of the system -- i.e., the language thatmakes it easiest to reason about the behavior of that component or module. Inparticular, programmers should be able to reason only in that language whenworking on that component. Unfortunately, there are no software toolchainsthat support single-language reasoning when components are used in amulti-language system because in such a setting, a component written in a&nbsp;language L may interoperate with components that include features that don&rsquo;texist in language L. Since programs interact after compilation to a commontarget, programmers have to understand details of linking and target-levelinteraction when reasoning about source components.&nbsp;</p>\n<p>The primary goal of this project was to investigate how to build principled software toolchains allow programmers to reason about the behavior of source components at the source level-without having to understand details of compilation and linking. &nbsp;The goals include the design of a richly typed target&nbsp;language that can serve as a target of type-preserving compilation from different source languages and support cross-language type errors, as well as investigation of adding linking types to a language to support richer interoperability between the languages.</p>\n<p>The first major result of this project is RichWasm, a richly typed compiler intermediate language that can be compiled to WebAssembly. RichWasm supports safe, fine-grained, shared-memory interoperability between modules, as well as interoperability between languages with manually managed and garbage-collected memory. &nbsp;RichWasm supports polymorphism, immutable and mutable references, and most importantly, two kinds of capabilities: (i) duplicable capabilities that allow a module to access just a single data structure in another module's memory, without being able to access all of that memory; and (ii) unique capabilities which can be used to free or do a type-changing update to a data structure. We developed type-preserving compilers to RichWasm from ML (supports garbage collection), and from a simple Rust-like language (supports manual memory management), and a compiler from RichWasm toregular WebAssembly. We extended ML with a simple form of linking types tosupport safe interaction with the other language and reporting of cross-language type errors.</p>\n<p>The second major outcome of this project is a methodology for verifying the soundness of foreign-function interfaces (FFIs). &nbsp;Every language implements an FFI for language interoperability, but existing FFIs are all ad hoc and it not clear if the type soundness guarantees of the original language are preserved in the presence of interoperability. We developed a semantic framework for proving soundness of FFIs as they are designed \"in the wild\", by which we mean that FFI developers implement conversion between types of data from two different source languages by implementing target-level conversion functions to mediate between data representations coming from the two source languages. We applied this framework to a series of case studies that demonstrate how this approach allows us to account for complex differences in language semantics and make efficiency trade-offs based on specifics of compilers or targets.</p>\n<p>The third result to emerge from this project involves safe encapsulation of foreign code without disturbing the invariants promised by types of the core language. Linking code from one language with another can potentially expose the first language to foreign behaviors that are internally inexpressible, posing a threat to safety invariants. We developed an approach that encapsulates foreign code in a sound way. First, one introduces novel linking types that characterize the behaviors of foreign libraries that are inexpressible in the core language. To reason about the soundness of linking, we construct a semantic model that captures the meaning of both core types and linking types as sets of target-language terms. Using this model, we can formally prove when foreign behavior is encapsulated; that is, unobservable to core code.&nbsp;</p>\n<p>A fourth major result was the development of a generic theorem for correct compilation of components (instead of whole programs). This addresses a critical question about compiler correctness for multi-language systems: how do we even state the compiler correctness theorem in the presence of linking? &nbsp;While there have been a number of recent results on compositional compiler correctness, they all state their correct-component-compilation theorems in remarkably different ways, yielding pros and cons that aren't well understood. &nbsp;We showed that specific compiler-verification efforts can use their choice of formalism ``under the hood'' and then prove that their theorems imply CCC.</p>\n<p>A final goal of the project was the development of a formal semantics of Rust (not including concurrency), which is still under development. &nbsp;The model,called Oxide, is close to source-level Rust---unlike prior work which is more low-level and models MIR, the CPS-style IR used in the Rust compiler. Oxide handles borrowing,dereferencing, mutation, non-lexical lifetimes, closures, and reborrowing. &nbsp;We also developed a \"tested semantics\", having tested our type checker, based on our model of Rust, against the Rust borrow-checker test suite.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 07/31/2023<br>\n\t\t\t\t\tModified by: Amal&nbsp;Ahmed</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nWhen building large-scale software systems, programmers should be able to usedifferent languages for different parts of the system -- i.e., the language thatmakes it easiest to reason about the behavior of that component or module. Inparticular, programmers should be able to reason only in that language whenworking on that component. Unfortunately, there are no software toolchainsthat support single-language reasoning when components are used in amulti-language system because in such a setting, a component written in a language L may interoperate with components that include features that don\u2019texist in language L. Since programs interact after compilation to a commontarget, programmers have to understand details of linking and target-levelinteraction when reasoning about source components. \n\nThe primary goal of this project was to investigate how to build principled software toolchains allow programmers to reason about the behavior of source components at the source level-without having to understand details of compilation and linking.  The goals include the design of a richly typed target language that can serve as a target of type-preserving compilation from different source languages and support cross-language type errors, as well as investigation of adding linking types to a language to support richer interoperability between the languages.\n\nThe first major result of this project is RichWasm, a richly typed compiler intermediate language that can be compiled to WebAssembly. RichWasm supports safe, fine-grained, shared-memory interoperability between modules, as well as interoperability between languages with manually managed and garbage-collected memory.  RichWasm supports polymorphism, immutable and mutable references, and most importantly, two kinds of capabilities: (i) duplicable capabilities that allow a module to access just a single data structure in another module's memory, without being able to access all of that memory; and (ii) unique capabilities which can be used to free or do a type-changing update to a data structure. We developed type-preserving compilers to RichWasm from ML (supports garbage collection), and from a simple Rust-like language (supports manual memory management), and a compiler from RichWasm toregular WebAssembly. We extended ML with a simple form of linking types tosupport safe interaction with the other language and reporting of cross-language type errors.\n\nThe second major outcome of this project is a methodology for verifying the soundness of foreign-function interfaces (FFIs).  Every language implements an FFI for language interoperability, but existing FFIs are all ad hoc and it not clear if the type soundness guarantees of the original language are preserved in the presence of interoperability. We developed a semantic framework for proving soundness of FFIs as they are designed \"in the wild\", by which we mean that FFI developers implement conversion between types of data from two different source languages by implementing target-level conversion functions to mediate between data representations coming from the two source languages. We applied this framework to a series of case studies that demonstrate how this approach allows us to account for complex differences in language semantics and make efficiency trade-offs based on specifics of compilers or targets.\n\nThe third result to emerge from this project involves safe encapsulation of foreign code without disturbing the invariants promised by types of the core language. Linking code from one language with another can potentially expose the first language to foreign behaviors that are internally inexpressible, posing a threat to safety invariants. We developed an approach that encapsulates foreign code in a sound way. First, one introduces novel linking types that characterize the behaviors of foreign libraries that are inexpressible in the core language. To reason about the soundness of linking, we construct a semantic model that captures the meaning of both core types and linking types as sets of target-language terms. Using this model, we can formally prove when foreign behavior is encapsulated; that is, unobservable to core code. \n\nA fourth major result was the development of a generic theorem for correct compilation of components (instead of whole programs). This addresses a critical question about compiler correctness for multi-language systems: how do we even state the compiler correctness theorem in the presence of linking?  While there have been a number of recent results on compositional compiler correctness, they all state their correct-component-compilation theorems in remarkably different ways, yielding pros and cons that aren't well understood.  We showed that specific compiler-verification efforts can use their choice of formalism ``under the hood'' and then prove that their theorems imply CCC.\n\nA final goal of the project was the development of a formal semantics of Rust (not including concurrency), which is still under development.  The model,called Oxide, is close to source-level Rust---unlike prior work which is more low-level and models MIR, the CPS-style IR used in the Rust compiler. Oxide handles borrowing,dereferencing, mutation, non-lexical lifetimes, closures, and reborrowing.  We also developed a \"tested semantics\", having tested our type checker, based on our model of Rust, against the Rust borrow-checker test suite.\n\n\t\t\t\t\tLast Modified: 07/31/2023\n\n\t\t\t\t\tSubmitted by: Amal Ahmed"
 }
}