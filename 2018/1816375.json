{
 "awd_id": "1816375",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SaTC: CORE: Small: API-centric Cryptography",
 "cfda_num": "47.070",
 "org_code": "05050000",
 "po_phone": "7032922981",
 "po_email": "pregalia@nsf.gov",
 "po_sign_block_name": "Phillip Regalia",
 "awd_eff_date": "2018-10-01",
 "awd_exp_date": "2023-09-30",
 "tot_intn_awd_amt": 450000.0,
 "awd_amount": 450000.0,
 "awd_min_amd_letter_date": "2018-08-30",
 "awd_max_amd_letter_date": "2018-08-30",
 "awd_abstract_narration": "Cryptography is a core component of modern technology.  It protects internet transactions, hides usernames and passwords as they traverse networks, protects the data residing on mobile devices and computer disk drives, and much more.  The systems that cryptographic mechanisms are tasked with protecting are typically very complex, with many interacting parts and a large number of places that may be vulnerable (often called the \"attack surface\").  One element of this large attack surface is the connection (or disconnection) between the mathematical algorithms that researchers design and the software that purports to implement these powerful algorithms.  When the software fails to accurately implement the mathematical algorithms, much can go wrong in practice.  This has led to real-world attacks, even though mathematics proves that no such attacks should be possible.  The two main themes of this research are: (1) to develop a broad and deep view of just how prevalent these disconnections are between the mathematical algorithms and their implementation, and (2) to reshape the way that researchers think about their theoretical efforts, so that what they develop is harder for software developers to get wrong, easier to understand, and easier to validate.\r\n\r\nMore specifically, to date the onus is on the security engineers and developers to understand and correctly realize the cryptographic primitives and protocols that are provably secure in theory, and to reshape their existing code base and application programming interfaces (APIs) as required.  This project explores an alternative viewpoint: as real-world libraries and their APIs are necessarily inflexible, the onus is to be on the theory to respect this.  Moreover, ease of correct implementation ought to be a primary design goal.  Whenever possible, theoretical primitives should be resilient to misunderstandings by developers who lack expertise in cryptography.  Concretely, the work includes three main tasks.  The first one applies this \"API-centric\" viewpoint to several important primitives, e.g., secure channels and authenticated key exchange.  It also includes efforts to survey existing standards, libraries, and software artifacts. The second task seeks to develop theoretical primitives that are forgiving of their misuse (e.g., primitives that are robust in the face of bad randomness, and that natively handle highly structured plaintext data). The third task is to develop abstract syntax for cryptographic primitives that is \"thoughtful\" with respect to the real functionalities that will need to be implemented in practice.\r\n\r\nThis award reflects NSF's statutory mission and has been deemed worthy of support through evaluation using the Foundation's intellectual merit and broader impacts review criteria.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CNS",
 "org_div_long_name": "Division Of Computer and Network Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Thomas",
   "pi_last_name": "Shrimpton",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Thomas Shrimpton",
   "pi_email_addr": "teshrim@cise.ufl.edu",
   "nsf_id": "000232896",
   "pi_start_date": "2018-08-30",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Florida",
  "inst_street_address": "1523 UNION RD RM 207",
  "inst_street_address_2": "",
  "inst_city_name": "GAINESVILLE",
  "inst_state_code": "FL",
  "inst_state_name": "Florida",
  "inst_phone_num": "3523923516",
  "inst_zip_code": "326111941",
  "inst_country_name": "United States",
  "cong_dist_code": "03",
  "st_cong_dist_code": "FL03",
  "org_lgl_bus_name": "UNIVERSITY OF FLORIDA",
  "org_prnt_uei_num": "",
  "org_uei_num": "NNFQH1JAPEP3"
 },
 "perf_inst": {
  "perf_inst_name": "University of Florida",
  "perf_str_addr": "",
  "perf_city_name": "",
  "perf_st_code": "FL",
  "perf_st_name": "Florida",
  "perf_zip_code": "326112002",
  "perf_ctry_code": "US",
  "perf_cong_dist": "03",
  "perf_st_cong_dist": "FL03",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "806000",
   "pgm_ele_name": "Secure &Trustworthy Cyberspace"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "025Z",
   "pgm_ref_txt": "SaTC: Secure and Trustworthy Cyberspace"
  },
  {
   "pgm_ref_code": "7434",
   "pgm_ref_txt": "CNCI"
  },
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  }
 ],
 "app_fund": [
  {
   "app_code": "0118",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001819DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2018,
   "fund_oblg_amt": 450000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p><span id=\"docs-internal-guid-786e9515-7fff-9f90-7273-8c33350ad030\"> </span></p>\n<p dir=\"ltr\"><span>The overarching goal of this project is move cryptographic theory closer to cryptographic practice by \"pulling\" from the practice side, rather than \"pushing\" from the theory side.&nbsp; Specifically:</span></p>\n<p dir=\"ltr\"><span>1. To reexamine established formalisms for cryptographic primitives and protocols (syntax and security notions) with the viewpoint that the realities of practice ---real APIs and hardware interfaces, real requirements in deployment, etc.--- should be a (if not </span><span>the</span><span>) primary driver of theory.</span></p>\n<p dir=\"ltr\"><span>2. To develop frameworks for reasoning about cryptographic standards (actual, or de facto) </span><span>as they are</span><span>, rather than reasoning about </span><span>particular</span><span> (often imagined) realizations of standards.</span></p>\n<p dir=\"ltr\"><span>3. To develop tools for reasoning about ease-of-implementation as a security concern.</span></p>\n<p><span id=\"docs-internal-guid-73227df9-7fff-a608-6bb1-eacc98acee0c\">\n<p dir=\"ltr\"><span>Our \"Partially Specified Channels\" paper (ACM CCS&rsquo;19) resulted in a change to the TLS1.3 specification.&nbsp; The conceptual advance of this work was to recognize that specs like TLS do not describe a single protocol, but rather a (very large) family of spec-compliant protocol realizations.&nbsp; This is largely due to two things: first, specs are (for good reasons) vague or silent on many implementation details; second, specs are full of \"SHOULD (NOT)\" and \"MAY (NOT)\" statements that are suggestions, in contrast to \"MUST (NOT)\" statements that are hard requirements.&nbsp; Thus, our abstract syntax for a secure channel consists of core algorithms --functionalities that every secure channel scheme needs to implement-- that take an \"specification details\" oracle.&nbsp; All of the \"MUST (NOT)\" statements are to be observed in the description of the algorithms; everything else, i.e., anything that is not explicitly handled by the algorithms, is effectively pushed into the oracle.&nbsp; Our main security notions then allow the </span><span>adversary</span><span> to respond to any queries these algorithms make to the specification-details oracle.&nbsp; Informally, a proof of security relative to our notions says that any realization of the specification details is secure, i.e., these details truely do not matter for security.</span></p>\n<p dir=\"ltr\"><span>Our \"Security in the Presense of Key Reuse\" paper (CRYPTO&rsquo;19) established a framework for reasoning about the security of a given primitive/protocol when the interface to cryptographic operations (i.e., the underlying software/HW API) is exposed to other processes.&nbsp; Among other things, this framework captures attacks that exploit the reuse of secret keys (and other cryptographic assets) across distinct cryptographic processes.&nbsp; This is a practically important matter, as key-reuse often results because of financial pressures (i.e., not wanting to purchase a certificate for every distinct cryptographic functionality) or deployment restrictions.&nbsp; Additionally, the complexity of modern systems and computing environments can allow unintended key-reuse for subtle reasons.&nbsp; We applied our new analytical tools to several case studies, including the EdDSA signature scheme and the Noise protocol framework.&nbsp; (The latter is used within the popular Wireguard app, for example.)</span></p>\n<p dir=\"ltr\"><span>We developed a new framework for reasoning about the \"translation\" of academic cryptographic protocols, into standards (e.g., TLS v1.3).&nbsp; This work appeared at CRYPTO'20.&nbsp; We used the new framework to analyze the integration of a password-authenticated key exchange (PAKE) into TLS v1.3 as a standard extension.&nbsp; This is something that the CFRG had been actively considering, as PAKEs allow passwords to be used in lieu of certificates, or as a \"hedge\" against PKI failures.</span></p>\n<p dir=\"ltr\"><span>We established formal foundations for mechanisms that aim to hide the design of combinatorial (i.e., stateless) circuits so that they are provably protected against reverse-engineering by untrusted foundries. With these in hand, we were able to show that the goal is achievable, despite more than a decade of work that resulted in broken mechanisms, and the discovery of very powerful and general attacks.&nbsp; We gave the first design-hiding scheme that is provably secure (IEEE Security and Privacy Symposium&rsquo;22).</span></p>\n<p dir=\"ltr\"><span>We investigated the security of probabilistic data structures (PDS), e.g. Bloom filters and variants. PDS are part of a number of open-source and commercial libraries, and are increasingly used in adversarial settings.&nbsp; We were particularly interested in the PDS-subclass of compact frequency estimators (CFE); among other things, CFEs are the basis of practical solutions to the so-called &ldquo;heavy hitters&rdquo; problem (also called the &ldquo;top-k&rdquo; problem, or the &ldquo;elephant flow detection&rdquo; problem) that matters to network routing and QoS, high-frequency trading, competitive multi-player game platforms, massive-scale database query engines, etc.&nbsp; At ACM CCS'23 we presented strongly negative results for the count-min sketch and the HeavyKeeper sketch, both of which are implemented in the open-source RedisBloom library to support the popular Redis database package. Our analysis shows that both PDS, as implemented, are susceptible to adversarial data streams: it is possible to make the true most-frequent stream element &ldquo;disappear&rdquo; from the estimated list of most-frequent elements. Our work also introduced a new PDS, called CountKeeper, which can be viewed (loosely) as a composition of the count-min and HeavyKeeper sketch structures.&nbsp; This is more robust to our attacks, and as a bonus, provides better honest-case performance and correctness than either count-min or HeavyKeeper provide, for the same amount of space. </span></p>\n<div><span><br /></span></div>\n</span></p>\n<p dir=\"ltr\"><span><br /></span></p>\n<div><span><br /></span></div>\n<p>&nbsp;</p>\n<p>&nbsp;</p><br>\n<p>\n Last Modified: 02/05/2024<br>\nModified by: Thomas&nbsp;Shrimpton</p></div>\n<div class=\"porSideCol\"\n></div>\n</div>\n",
  "por_txt_cntn": "\n\n \n\n\nThe overarching goal of this project is move cryptographic theory closer to cryptographic practice by \"pulling\" from the practice side, rather than \"pushing\" from the theory side. Specifically:\n\n\n1. To reexamine established formalisms for cryptographic primitives and protocols (syntax and security notions) with the viewpoint that the realities of practice ---real APIs and hardware interfaces, real requirements in deployment, etc.--- should be a (if not the) primary driver of theory.\n\n\n2. To develop frameworks for reasoning about cryptographic standards (actual, or de facto) as they are, rather than reasoning about particular (often imagined) realizations of standards.\n\n\n3. To develop tools for reasoning about ease-of-implementation as a security concern.\n\n\n\n\n\nOur \"Partially Specified Channels\" paper (ACM CCS19) resulted in a change to the TLS1.3 specification. The conceptual advance of this work was to recognize that specs like TLS do not describe a single protocol, but rather a (very large) family of spec-compliant protocol realizations. This is largely due to two things: first, specs are (for good reasons) vague or silent on many implementation details; second, specs are full of \"SHOULD (NOT)\" and \"MAY (NOT)\" statements that are suggestions, in contrast to \"MUST (NOT)\" statements that are hard requirements. Thus, our abstract syntax for a secure channel consists of core algorithms --functionalities that every secure channel scheme needs to implement-- that take an \"specification details\" oracle. All of the \"MUST (NOT)\" statements are to be observed in the description of the algorithms; everything else, i.e., anything that is not explicitly handled by the algorithms, is effectively pushed into the oracle. Our main security notions then allow the adversary to respond to any queries these algorithms make to the specification-details oracle. Informally, a proof of security relative to our notions says that any realization of the specification details is secure, i.e., these details truely do not matter for security.\n\n\nOur \"Security in the Presense of Key Reuse\" paper (CRYPTO19) established a framework for reasoning about the security of a given primitive/protocol when the interface to cryptographic operations (i.e., the underlying software/HW API) is exposed to other processes. Among other things, this framework captures attacks that exploit the reuse of secret keys (and other cryptographic assets) across distinct cryptographic processes. This is a practically important matter, as key-reuse often results because of financial pressures (i.e., not wanting to purchase a certificate for every distinct cryptographic functionality) or deployment restrictions. Additionally, the complexity of modern systems and computing environments can allow unintended key-reuse for subtle reasons. We applied our new analytical tools to several case studies, including the EdDSA signature scheme and the Noise protocol framework. (The latter is used within the popular Wireguard app, for example.)\n\n\nWe developed a new framework for reasoning about the \"translation\" of academic cryptographic protocols, into standards (e.g., TLS v1.3). This work appeared at CRYPTO'20. We used the new framework to analyze the integration of a password-authenticated key exchange (PAKE) into TLS v1.3 as a standard extension. This is something that the CFRG had been actively considering, as PAKEs allow passwords to be used in lieu of certificates, or as a \"hedge\" against PKI failures.\n\n\nWe established formal foundations for mechanisms that aim to hide the design of combinatorial (i.e., stateless) circuits so that they are provably protected against reverse-engineering by untrusted foundries. With these in hand, we were able to show that the goal is achievable, despite more than a decade of work that resulted in broken mechanisms, and the discovery of very powerful and general attacks. We gave the first design-hiding scheme that is provably secure (IEEE Security and Privacy Symposium22).\n\n\nWe investigated the security of probabilistic data structures (PDS), e.g. Bloom filters and variants. PDS are part of a number of open-source and commercial libraries, and are increasingly used in adversarial settings. We were particularly interested in the PDS-subclass of compact frequency estimators (CFE); among other things, CFEs are the basis of practical solutions to the so-called heavy hitters problem (also called the top-k problem, or the elephant flow detection problem) that matters to network routing and QoS, high-frequency trading, competitive multi-player game platforms, massive-scale database query engines, etc. At ACM CCS'23 we presented strongly negative results for the count-min sketch and the HeavyKeeper sketch, both of which are implemented in the open-source RedisBloom library to support the popular Redis database package. Our analysis shows that both PDS, as implemented, are susceptible to adversarial data streams: it is possible to make the true most-frequent stream element disappear from the estimated list of most-frequent elements. Our work also introduced a new PDS, called CountKeeper, which can be viewed (loosely) as a composition of the count-min and HeavyKeeper sketch structures. This is more robust to our attacks, and as a bonus, provides better honest-case performance and correctness than either count-min or HeavyKeeper provide, for the same amount of space. \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\t\t\t\tLast Modified: 02/05/2024\n\n\t\t\t\t\tSubmitted by: ThomasShrimpton\n"
 }
}