{
 "awd_id": "1837051",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "FMitF: Collaborative Research: RedLeaf: Verified Operating Systems in Rust",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032922585",
 "po_email": "pprabhak@nsf.gov",
 "po_sign_block_name": "Pavithra Prabhakar",
 "awd_eff_date": "2018-09-15",
 "awd_exp_date": "2023-08-31",
 "tot_intn_awd_amt": 399931.0,
 "awd_amount": 399931.0,
 "awd_min_amd_letter_date": "2018-09-07",
 "awd_max_amd_letter_date": "2018-09-07",
 "awd_abstract_narration": "An operating system kernel provides a foundation for isolation and security in every computer system used today. Operating system kernels are trusted to provide the first line of defense for numerous mission critical systems in the face of targeted security attacks. Unfortunately, despite decades of evolution modern operating systems are faulty and vulnerable. Inheriting their core engineering technology from the first time-sharing machines, modern operating system kernels are still developed with a legacy software engineering techniques---a combination of an unsafe programming language, rudimentary concurrency primitives, and virtually no testing or verification tools. Today these systems are faulty and vulnerable. Lacking verification support, industry standard kernels make nearly every computer system on the planet vulnerable. \r\n\r\nThis project will develop RedLeaf, a new operating system, and associated formal verification tools for implementing provably secure and reliable systems in the Rust programming language. RedLeaf brings together state-of-the-art results from verification, programming-language, and systems research communities in order to enable unprecedented security and reliability guarantees in low-level systems software. To achieve complete verification of the entire software stack, i.e., operating system and applications, the RedLeaf team will develop a set of new tools, a collection of techniques and engineering disciplines, and a methodology focused on rapid development of verified systems software. The RedLeaf OS will run on an embedded CPU of a medical sensor, implement a network function virtualization framework aimed at line-rate network processing, and provide a general platform for a broad range of verifiably secure systems. The operating system and associated tools will be open source, directly benefiting the broader community.\r\n\r\nThis award reflects NSF's statutory mission and has been deemed worthy of support through evaluation using the Foundation's intellectual merit and broader impacts review criteria.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Zvonimir",
   "pi_last_name": "Rakamaric",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Zvonimir Rakamaric",
   "pi_email_addr": "zvonimir@cs.utah.edu",
   "nsf_id": "000623290",
   "pi_start_date": "2018-09-07",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Utah",
  "inst_street_address": "201 PRESIDENTS CIR",
  "inst_street_address_2": "",
  "inst_city_name": "SALT LAKE CITY",
  "inst_state_code": "UT",
  "inst_state_name": "Utah",
  "inst_phone_num": "8015816903",
  "inst_zip_code": "841129049",
  "inst_country_name": "United States",
  "cong_dist_code": "01",
  "st_cong_dist_code": "UT01",
  "org_lgl_bus_name": "UNIVERSITY OF UTAH",
  "org_prnt_uei_num": "",
  "org_uei_num": "LL8GLEVH6MG3"
 },
 "perf_inst": {
  "perf_inst_name": "University of Utah",
  "perf_str_addr": "50 Central Campus Dr",
  "perf_city_name": "Salt Lake City",
  "perf_st_code": "UT",
  "perf_st_name": "Utah",
  "perf_zip_code": "841129205",
  "perf_ctry_code": "US",
  "perf_cong_dist": "01",
  "perf_st_cong_dist": "UT01",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "094Y00",
   "pgm_ele_name": "FMitF: Formal Methods in the F"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "062Z",
   "pgm_ref_txt": "Harnessing the Data Revolution"
  },
  {
   "pgm_ref_code": "071Z",
   "pgm_ref_txt": "FMitF-Formal Methods in the Field"
  }
 ],
 "app_fund": [
  {
   "app_code": "0118",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001819DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2018,
   "fund_oblg_amt": 399931.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Rust has gained popularity as the programming language of choice for implementing systems code. This is because it focuses on safety out-of-the-box from its basic principles,&nbsp;such as memory safety using its elaborate linear type system. However, despite ensuring memory safety, there is still a need to develop tools that allow us to verify custom properties, in the form of assertions, in Rust programs. To achieve this goal, we develop Rust verification techniques within the SMACK software  verification toolchain, which leverages the LLVM compiler infrastructure, Boogie intermediate verification language, and SMT  solvers.</p>\n<p>The SMACK verifier extended with support for Rust was applied to real-world Rust programs. We in particular focused on verifying the equivalence between Rust programs and their C counterparts. That is a critical functionality given that numerous C programs are being rewritten into Rust nowadays. To be able to verify real-world Rust programs, we implemented models for the commonly used Rust standard libraries (such as vectors). We also delivered a cross-language verification extension of SMACK capable of verifying languages beyond just Rust and C, such as Fortran. As a part of this effort, we publicly released a set of cross-language verification benchmarks to be used by the software verification community.</p><br>\n<p>\n Last Modified: 05/25/2024<br>\nModified by: Zvonimir&nbsp;Rakamaric</p></div>\n<div class=\"porSideCol\"\n></div>\n</div>\n",
  "por_txt_cntn": "\n\nRust has gained popularity as the programming language of choice for implementing systems code. This is because it focuses on safety out-of-the-box from its basic principles,such as memory safety using its elaborate linear type system. However, despite ensuring memory safety, there is still a need to develop tools that allow us to verify custom properties, in the form of assertions, in Rust programs. To achieve this goal, we develop Rust verification techniques within the SMACK software  verification toolchain, which leverages the LLVM compiler infrastructure, Boogie intermediate verification language, and SMT  solvers.\n\n\nThe SMACK verifier extended with support for Rust was applied to real-world Rust programs. We in particular focused on verifying the equivalence between Rust programs and their C counterparts. That is a critical functionality given that numerous C programs are being rewritten into Rust nowadays. To be able to verify real-world Rust programs, we implemented models for the commonly used Rust standard libraries (such as vectors). We also delivered a cross-language verification extension of SMACK capable of verifying languages beyond just Rust and C, such as Fortran. As a part of this effort, we publicly released a set of cross-language verification benchmarks to be used by the software verification community.\t\t\t\t\tLast Modified: 05/25/2024\n\n\t\t\t\t\tSubmitted by: ZvonimirRakamaric\n"
 }
}