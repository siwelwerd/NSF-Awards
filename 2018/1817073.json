{
 "awd_id": "1817073",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Small: Indy: Toward Safe and Fast Compiler Flags",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032922585",
 "po_email": "pprabhak@nsf.gov",
 "po_sign_block_name": "Pavithra Prabhakar",
 "awd_eff_date": "2018-10-01",
 "awd_exp_date": "2021-09-30",
 "tot_intn_awd_amt": 481430.0,
 "awd_amount": 497430.0,
 "awd_min_amd_letter_date": "2018-07-20",
 "awd_max_amd_letter_date": "2019-04-09",
 "awd_abstract_narration": "Rapid advances in computer architecture are necessitated by the growing demand for computing speed and also energy efficiency. Unfortunately, these advances require significant adaptations of existing software and their recompilation, and when applied to software in scientific simulations and engineering domains, the numeric outputs of these software can change. This issue is of significant concern, as the whole scientific and engineering enterprise rests on reproducible results building on top of prior contributions. This research project develops methods to detect and isolate those software components responsible for changing answers, and produces actionable evidence in terms of the software routines that need to be rewritten. This ensures that scientific software can truly become an asset that serves generations of research, and not be obviated every three or so years when hardware changes.\r\n\r\nThe project develops methods to compile a users' software application or library using different compilers and executing on different platforms. Given a collection of acceptance tests, the tools developed in this work (collectively called \"Indy\", connoting \"Fast and Safe Compiler Flags\") help detect those components that produce unacceptably deviant answers. Then, employing code bisection methods, the Indy tools root-cause the source of variability to the level of single file or even to a single function symbol. Given that the methods used by Indy can be computationally intensive, the project also explores machine-learning methods and other static analysis methods to avoid wholesale recompilation and re-execution. The Indy tools are maintained on public repositories, and the investigative team maintains strong connections with user-groups to ensure tool adoption, feedback, and refinement. The project will release Indy as open source and build a user community around Indy by ensuring that interested researchers are able to contribute to the code-base. This will allow a wider growth of the project. This aspect is of special interest to the software cluster in the NSF Office of Advanced Cyberinfrastructure, which is co-funding this award.\r\n\r\nThis award reflects NSF's statutory mission and has been deemed worthy of support through evaluation using the Foundation's intellectual merit and broader impacts review criteria.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Ganesh",
   "pi_last_name": "Gopalakrishnan",
   "pi_mid_init": "L",
   "pi_sufx_name": "",
   "pi_full_name": "Ganesh L Gopalakrishnan",
   "pi_email_addr": "ganesh@cs.utah.edu",
   "nsf_id": "000160895",
   "pi_start_date": "2018-07-20",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Utah",
  "inst_street_address": "201 PRESIDENTS CIR",
  "inst_street_address_2": "",
  "inst_city_name": "SALT LAKE CITY",
  "inst_state_code": "UT",
  "inst_state_name": "Utah",
  "inst_phone_num": "8015816903",
  "inst_zip_code": "841129049",
  "inst_country_name": "United States",
  "cong_dist_code": "01",
  "st_cong_dist_code": "UT01",
  "org_lgl_bus_name": "UNIVERSITY OF UTAH",
  "org_prnt_uei_num": "",
  "org_uei_num": "LL8GLEVH6MG3"
 },
 "perf_inst": {
  "perf_inst_name": "University of Utah",
  "perf_str_addr": "",
  "perf_city_name": "Salt Lake City",
  "perf_st_code": "UT",
  "perf_st_name": "Utah",
  "perf_zip_code": "841129205",
  "perf_ctry_code": "US",
  "perf_cong_dist": "01",
  "perf_st_cong_dist": "UT01",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  },
  {
   "pgm_ele_code": "800400",
   "pgm_ele_name": "Software Institutes"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "026Z",
   "pgm_ref_txt": "NSCI: National Strategic Computing Initi"
  },
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7942",
   "pgm_ref_txt": "HIGH-PERFORMANCE COMPUTING"
  },
  {
   "pgm_ref_code": "8004",
   "pgm_ref_txt": "Software Institutes"
  },
  {
   "pgm_ref_code": "8206",
   "pgm_ref_txt": "Formal Methods and Verification"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  }
 ],
 "app_fund": [
  {
   "app_code": "0118",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001819DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0119",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001920DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2018,
   "fund_oblg_amt": 481430.0
  },
  {
   "fund_oblg_fiscal_yr": 2019,
   "fund_oblg_amt": 16000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p><br />This project aims to ensure that numerical software that is central to innovation and making new scientific discoveries is not rendered unreliable when recompiled using newer compilers and/or newer levels of optimizations. Compilers are created independent of their usage context, but come with somewhat clear instructions on what to expect in terms of performance when applied to compile numerical software. Unfortunately, compilers do not (and reasonably cannot) come with any promises of how the computed results change when aggressive optimizations are invoked. Under such optimizations, compilers reassociate arithmetic expressions: for instance, change the order in which large arrays of numbers are added and/or multiplied. When applied to numerical arrays with widely differing values that are represented using the floating-point representation scheme, theoverall numerical rounding incurred can change widely.&nbsp; While most codes tend to be unaffected by numerical rounding error changes which are relatively small, some codes---e.g., those used for climatesimulation---are significantly affected.<br /><br />This project Indy resulted in a tool called FLiT. This tool accepts a test harness consisting of the compilers of interest and their optimization flags. It also takes an application of interest and a baseline compilation plus the results produced by that level of compilation. Then, FLiT considers various flag combinations till it finds sensitive combinations of optimization flags. This can be used to forewarn users or diagnose and root-cause deviant compilations.<br /><br />The main outcomes of the Indy project are several prominent publications, but most importantly a stable piece of software called FLiT that has been presented in multiple tutorials. It also has spawned future work in terms of now being adapted for compilation targeting GPUs which are increasingly being used in scientific computing.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 01/30/2022<br>\n\t\t\t\t\tModified by: Ganesh&nbsp;L&nbsp;Gopalakrishnan</p>\n</div>\n<div class=\"porSideCol\">\n<div class=\"each-gallery\">\n<div class=\"galContent\" id=\"gallery0\">\n<div class=\"photoCount\" id=\"photoCount0\">\n\t\t\t\t\t\t\t\t\tImage\n\t\t\t\t\t\t\t\t</div>\n<div class=\"galControls onePhoto\" id=\"controls0\"></div>\n<div class=\"galSlideshow\" id=\"slideshow0\"></div>\n<div class=\"galEmbox\" id=\"embox\">\n<div class=\"image-title\"></div>\n</div>\n</div>\n<div class=\"galNavigation onePhoto\" id=\"navigation0\">\n<ul class=\"thumbs\" id=\"thumbs0\">\n<li>\n<a href=\"/por/images/Reports/POR/2022/1817073/1817073_10559718_1643553282529_flit-search--rgov-214x142.jpg\" original=\"/por/images/Reports/POR/2022/1817073/1817073_10559718_1643553282529_flit-search--rgov-800width.jpg\" title=\"FLiT Search\"><img src=\"/por/images/Reports/POR/2022/1817073/1817073_10559718_1643553282529_flit-search--rgov-66x44.jpg\" alt=\"FLiT Search\"></a>\n<div class=\"imageCaptionContainer\">\n<div class=\"imageCaption\">Bisection Search of Result-Changing Optimizations</div>\n<div class=\"imageCredit\">Michael Bentley</div>\n<div class=\"imageSubmitted\">Ganesh&nbsp;L&nbsp;Gopalakrishnan</div>\n<div class=\"imageTitle\">FLiT Search</div>\n</div>\n</li>\n</ul>\n</div>\n</div>\n</div>\n</div>",
  "por_txt_cntn": "\n\nThis project aims to ensure that numerical software that is central to innovation and making new scientific discoveries is not rendered unreliable when recompiled using newer compilers and/or newer levels of optimizations. Compilers are created independent of their usage context, but come with somewhat clear instructions on what to expect in terms of performance when applied to compile numerical software. Unfortunately, compilers do not (and reasonably cannot) come with any promises of how the computed results change when aggressive optimizations are invoked. Under such optimizations, compilers reassociate arithmetic expressions: for instance, change the order in which large arrays of numbers are added and/or multiplied. When applied to numerical arrays with widely differing values that are represented using the floating-point representation scheme, theoverall numerical rounding incurred can change widely.  While most codes tend to be unaffected by numerical rounding error changes which are relatively small, some codes---e.g., those used for climatesimulation---are significantly affected.\n\nThis project Indy resulted in a tool called FLiT. This tool accepts a test harness consisting of the compilers of interest and their optimization flags. It also takes an application of interest and a baseline compilation plus the results produced by that level of compilation. Then, FLiT considers various flag combinations till it finds sensitive combinations of optimization flags. This can be used to forewarn users or diagnose and root-cause deviant compilations.\n\nThe main outcomes of the Indy project are several prominent publications, but most importantly a stable piece of software called FLiT that has been presented in multiple tutorials. It also has spawned future work in terms of now being adapted for compilation targeting GPUs which are increasingly being used in scientific computing.\n\n\t\t\t\t\tLast Modified: 01/30/2022\n\n\t\t\t\t\tSubmitted by: Ganesh L Gopalakrishnan"
 }
}