{
 "awd_id": "1816951",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Small: Collaborative Research: Static Analysis Infrastructure for Variability-Aware Bug Detection and Translation of Highly-Configurable Software Systems",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927841",
 "po_email": "sgreensp@nsf.gov",
 "po_sign_block_name": "Sol Greenspan",
 "awd_eff_date": "2018-10-01",
 "awd_exp_date": "2022-09-30",
 "tot_intn_awd_amt": 241319.0,
 "awd_amount": 241319.0,
 "awd_min_amd_letter_date": "2018-05-30",
 "awd_max_amd_letter_date": "2018-05-30",
 "awd_abstract_narration": "Highly-configurable systems, e.g., the Linux kernel, form our most critical infrastructure, underpinning everything from high-performance computing clusters to IoT devices.  Keeping these systems secure and reliable with automated tools is essential.  However, tool support is lacking for such systems because of the complexity and scale of their configurability.  This leaves some of the most critical software with some of the least tool support.  The problem is that most software tools are not variability-aware; that is, they do not account for the many configurations of the software.  Serious defects, including null pointer errors and buffer overflows, can and do appear in specific configurations, making them hard to find without accounting for variability.  The goal of this project is to advance the state of the art for systems development and debugging, resulting in more secure and less error-prone systems, benefiting the millions who rely on highly-configurable software infrastructure.\r\n\r\nTo solve these challenges, this project aims to develop the infrastructure, analysis techniques, and language support for debugging and maintaining configurable software systems written in C-family languages, currently lacking for software developers.  The first part of the project is to develop a front-end infrastructure that captures these sources of variability in a new intermediate representation. Such reusable infrastructure is crucial to the development of state-of-the-art analyses.  The second part seeks to create variability-aware versions of static analyses and propose new inter-procedural analyses that enable tradeoffs between scalability and precision.  While static analysis has proven useful for detecting bugs, accounting for configurations increases the complexity of analysis.  Systematic extensions to bug detection algorithms based on these new analyses can target previously obscured bugs.  Since the C preprocessor has long been recognized as a source of problems, the third part of this project is to develop new language extensions to C, supplanting preprocessor usage and enabling compiler support for variability specifications.  Translators to the new language based on our front-end analysis infrastructure will enable existing software to benefit from the new language.  The PIs on this project will mentor graduate students and are committed to promoting female and under-represented minority participation.  Artifacts developed in this project will be used in courses to introduce students to state-of-the-art software tool development.\r\n\r\nThis award reflects NSF's statutory mission and has been deemed worthy of support through evaluation using the Foundation's intellectual merit and broader impacts review criteria.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Shiyi",
   "pi_last_name": "Wei",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Shiyi Wei",
   "pi_email_addr": "swei@utdallas.edu",
   "nsf_id": "000754240",
   "pi_start_date": "2018-05-30",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Texas at Dallas",
  "inst_street_address": "800 WEST CAMPBELL RD.",
  "inst_street_address_2": "SP2.25",
  "inst_city_name": "RICHARDSON",
  "inst_state_code": "TX",
  "inst_state_name": "Texas",
  "inst_phone_num": "9728832313",
  "inst_zip_code": "750803021",
  "inst_country_name": "United States",
  "cong_dist_code": "24",
  "st_cong_dist_code": "TX24",
  "org_lgl_bus_name": "UNIVERSITY OF TEXAS AT DALLAS",
  "org_prnt_uei_num": "",
  "org_uei_num": "EJCVPNN1WFS5"
 },
 "perf_inst": {
  "perf_inst_name": "University of Texas at Dallas",
  "perf_str_addr": "800 W. Campbell Rd., AD15",
  "perf_city_name": "Richardson",
  "perf_st_code": "TX",
  "perf_st_name": "Texas",
  "perf_zip_code": "750803021",
  "perf_ctry_code": "US",
  "perf_cong_dist": "24",
  "perf_st_cong_dist": "TX24",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7944",
   "pgm_ref_txt": "SOFTWARE ENG & FORMAL METHODS"
  }
 ],
 "app_fund": [
  {
   "app_code": "0118",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001819DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2018,
   "fund_oblg_amt": 241319.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p><span id=\"docs-internal-guid-c323cbef-7fff-456b-5f61-be84cd851d75\"> </span></p>\n<p dir=\"ltr\"><span>Tool support is lacking for highly-configurable systems, such as the Linux kernel, because of the complexity and scale of their configurability. The problem is that most software tools do not account for the many configurations of the software, i.e., are variability-oblivious. However, bugs such as null pointer errors and buffer overflows can appear in arbitrary configurations, making them hard to find with existing tools. The main goal of this project is to advance the state-of-the-art in program analysis for highly-configurable C systems software. The project includes the development of an analysis infrastructure that enables variability bug-finding. Achieving this requires overcoming the precision and scalability challenges to the underlying analysis algorithms.</span></p>\n<p>&nbsp;</p>\n<p dir=\"ltr\"><span>We introduced a new framework for generating benchmarks of variability-aware bugs. This framework simulates variability-aware analysis using off-the-shelf bug detectors by running them on samples of configurations. Unlike prior techniques for developing variability bug datasets, our approach finds bugs known to be discoverable by state-of-the-art bug finding tools. Therefore, the results are applicable to evaluating the variability-aware analysis that we developed under this project.</span></p>\n<p>&nbsp;</p>\n<p dir=\"ltr\"><span>For the front-end of our variability-aware analysis development, we designed and implemented a scalable desugaring transformation, SugarC, that translates unpreprocessed C to pure C.&nbsp; This closes the gap between existing variability-oblivious and variability-aware analyses by converting configurable C code into pure C. The variability remains encoded in C, which can be analyzed by existing analyses. To evaluate support for desugaring C constructs, we created a new benchmark called DesugarBench, showing that SugarC supports many more constructs than prior works, especially the kinds of challenging cases found in real-world C.</span></p>\n<p>&nbsp;</p>\n<p dir=\"ltr\"><span>We developed two parallel efforts for exploring variability-aware analysis on top of the front-end.&nbsp; First, VarAlyzer is an end-to-end variability-aware dataflow analysis. VarAlyzer was evaluated by conducting a typestate analysis that checks for correct API usage. Second, Sugarlyzer is an extensible framework that enables the integration of many existing variability-oblivious tools. To demonstrate the extensibility of Sugarlyzer, we integrate three popular static analyzers (Clang, Infer, and Phasar) into Sugarlyzer. The integration only requires dozens of lines of code to implement. We have run all three integrated tools on a variability bug dataset, VBDb, in order to assess Sugarzlyer?s correctness and effectiveness. The results show that Sugarlyzer is able to detect the vast majority of variability bugs present in the dataset (78/105), compared to a baseline that exhaustively tests all configurations.</span></p>\n<p>&nbsp;</p>\n<p dir=\"ltr\"><span>Our analysis of macro usage has yielded formal properties describing the transformability of macro usage. Specifically, it categorizes macros by their semantic equivalence to C function. We used these properties to determine what macros are transformable without any change to the interface of the macro. Furthermore, we implemented these properties in a lightweight static analysis which informs our transformer that rewrites equivalent macros to C function, thereby removing the preprocessor usage.</span></p>\n<p>&nbsp;</p>\n<p dir=\"ltr\"><span>We used our build system constraint extraction algorithms to generate valid build configuration for the Linux kernel. This process found build errors, which we patched and reported to the Linux developers. We have released a new version of the constraint analysis tool publicly and had one accepted build system patch to the Linux kernel source.</span></p>\n<p>&nbsp;</p>\n<p dir=\"ltr\"><span>We used ConfigFuzz to transform six common fuzzing targets and carried out the evaluation using the AFL and AFL++ fuzzers. ConfigFuzz shows better performance than two baseline setups in four targets. We analyze the target programs? source code and the options fuzzed by ConfigFuzz to reason about the fuzzing performance. We also show that parameterizing ConfigFuzz to fuzz configurations with up to 2 options often leads to higher code coverage than up to 1 option, while fuzzing many more options with ConfigFuzz may decrease the performance.</span></p>\n<p>&nbsp;</p>\n<p dir=\"ltr\"><span>The research results from this grant were disseminated to several competitive conferences and journals including, but not limited to, the International Conference of Software Engineering (ICSE), Transactions on Software Engineering and Methodology (TOSEM), and the Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering (ESEC/FSE). Nine peer-review publications were produced that were funded in part by this grant. Artifacts produced during this grant have been disseminated publicly in repositories containing both the software source code, experimental scripts, and resulting data.</span></p>\n<p>&nbsp;</p>\n<p dir=\"ltr\"><span>Ten graduate and six undergraduate students were funded in part from this research, including five from groups underrepresented in computing. Two of the graduate students were doctoral students who graduated with dissertation work funded in part by the grant and one masters student graduated during the grant, all of whom now work in the software industry. Five graduate courses received content based on grant research, including a graduate course on configurable software, an independent study on configurable software, and courses on operating systems and compilers that incorporate material related to the grant.</span></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 01/15/2023<br>\n\t\t\t\t\tModified by: Shiyi&nbsp;Wei</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\n \nTool support is lacking for highly-configurable systems, such as the Linux kernel, because of the complexity and scale of their configurability. The problem is that most software tools do not account for the many configurations of the software, i.e., are variability-oblivious. However, bugs such as null pointer errors and buffer overflows can appear in arbitrary configurations, making them hard to find with existing tools. The main goal of this project is to advance the state-of-the-art in program analysis for highly-configurable C systems software. The project includes the development of an analysis infrastructure that enables variability bug-finding. Achieving this requires overcoming the precision and scalability challenges to the underlying analysis algorithms.\n\n \nWe introduced a new framework for generating benchmarks of variability-aware bugs. This framework simulates variability-aware analysis using off-the-shelf bug detectors by running them on samples of configurations. Unlike prior techniques for developing variability bug datasets, our approach finds bugs known to be discoverable by state-of-the-art bug finding tools. Therefore, the results are applicable to evaluating the variability-aware analysis that we developed under this project.\n\n \nFor the front-end of our variability-aware analysis development, we designed and implemented a scalable desugaring transformation, SugarC, that translates unpreprocessed C to pure C.  This closes the gap between existing variability-oblivious and variability-aware analyses by converting configurable C code into pure C. The variability remains encoded in C, which can be analyzed by existing analyses. To evaluate support for desugaring C constructs, we created a new benchmark called DesugarBench, showing that SugarC supports many more constructs than prior works, especially the kinds of challenging cases found in real-world C.\n\n \nWe developed two parallel efforts for exploring variability-aware analysis on top of the front-end.  First, VarAlyzer is an end-to-end variability-aware dataflow analysis. VarAlyzer was evaluated by conducting a typestate analysis that checks for correct API usage. Second, Sugarlyzer is an extensible framework that enables the integration of many existing variability-oblivious tools. To demonstrate the extensibility of Sugarlyzer, we integrate three popular static analyzers (Clang, Infer, and Phasar) into Sugarlyzer. The integration only requires dozens of lines of code to implement. We have run all three integrated tools on a variability bug dataset, VBDb, in order to assess Sugarzlyer?s correctness and effectiveness. The results show that Sugarlyzer is able to detect the vast majority of variability bugs present in the dataset (78/105), compared to a baseline that exhaustively tests all configurations.\n\n \nOur analysis of macro usage has yielded formal properties describing the transformability of macro usage. Specifically, it categorizes macros by their semantic equivalence to C function. We used these properties to determine what macros are transformable without any change to the interface of the macro. Furthermore, we implemented these properties in a lightweight static analysis which informs our transformer that rewrites equivalent macros to C function, thereby removing the preprocessor usage.\n\n \nWe used our build system constraint extraction algorithms to generate valid build configuration for the Linux kernel. This process found build errors, which we patched and reported to the Linux developers. We have released a new version of the constraint analysis tool publicly and had one accepted build system patch to the Linux kernel source.\n\n \nWe used ConfigFuzz to transform six common fuzzing targets and carried out the evaluation using the AFL and AFL++ fuzzers. ConfigFuzz shows better performance than two baseline setups in four targets. We analyze the target programs? source code and the options fuzzed by ConfigFuzz to reason about the fuzzing performance. We also show that parameterizing ConfigFuzz to fuzz configurations with up to 2 options often leads to higher code coverage than up to 1 option, while fuzzing many more options with ConfigFuzz may decrease the performance.\n\n \nThe research results from this grant were disseminated to several competitive conferences and journals including, but not limited to, the International Conference of Software Engineering (ICSE), Transactions on Software Engineering and Methodology (TOSEM), and the Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering (ESEC/FSE). Nine peer-review publications were produced that were funded in part by this grant. Artifacts produced during this grant have been disseminated publicly in repositories containing both the software source code, experimental scripts, and resulting data.\n\n \nTen graduate and six undergraduate students were funded in part from this research, including five from groups underrepresented in computing. Two of the graduate students were doctoral students who graduated with dissertation work funded in part by the grant and one masters student graduated during the grant, all of whom now work in the software industry. Five graduate courses received content based on grant research, including a graduate course on configurable software, an independent study on configurable software, and courses on operating systems and compilers that incorporate material related to the grant.\n\n \n\n \n\n\t\t\t\t\tLast Modified: 01/15/2023\n\n\t\t\t\t\tSubmitted by: Shiyi Wei"
 }
}