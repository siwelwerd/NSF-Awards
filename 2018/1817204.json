{
 "awd_id": "1817204",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Small: M2C: Models to Code",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032922585",
 "po_email": "pprabhak@nsf.gov",
 "po_sign_block_name": "Pavithra Prabhakar",
 "awd_eff_date": "2018-10-01",
 "awd_exp_date": "2023-09-30",
 "tot_intn_awd_amt": 499860.0,
 "awd_amount": 499860.0,
 "awd_min_amd_letter_date": "2018-08-23",
 "awd_max_amd_letter_date": "2018-08-23",
 "awd_abstract_narration": "Software is a critical part of the economic infrastructure and software errors cost tens of billions of dollars annually.  Models are often used to capture the behavior of software components, users, and the physical environment, as well as their interaction. However, these models are often ignored when implementing the system in code.  The M2C (Models to Code) project is a pilot study aimed at bridging the gap between design-level models and code-level implementations through the generation of correct and efficient code from high-level design models.  The M2C project creates infrastructure for defining models, using them in designing systems that are correct by construction, and generating code that faithfully implements these models on a range of platforms. This will help improve the software development process globally, with substantial savings in associated costs.\r\n\r\nIn M2C, formalized models of computation are used to model complex systems.  These models are analyzed compositionally for correctness, and code is generated from them to support simulation and efficient execution.  The investigators specifically consider two basic paradigms.  The first is a functional sublanguage of the PVS Specification and verification system that can be used to define widely used mathematical and statistical operations, and to capture the semantics of processor instruction sets, programming languages, and models of computation.  The second is a compositional model of computation based on quasi-periodic execution that underpins the architecture definition language Radler.  By focusing on the generation of correct and efficient code from verified models, this project creates a seamless design flow for safety-critical software-based systems going from abstract mathematical models to concrete code that can be used for simulation or execution.\r\n\r\nThis award reflects NSF's statutory mission and has been deemed worthy of support through evaluation using the Foundation's intellectual merit and broader impacts review criteria.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Natarajan",
   "pi_last_name": "Shankar",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Natarajan Shankar",
   "pi_email_addr": "shankar@csl.sri.com",
   "nsf_id": "000370169",
   "pi_start_date": "2018-08-23",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "SRI International",
  "inst_street_address": "333 RAVENSWOOD AVE",
  "inst_street_address_2": "",
  "inst_city_name": "MENLO PARK",
  "inst_state_code": "CA",
  "inst_state_name": "California",
  "inst_phone_num": "6097342285",
  "inst_zip_code": "940253493",
  "inst_country_name": "United States",
  "cong_dist_code": "16",
  "st_cong_dist_code": "CA16",
  "org_lgl_bus_name": "SRI INTERNATIONAL",
  "org_prnt_uei_num": "SRG2J1WS9X63",
  "org_uei_num": "SRG2J1WS9X63"
 },
 "perf_inst": {
  "perf_inst_name": "SRI International",
  "perf_str_addr": "333 Ravenswood Ave",
  "perf_city_name": "Menlo Park",
  "perf_st_code": "CA",
  "perf_st_name": "California",
  "perf_zip_code": "940253493",
  "perf_ctry_code": "US",
  "perf_cong_dist": "16",
  "perf_st_cong_dist": "CA16",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "287800",
   "pgm_ele_name": "Special Projects - CCF"
  },
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "8206",
   "pgm_ref_txt": "Formal Methods and Verification"
  }
 ],
 "app_fund": [
  {
   "app_code": "0118",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001819DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2018,
   "fund_oblg_amt": 499860.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>The goal of the Models to Code project is to bridge the gap between<br />mathematical models and executable code to get the best of both<br />worlds: powerful reasoning complemented with safe, efficient<br />executable models.&nbsp; Errors in safety-critical code can have<br />catastrophic consequences, but developing error-free code is a hard<br />challenge.&nbsp; We have been developing an approach to high- assurance<br />software systems based on the efficient argument thesis: systems<br />should be designed hand-in-hand with an assurance argument that<br />employs claims and assumptions that can be easily falsified if wrong.<br />The pillars of an efficient argument approach to software design are<br />models, architectures, languages, and tools.&nbsp; The ability to generate<br />code directly from models is a key tool since the generated code meets <br />certain correctness criteria by construction.<br /><br />The biggest accomplishment is the completion of the PVS2C code<br />generator which supports a comprehensive framework for transforming<br />mathematical models in the highly expressive PVS specification<br />language into highly efficient code. Related extensions to PVS include<br />a powerful strings library. The code generator supports all of the<br />basic numeric types (including floating-point and multi-precision<br />representations), fixed and flexible-length arrays, infinite arrays,<br />polymorphism, closures, algebraic datatypes, and file I/O. A key<br />property of the generated code (assuming the source PVS has been<br />fullly typechecked) is that it can only fail by exhausting (stack or<br />heap) resources. The targeted subset of C is also small, supporting an<br />eventual formalized proof of the key property. We have established the<br />correctness of the code generator for an idealized language in a<br />pencil-and-paper argument. We have also implemented prototype code<br />generators targeting Rust and oCaml. We have carried out case studies<br />on the code generator with crypto operations, e.g., the AES protocol,<br />and a parser interpreter for the Parsing Expression Grammar (PEG)<br />formalism. In both cases, the performance of the generated code is<br />encouraging (given that the source programs are mathematical<br />models). In the latter case of the parser interpreter, we also<br />performed a case study on proof robustness by refining the PEG<br />formalization in significant ways. We were able to demonstrate that<br />proofs remained robustly replayable in spite of these modifications<br />largely due to the careful and judicious combination of automation and<br />manual guidance supported by PVS. We have also implemented a<br />translator from PVS to the SMT-LIB2 language to integrate other SMT<br />solvers (than Yices2) as back- end reasoning tools. Additionally, we<br />have developed a prototype proof recommender system called CoProver to<br />assist users with proof steps and lemma selections by training<br />suitable machine learning models for these tasks.<br /><br />Another significant activity has been the development of<br />conflict-directed satisfiability algorithms. The conflict-directed<br />strategy for constraint solving is one where nontrivial reasoning is<br />only performed when the assignments to variables are in conflict with<br />the constraints. Conflict-driven reasoning is used to extract a<br />concise explanation in the form of a conflict clause that redirects<br />the search for a satisfying assignment. The CDCL algorithm for Boolean<br />satisfiability is an example of a conflict-directed search<br />algorithm. The MCSAT algorithm approaches theory solving in a similar<br />manner. With the CDSAT algorithm, we have defined a technique that<br />works across a combination of theories. This has also led to novel<br />ways of handling quantified constraints.</p><br>\n<p>\n Last Modified: 01/31/2024<br>\nModified by: Natarajan&nbsp;Shankar</p></div>\n<div class=\"porSideCol\"\n></div>\n</div>\n",
  "por_txt_cntn": "\n\nThe goal of the Models to Code project is to bridge the gap between\nmathematical models and executable code to get the best of both\nworlds: powerful reasoning complemented with safe, efficient\nexecutable models. Errors in safety-critical code can have\ncatastrophic consequences, but developing error-free code is a hard\nchallenge. We have been developing an approach to high- assurance\nsoftware systems based on the efficient argument thesis: systems\nshould be designed hand-in-hand with an assurance argument that\nemploys claims and assumptions that can be easily falsified if wrong.\nThe pillars of an efficient argument approach to software design are\nmodels, architectures, languages, and tools. The ability to generate\ncode directly from models is a key tool since the generated code meets \ncertain correctness criteria by construction.\n\nThe biggest accomplishment is the completion of the PVS2C code\ngenerator which supports a comprehensive framework for transforming\nmathematical models in the highly expressive PVS specification\nlanguage into highly efficient code. Related extensions to PVS include\na powerful strings library. The code generator supports all of the\nbasic numeric types (including floating-point and multi-precision\nrepresentations), fixed and flexible-length arrays, infinite arrays,\npolymorphism, closures, algebraic datatypes, and file I/O. A key\nproperty of the generated code (assuming the source PVS has been\nfullly typechecked) is that it can only fail by exhausting (stack or\nheap) resources. The targeted subset of C is also small, supporting an\neventual formalized proof of the key property. We have established the\ncorrectness of the code generator for an idealized language in a\npencil-and-paper argument. We have also implemented prototype code\ngenerators targeting Rust and oCaml. We have carried out case studies\non the code generator with crypto operations, e.g., the AES protocol,\nand a parser interpreter for the Parsing Expression Grammar (PEG)\nformalism. In both cases, the performance of the generated code is\nencouraging (given that the source programs are mathematical\nmodels). In the latter case of the parser interpreter, we also\nperformed a case study on proof robustness by refining the PEG\nformalization in significant ways. We were able to demonstrate that\nproofs remained robustly replayable in spite of these modifications\nlargely due to the careful and judicious combination of automation and\nmanual guidance supported by PVS. We have also implemented a\ntranslator from PVS to the SMT-LIB2 language to integrate other SMT\nsolvers (than Yices2) as back- end reasoning tools. Additionally, we\nhave developed a prototype proof recommender system called CoProver to\nassist users with proof steps and lemma selections by training\nsuitable machine learning models for these tasks.\n\nAnother significant activity has been the development of\nconflict-directed satisfiability algorithms. The conflict-directed\nstrategy for constraint solving is one where nontrivial reasoning is\nonly performed when the assignments to variables are in conflict with\nthe constraints. Conflict-driven reasoning is used to extract a\nconcise explanation in the form of a conflict clause that redirects\nthe search for a satisfying assignment. The CDCL algorithm for Boolean\nsatisfiability is an example of a conflict-directed search\nalgorithm. The MCSAT algorithm approaches theory solving in a similar\nmanner. With the CDSAT algorithm, we have defined a technique that\nworks across a combination of theories. This has also led to novel\nways of handling quantified constraints.\t\t\t\t\tLast Modified: 01/31/2024\n\n\t\t\t\t\tSubmitted by: NatarajanShankar\n"
 }
}