{
 "awd_id": "2130671",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SaTC: CORE: Small: Scaling Correct-by-Construction Code Generation for Cryptography",
 "cfda_num": "47.070",
 "org_code": "05050000",
 "po_phone": "7032927841",
 "po_email": "sgreensp@nsf.gov",
 "po_sign_block_name": "Sol Greenspan",
 "awd_eff_date": "2022-02-15",
 "awd_exp_date": "2025-01-31",
 "tot_intn_awd_amt": 500000.0,
 "awd_amount": 516000.0,
 "awd_min_amd_letter_date": "2022-02-09",
 "awd_max_amd_letter_date": "2022-06-30",
 "awd_abstract_narration": "Cryptography secures communication in many parts of the modern world, from online shopping to private text messaging.  Bugs in cryptographic software lead to information leakage and opportunities for bad actors to have undue influence on computer systems.  Prior work by this research team began the Fiat Cryptography project, which generates fast and secure cryptographic code for intricate arithmetic algorithms, which previously had been painstakingly handcoded by experts.  The new code-generation method has a rigorous mathematical proof of correctness (in a theorem-proving software package called Coq), which contrasts with the fallibility of the humans who had written similar code before.  Today that tooling is used by all major web browsers.  This project develops extensions to allow for even more real-world adoption, by covering more kinds of cryptographic code and improving performance and trustworthiness.\r\n\r\nThe planned work has two main thrusts: expanding scope to higher-level code and lowering the system's guarantees to assembly instead of C.  The first thrust involves moving beyond Fiat Cryptography's original specialization to straightline code, adding support for loops, function calls, precomputed tables, and mutable data structures.  The intent is to retain the quality of starting from whiteboard-level purely functional programs and deriving fast imperative code from them automatically.  However, recognizing the likely lack of a \"one-size-fits-all\" approach for such a wider range of programs, an extensible proof-generating compiler will be built, to which new code-derivation rules can be added if they are proved in Coq.  The second project thrust studies how formal guarantees may be lowered to assembly code instead of C.  Many important optimizations have been beyond the ability of compilers like GCC to apply automatically, but it is still desirable to establish correctness of those optimizations formally.  To that end, a formally verified equivalence checker will be built, to certify that assembly programs compute the same mathematical functions as C-level programs generated by Fiat Cryptography.  A collaboration with experts in genetic search should allow Fiat Cryptography to retain its push-button nature while still producing performance-competitive assembly code.\r\n\r\nThis award reflects NSF's statutory mission and has been deemed worthy of support through evaluation using the Foundation's intellectual merit and broader impacts review criteria.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CNS",
 "org_div_long_name": "Division Of Computer and Network Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Adam",
   "pi_last_name": "Chlipala",
   "pi_mid_init": "J",
   "pi_sufx_name": "",
   "pi_full_name": "Adam J Chlipala",
   "pi_email_addr": "adamc@csail.mit.edu",
   "nsf_id": "000610723",
   "pi_start_date": "2022-02-09",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Massachusetts Institute of Technology",
  "inst_street_address": "77 MASSACHUSETTS AVE",
  "inst_street_address_2": "",
  "inst_city_name": "CAMBRIDGE",
  "inst_state_code": "MA",
  "inst_state_name": "Massachusetts",
  "inst_phone_num": "6172531000",
  "inst_zip_code": "021394301",
  "inst_country_name": "United States",
  "cong_dist_code": "07",
  "st_cong_dist_code": "MA07",
  "org_lgl_bus_name": "MASSACHUSETTS INSTITUTE OF TECHNOLOGY",
  "org_prnt_uei_num": "E2NYLCDML6V1",
  "org_uei_num": "E2NYLCDML6V1"
 },
 "perf_inst": {
  "perf_inst_name": "Massachusetts Institute of Technology",
  "perf_str_addr": "77 MASSACHUSETTS AVE",
  "perf_city_name": "Cambridge",
  "perf_st_code": "MA",
  "perf_st_name": "Massachusetts",
  "perf_zip_code": "021394301",
  "perf_ctry_code": "US",
  "perf_cong_dist": "07",
  "perf_st_cong_dist": "MA07",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "806000",
   "pgm_ele_name": "Secure &Trustworthy Cyberspace"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "025Z",
   "pgm_ref_txt": "SaTC: Secure and Trustworthy Cyberspace"
  },
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "9178",
   "pgm_ref_txt": "UNDERGRADUATE EDUCATION"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  }
 ],
 "app_fund": [
  {
   "app_code": "",
   "app_name": "",
   "app_symb_id": "",
   "fund_code": "01002223DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2022,
   "fund_oblg_amt": 516000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>This project extended the Fiat Cryptography tooling, an automatic code generator for the performance-critical parts of cryptographic software, where the generator itself has a machine-checked mathematical proof of correctness.&nbsp; The prior work only generated straightline code, while a new system Rupicola was developed that is able to derive more involved programs from their functional specifications.&nbsp; Rupicola and other tools were used to carry out a case study of a complete software stack that runs directly on a RISC-V commercial microcontroller, implementing a simple cryptographic protocol, with a machine-checked correctness proof from first principles.&nbsp; This line of work demonstrated the deepest coverage of formal guarantees across cryptographic software to date.<br /><br />Another direction (in collaboration with researchers at other institutions) improved performance without sacrificing strength of mathematical guarantees.&nbsp; The CryptOpt system is a new Fiat Cryptography backend producing x86 assembly instead of C.&nbsp; It uses random search to modify assembly programs, benchmark them, and remember which variants ran most quickly.&nbsp; Crucially, the final variant selected is fed to our new program-equivalence checker, which itself has a machine-checked correctness proof.&nbsp; As a result, despite use of heuristic methods, the mathematical guarantee of correct compilation only becomes stronger, since now no C compiler needs to be trusted.&nbsp; CryptOpt set some new performance records for particular common elliptic curves on the latest Intel processors.&nbsp; It was also adopted by Google to improve the performance of popular curve P-256 by about 50% in their BoringSSL library.&nbsp; This subproject won a number of prizes, including a \"Humies\" Gold Award (from the genetic-algorithms community) and the German IT Security Award.<br /><br />The last published result of the project introduces an approach to proving that compilers preserve cryptographic constant time, the gold standard for lack of vulnerability to attacks based on timing side channels.&nbsp; This last result shows how to extend such definitions and methods to programs that are nondeterministic, for instance due to input-output or use of unpredictable memory allocators.</p><br>\n<p>\n Last Modified: 04/22/2025<br>\nModified by: Adam&nbsp;J&nbsp;Chlipala</p></div>\n<div class=\"porSideCol\"\n></div>\n</div>\n",
  "por_txt_cntn": "\n\nThis project extended the Fiat Cryptography tooling, an automatic code generator for the performance-critical parts of cryptographic software, where the generator itself has a machine-checked mathematical proof of correctness. The prior work only generated straightline code, while a new system Rupicola was developed that is able to derive more involved programs from their functional specifications. Rupicola and other tools were used to carry out a case study of a complete software stack that runs directly on a RISC-V commercial microcontroller, implementing a simple cryptographic protocol, with a machine-checked correctness proof from first principles. This line of work demonstrated the deepest coverage of formal guarantees across cryptographic software to date.\n\nAnother direction (in collaboration with researchers at other institutions) improved performance without sacrificing strength of mathematical guarantees. The CryptOpt system is a new Fiat Cryptography backend producing x86 assembly instead of C. It uses random search to modify assembly programs, benchmark them, and remember which variants ran most quickly. Crucially, the final variant selected is fed to our new program-equivalence checker, which itself has a machine-checked correctness proof. As a result, despite use of heuristic methods, the mathematical guarantee of correct compilation only becomes stronger, since now no C compiler needs to be trusted. CryptOpt set some new performance records for particular common elliptic curves on the latest Intel processors. It was also adopted by Google to improve the performance of popular curve P-256 by about 50% in their BoringSSL library. This subproject won a number of prizes, including a \"Humies\" Gold Award (from the genetic-algorithms community) and the German IT Security Award.\n\nThe last published result of the project introduces an approach to proving that compilers preserve cryptographic constant time, the gold standard for lack of vulnerability to attacks based on timing side channels. This last result shows how to extend such definitions and methods to programs that are nondeterministic, for instance due to input-output or use of unpredictable memory allocators.\t\t\t\t\tLast Modified: 04/22/2025\n\n\t\t\t\t\tSubmitted by: AdamJChlipala\n"
 }
}