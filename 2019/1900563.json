{
 "awd_id": "1900563",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Medium: Collab Research: Synthesizing Verified Analyzers for Critical Software",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927885",
 "po_email": "abanerje@nsf.gov",
 "po_sign_block_name": "Anindya Banerjee",
 "awd_eff_date": "2019-10-01",
 "awd_exp_date": "2023-09-30",
 "tot_intn_awd_amt": 598039.0,
 "awd_amount": 598039.0,
 "awd_min_amd_letter_date": "2019-08-21",
 "awd_max_amd_letter_date": "2019-08-21",
 "awd_abstract_narration": "The reliability of a complete software system hinges on the reliability of each tool used to construct it. Among these tools are program analyzers which are automated tools for verifying the absence of specific classes of errors such as unsafe memory accesses. While used both for program optimization by compilers, and for eliminating software defects by software developers, program analyzers by themselves are not verified: their reliability is largely assumed and, in current practice, they inhabit a software's trusted computing base. This project develops (a) foundational theories for synthesizing program analyzers directly from their specifications; (b) practical implementations of program analyzers; and (c) rigorous evaluations of both foundational techniques as well as implementations via a mixture of formal methods, software development, and empirical case studies. Underlying these results is the potential for widespread adoption of these tools in practice thus leading to higher reliability of software more generally.\r\n\r\nThe project's techniques and tools will enable the deductive synthesis of sound program analysers in proof assistants in an interactive, mostly-automated style, and using the calculational framework of abstract interpretation with Galois connections. The investigators evaluate this approach by first comparing to existing tools: Fiat, an existing tool for semi-automated deductive synthesis in the theorem prover Coq but which does not support Galois connections, and Constructive Galois Connections, an existing framework for embedding Galois connections in Agda language but which does not support automation. The investigators compare these results with existing on-paper derivations of correct-by-construction program analyzers, as well as existing information flow analyzers which were not derived using the abstract interpretation framework.\r\n\r\nThis award reflects NSF's statutory mission and has been deemed worthy of support through evaluation using the Foundation's intellectual merit and broader impacts review criteria.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "David",
   "pi_last_name": "Van Horn",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "David Van Horn",
   "pi_email_addr": "dvanhorn@cs.umd.edu",
   "nsf_id": "000572933",
   "pi_start_date": "2019-08-21",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Maryland, College Park",
  "inst_street_address": "3112 LEE BUILDING",
  "inst_street_address_2": "",
  "inst_city_name": "COLLEGE PARK",
  "inst_state_code": "MD",
  "inst_state_name": "Maryland",
  "inst_phone_num": "3014056269",
  "inst_zip_code": "207425100",
  "inst_country_name": "United States",
  "cong_dist_code": "04",
  "st_cong_dist_code": "MD04",
  "org_lgl_bus_name": "UNIVERSITY OF MARYLAND, COLLEGE PARK",
  "org_prnt_uei_num": "NPU8ULVAAS23",
  "org_uei_num": "NPU8ULVAAS23"
 },
 "perf_inst": {
  "perf_inst_name": "University of Maryland College Park",
  "perf_str_addr": "",
  "perf_city_name": "",
  "perf_st_code": "MD",
  "perf_st_name": "Maryland",
  "perf_zip_code": "207425141",
  "perf_ctry_code": "US",
  "perf_cong_dist": "04",
  "perf_st_cong_dist": "MD04",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "287800",
   "pgm_ele_name": "Special Projects - CCF"
  },
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "2878",
   "pgm_ref_txt": "SPECIAL PROJECTS - CCF"
  },
  {
   "pgm_ref_code": "7924",
   "pgm_ref_txt": "MEDIUM PROJECT"
  },
  {
   "pgm_ref_code": "7943",
   "pgm_ref_txt": "PROGRAMMING LANGUAGES"
  },
  {
   "pgm_ref_code": "8206",
   "pgm_ref_txt": "Formal Methods and Verification"
  }
 ],
 "app_fund": [
  {
   "app_code": "0119",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001920DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2019,
   "fund_oblg_amt": 598039.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p><span id=\"docs-internal-guid-a36fe839-7fff-1a94-0c52-cbc6a5bbea11\">\n<p dir=\"ltr\"><span>This project was conceived to address a clear gap in the way programmers approach the development of high-assurance systems: while programmers may use advanced program analysis tools to identify bugs or certify their absence, these tools were themselves difficult to develop and, as a result, were themselves often buggy. The purpose of this project was thus to apply program verification techniques (including formal verification and deductive synthesis) to program analysis tools. To do this would require many intermediate goals, including developing complex static analysis tools, identifying methods of specifying their behavior, extending existing metatheory to support features like quantitative analysis, and finally certifying those complex program analyses&rsquo; correctness.</span></p>\n<br />\n<p dir=\"ltr\"><span>Intellectual Merit:</span></p>\n<br />\n<p dir=\"ltr\"><span>This project successfully developed novel combinations of program synthesis from specification and program analysis. In this combination, a specification is described at a high level via, for example, the types and effects of program fragment, along with descriptions of abstract properties that are expected to be useful to the synthesizer. These abstract properties provide two benefits: speeding up the synthesis itself as well as allowing the synthesizer to apply to complex languages (such as Ruby or Python) where consideration of the full language semantics would lead to too large and complex a search space. Additionally, the project&rsquo;s investigation of quantitative analyses such as differential privacy and floating-point accuracy have developed new methodologies to address these in type systems and program analyses. Results were published in a variety of venues, including </span><span>TPDP, FCS, CSF, CCS, OOPSLA, and PLDI.</span></p>\n<br />\n<p dir=\"ltr\"><span>Broader Impacts:</span></p>\n<br />\n<p dir=\"ltr\"><span>Several tools developed as part of this project are now available to open source. Most prominently, the RbSyn (Ruby Synthesis) project incorporates all of the major advances in program synthesis, including the handling of both types and effects and the use of abstract interpretation to reduce the search space. Moreover, RbSyn and derivative tools such as Absynth have proven themselves in a variety of real-world use cases such as synthesizing data science transformations. The fact that RbSyn can abstract away from concrete language syntax means it should make it easier to transfer data science analysis and other code between languages and frameworks, lowering the amount of duplicated effort. Moreover, the work on quantitative properties has led to a variety of improvements in floating-point error analysis, some of which are now being included into the Herbie project. Reducing floating-point error improves the reliability and reproducibility of software and allows digital design and analysis techniques that reduce the cost of design and engineering of complex projects.</span></p>\n<div><span><br /></span></div>\n</span></p>\n<p>&nbsp;</p><br>\n<p>\n Last Modified: 04/24/2024<br>\nModified by: David&nbsp;Van Horn</p></div>\n<div class=\"porSideCol\"\n></div>\n</div>\n",
  "por_txt_cntn": "\n\n\n\n\nThis project was conceived to address a clear gap in the way programmers approach the development of high-assurance systems: while programmers may use advanced program analysis tools to identify bugs or certify their absence, these tools were themselves difficult to develop and, as a result, were themselves often buggy. The purpose of this project was thus to apply program verification techniques (including formal verification and deductive synthesis) to program analysis tools. To do this would require many intermediate goals, including developing complex static analysis tools, identifying methods of specifying their behavior, extending existing metatheory to support features like quantitative analysis, and finally certifying those complex program analyses correctness.\n\n\n\n\nIntellectual Merit:\n\n\n\n\nThis project successfully developed novel combinations of program synthesis from specification and program analysis. In this combination, a specification is described at a high level via, for example, the types and effects of program fragment, along with descriptions of abstract properties that are expected to be useful to the synthesizer. These abstract properties provide two benefits: speeding up the synthesis itself as well as allowing the synthesizer to apply to complex languages (such as Ruby or Python) where consideration of the full language semantics would lead to too large and complex a search space. Additionally, the projects investigation of quantitative analyses such as differential privacy and floating-point accuracy have developed new methodologies to address these in type systems and program analyses. Results were published in a variety of venues, including TPDP, FCS, CSF, CCS, OOPSLA, and PLDI.\n\n\n\n\nBroader Impacts:\n\n\n\n\nSeveral tools developed as part of this project are now available to open source. Most prominently, the RbSyn (Ruby Synthesis) project incorporates all of the major advances in program synthesis, including the handling of both types and effects and the use of abstract interpretation to reduce the search space. Moreover, RbSyn and derivative tools such as Absynth have proven themselves in a variety of real-world use cases such as synthesizing data science transformations. The fact that RbSyn can abstract away from concrete language syntax means it should make it easier to transfer data science analysis and other code between languages and frameworks, lowering the amount of duplicated effort. Moreover, the work on quantitative properties has led to a variety of improvements in floating-point error analysis, some of which are now being included into the Herbie project. Reducing floating-point error improves the reliability and reproducibility of software and allows digital design and analysis techniques that reduce the cost of design and engineering of complex projects.\n\n\n\n\n\n\t\t\t\t\tLast Modified: 04/24/2024\n\n\t\t\t\t\tSubmitted by: DavidVan Horn\n"
 }
}