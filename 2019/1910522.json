{
 "awd_id": "1910522",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Small: Collaborative Research: Foundations for Gradual Typing",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927885",
 "po_email": "abanerje@nsf.gov",
 "po_sign_block_name": "Anindya Banerjee",
 "awd_eff_date": "2019-10-01",
 "awd_exp_date": "2022-09-30",
 "tot_intn_awd_amt": 249995.0,
 "awd_amount": 249995.0,
 "awd_min_amd_letter_date": "2019-06-14",
 "awd_max_amd_letter_date": "2019-06-14",
 "awd_abstract_narration": "Type-safe programming languages report errors when a program applies operations to data of the wrong type---e.g., a list-length operation expects a list, not a number---and they come in two flavors: dynamically typed (or untyped) languages, which catch such type errors at run time, and statically typed languages, which catch type errors at compile time before the program is ever run.  Dynamically typed languages are well suited for rapid prototyping of software, while static typing becomes important as software systems grow since it offers improved maintainability, code documentation, early error detection, and support for compilation to faster code.  Gradually typed languages bring together these benefits, allowing dynamically typed and statically typed code---and more generally, less precisely and more precisely typed code---to coexist and interoperate, thus allowing programmers to slowly evolve parts of their code base from less precisely typed to more precisely typed.  To ensure safe interoperability, gradual languages insert runtime checks when data with a less precise type is cast to a more precise type. Gradual typing has seen high adoption in industry, in languages like TypeScript, Hack, Flow, and C#.  Unfortunately, current gradually typed languages fall short in three ways. First, while normal static typing provides reasoning principles that enable safe program transformations and optimizations, naive gradual systems often do not. Second, gradual languages rarely guarantee graduality, a reasoning principle helpful to programmers, which says that making types more precise in a program merely adds in checks and the program otherwise behaves as before. Third, time and space efficiency of the runtime casts inserted by gradual languages remains a concern.  This project addresses all three of these issues.  The project's novelties include: (1) a new approach to the design of gradual languages by first codifying the desired reasoning principles for the language using a program logic called Gradual Type Theory (GTT), and from that deriving the behavior of runtime casts; (2) compiling to a non-gradual compiler intermediate representation (IR) in a way that preserves these principles; and (3) the ability to use GTT to reason about the correctness of optimizations and efficient implementation of casts. The project has the potential for significant impact on industrial software development since gradually typed languages provide a migration path from existing dynamically typed codebases to more maintainable statically typed code, and from traditional static types to more precise types, providing a mechanism for increased adoption of advanced type features.  The project will also have impact by providing infrastructure for future language designs and investigations into improving the performance of gradual typing.\r\n\r\nThe project team will apply the GTT approach to investigate gradual typing for polymorphism with data abstraction (parametricity), algebraic effects and handlers, and refinement/dependent types.  For each, the team will develop cast calculi and program logics expressing better equational reasoning principles than previous proposals, with certified elaboration to a compiler intermediate language based on Call-By-Push-Value (CBPV) while preserving these properties, and design convenient surface languages that elaborate into them.  The GTT program logics will be used for program verification, proving the correctness of program optimizations and refactorings.\r\n\r\nThis award reflects NSF's statutory mission and has been deemed worthy of support through evaluation using the Foundation's intellectual merit and broader impacts review criteria.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Amal",
   "pi_last_name": "Ahmed",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Amal Ahmed",
   "pi_email_addr": "amal@ccs.neu.edu",
   "nsf_id": "000573498",
   "pi_start_date": "2019-06-14",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Northeastern University",
  "inst_street_address": "360 HUNTINGTON AVE",
  "inst_street_address_2": "",
  "inst_city_name": "BOSTON",
  "inst_state_code": "MA",
  "inst_state_name": "Massachusetts",
  "inst_phone_num": "6173735600",
  "inst_zip_code": "021155005",
  "inst_country_name": "United States",
  "cong_dist_code": "07",
  "st_cong_dist_code": "MA07",
  "org_lgl_bus_name": "NORTHEASTERN UNIVERSITY",
  "org_prnt_uei_num": "",
  "org_uei_num": "HLTMVS2JZBS6"
 },
 "perf_inst": {
  "perf_inst_name": "Northeastern University",
  "perf_str_addr": "360 Huntington Ave",
  "perf_city_name": "Boston",
  "perf_st_code": "MA",
  "perf_st_name": "Massachusetts",
  "perf_zip_code": "021155005",
  "perf_ctry_code": "US",
  "perf_cong_dist": "07",
  "perf_st_cong_dist": "MA07",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7943",
   "pgm_ref_txt": "PROGRAMMING LANGUAGES"
  },
  {
   "pgm_ref_code": "9102",
   "pgm_ref_txt": "WOMEN, MINORITY, DISABLED, NEC"
  }
 ],
 "app_fund": [
  {
   "app_code": "0119",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001920DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2019,
   "fund_oblg_amt": 249995.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Gradual typing allows safe interoperability between more and less preciselytyped code by inserting runtime type casts when properties are not known atcompile-time---i.e., enforcing types statically when possible and dynamicallywhen necessary. Considerable recent research has investigated extensions ofgradual typing to more advanced static features, such as parametricpolymorphism, effect typing, and refinement/dependent types. &nbsp;However, while thestatic type systems provide strong reasoning principles that enable programmersand compilers to make safe program transformations and optimizations, naivegradual systems often break these principles.</p>\n<p>This project seeks to apply an axiomatic approach to the design of graduallytyped languages, where a program logic (Gradual Type Theory, or GTT) codifiesthe desired equational reasoning principles for a gradually typed language andis used to determine the behavior of runtime type casts. GTT can be compiled ina way that preserves these principles, making it possible to to reason about thecorrectness of optimizations and efficient implementation of casts. &nbsp;</p>\n<p>The first major result of this project pertains to an open problem in polymorphic gradual typing. We refuted a recent claim that a polymorphic gradual language cannot simultaneously satisfy two desired criteria for such a language: parametricity (information hiding) and the gradual guarantee or graduality (which says that adding more precise type annotations to code can only produce more errors). We showed that it is, in fact, possible to design a polymorphic gradual language that satisfies both critical properties, parametricity and graduality. &nbsp;We took a novel approach, using desired equalities (which included axioms for graduality and parametricity) to guide the language design. &nbsp;This resulted in a syntactic form for existential types that closely resembles Haskell's newtype construct, and syntax for polymorphism that's quite different from the standard polymorphic lambda calculus. &nbsp;We showed how to translate our surface gradual language to a target where checks are inserted. &nbsp;We proved graduality &nbsp;and then showed that parametricity follows as a corollary of graduality.</p>\n<p>The second major outcome of this project is the design of a simple language, GrEff, for gradual effect handlers. with a corresponding embedding-projection pair semantics. Algebraic effect handlers are a generalization of exceptions that give a more structured view of continuations and have been an active area of research in functional language design. GrEff supports the gradual migration from *unchecked* to *checked* effect handlers, i.e. from a static type system where function types do not keep track of which effects are performed to one that uses a type and effect system. This is a generalization of the quite common language design choice between checked and unchecked exceptions.</p>\n<p>The third major result of the project is a new property for gradually typed languages called Vigilance. While all gradual languages allow programmers to add type annotations to enforce precise types on values produced by code with imprecise type annotations, different gradual languages dynamically check the same types using different runtime semantics for type casts. This raises the question of whether the type annotations developers add to their code are indeed enforced, either statically or dynamically. We developed a new property called type vigilance, a semantic property that ensures developers can rely on type annotations in a gradually typed language, by requiring the semantics of the gradual language to supplement static checks with explicit type casts that perform sufficient checks. Technically, vigilance asks if a semantics enforces the complete run-time typing history of a value, which consists of all the types that casts should enforce on the value at run time. We apply vigilance to existing gradual semantics, Natural and Transient: we show the the Natural semantics is vigilant for a simple type system, but Transient is not; while Transient is vigilant for a tag type system that tracks only the top-level tag of each type (e.g., Integer, Function, Pair). Using vigilance as a guide, we develop a new gradual type system for Transient, dubbed Truer Transient, that is stronger than tag typing and more faithfully reflects the type-level reasoning power guaranteed by Transient's operational semantics. &nbsp;Vigilance is thus a useful tool designers can use to ensure that the type annotation language is of a precision that is actually enforced.&nbsp;</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 07/31/2023<br>\n\t\t\t\t\tModified by: Amal&nbsp;Ahmed</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nGradual typing allows safe interoperability between more and less preciselytyped code by inserting runtime type casts when properties are not known atcompile-time---i.e., enforcing types statically when possible and dynamicallywhen necessary. Considerable recent research has investigated extensions ofgradual typing to more advanced static features, such as parametricpolymorphism, effect typing, and refinement/dependent types.  However, while thestatic type systems provide strong reasoning principles that enable programmersand compilers to make safe program transformations and optimizations, naivegradual systems often break these principles.\n\nThis project seeks to apply an axiomatic approach to the design of graduallytyped languages, where a program logic (Gradual Type Theory, or GTT) codifiesthe desired equational reasoning principles for a gradually typed language andis used to determine the behavior of runtime type casts. GTT can be compiled ina way that preserves these principles, making it possible to to reason about thecorrectness of optimizations and efficient implementation of casts.  \n\nThe first major result of this project pertains to an open problem in polymorphic gradual typing. We refuted a recent claim that a polymorphic gradual language cannot simultaneously satisfy two desired criteria for such a language: parametricity (information hiding) and the gradual guarantee or graduality (which says that adding more precise type annotations to code can only produce more errors). We showed that it is, in fact, possible to design a polymorphic gradual language that satisfies both critical properties, parametricity and graduality.  We took a novel approach, using desired equalities (which included axioms for graduality and parametricity) to guide the language design.  This resulted in a syntactic form for existential types that closely resembles Haskell's newtype construct, and syntax for polymorphism that's quite different from the standard polymorphic lambda calculus.  We showed how to translate our surface gradual language to a target where checks are inserted.  We proved graduality  and then showed that parametricity follows as a corollary of graduality.\n\nThe second major outcome of this project is the design of a simple language, GrEff, for gradual effect handlers. with a corresponding embedding-projection pair semantics. Algebraic effect handlers are a generalization of exceptions that give a more structured view of continuations and have been an active area of research in functional language design. GrEff supports the gradual migration from *unchecked* to *checked* effect handlers, i.e. from a static type system where function types do not keep track of which effects are performed to one that uses a type and effect system. This is a generalization of the quite common language design choice between checked and unchecked exceptions.\n\nThe third major result of the project is a new property for gradually typed languages called Vigilance. While all gradual languages allow programmers to add type annotations to enforce precise types on values produced by code with imprecise type annotations, different gradual languages dynamically check the same types using different runtime semantics for type casts. This raises the question of whether the type annotations developers add to their code are indeed enforced, either statically or dynamically. We developed a new property called type vigilance, a semantic property that ensures developers can rely on type annotations in a gradually typed language, by requiring the semantics of the gradual language to supplement static checks with explicit type casts that perform sufficient checks. Technically, vigilance asks if a semantics enforces the complete run-time typing history of a value, which consists of all the types that casts should enforce on the value at run time. We apply vigilance to existing gradual semantics, Natural and Transient: we show the the Natural semantics is vigilant for a simple type system, but Transient is not; while Transient is vigilant for a tag type system that tracks only the top-level tag of each type (e.g., Integer, Function, Pair). Using vigilance as a guide, we develop a new gradual type system for Transient, dubbed Truer Transient, that is stronger than tag typing and more faithfully reflects the type-level reasoning power guaranteed by Transient's operational semantics.  Vigilance is thus a useful tool designers can use to ensure that the type annotation language is of a precision that is actually enforced. \n\n\t\t\t\t\tLast Modified: 07/31/2023\n\n\t\t\t\t\tSubmitted by: Amal Ahmed"
 }
}