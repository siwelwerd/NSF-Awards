{
 "awd_id": "1901769",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Small: Measurable Program Analysis",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927991",
 "po_email": "namla@nsf.gov",
 "po_sign_block_name": "Nina Amla",
 "awd_eff_date": "2018-08-11",
 "awd_exp_date": "2020-06-30",
 "tot_intn_awd_amt": 219660.0,
 "awd_amount": 227579.0,
 "awd_min_amd_letter_date": "2018-11-01",
 "awd_max_amd_letter_date": "2018-11-01",
 "awd_abstract_narration": "Software is everywhere and its correct operation plays an increasingly important role in the health, productivity, and safety of society and in the lives of individuals.  Consequently, there is a need for techniques that can cost-effectively measure software correctness to establish a well-founded basis for making judgments about whether software is ready for deployment and wide spread use.  The availability of such measures provides an evidentiary basis  for balancing the rewards of using a software system against the risks of its failure.  This type of evidence has the potential to transform the expectations of consumers of software and to enhance their understanding of software behavior and how to place their trust in that behavior.  Evidence of correctness has obvious value for safety critical software, but more broadly it will help shape how society views software as critical infrastructure and the professionalism that it expects of its manufacture.\r\n\r\nThis project blends the outcomes of decades of work on abstraction-based program analysis and symbolic execution with recent results in quantifying the solution space of a logical formula.  The project explores novel combinations and staging of scalable non-quantitative analyses, to identify sub-spaces of program behavior that may be erroneous, followed by quantitative analyses focused on those sub-spaces.  This offers an approach to measurable program analysis (MPA) that promises scalability while yielding safe and accurate results.  The project produces theory and tools that realize a variety of MPA, empirically evaluates the cost and benefit of these analyses, and openly shares all results and artifacts with the research community.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Matthew",
   "pi_last_name": "Dwyer",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Matthew Dwyer",
   "pi_email_addr": "md3cn@virginia.edu",
   "nsf_id": "000103915",
   "pi_start_date": "2018-11-01",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Virginia Main Campus",
  "inst_street_address": "1001 EMMET ST N",
  "inst_street_address_2": "",
  "inst_city_name": "CHARLOTTESVILLE",
  "inst_state_code": "VA",
  "inst_state_name": "Virginia",
  "inst_phone_num": "4349244270",
  "inst_zip_code": "229034833",
  "inst_country_name": "United States",
  "cong_dist_code": "05",
  "st_cong_dist_code": "VA05",
  "org_lgl_bus_name": "RECTOR & VISITORS OF THE UNIVERSITY OF VIRGINIA",
  "org_prnt_uei_num": "",
  "org_uei_num": "JJG6HU8PA4S5"
 },
 "perf_inst": {
  "perf_inst_name": "University of Virginia Main Campus",
  "perf_str_addr": "",
  "perf_city_name": "Charlottesville",
  "perf_st_code": "VA",
  "perf_st_name": "Virginia",
  "perf_zip_code": "229044195",
  "perf_ctry_code": "US",
  "perf_cong_dist": "05",
  "perf_st_cong_dist": "VA05",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "8206",
   "pgm_ref_txt": "Formal Methods and Verification"
  },
  {
   "pgm_ref_code": "9150",
   "pgm_ref_txt": "EXP PROG TO STIM COMP RES"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  }
 ],
 "app_fund": [
  {
   "app_code": "0116",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001617DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0117",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001718DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2016,
   "fund_oblg_amt": 219659.0
  },
  {
   "fund_oblg_fiscal_yr": 2017,
   "fund_oblg_amt": 7920.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Software is at the heart of technology upon which modern society depends.&nbsp;&nbsp; To determine whether software behaves as intended current practice is to test it - to run the software on sample inputs and observe how it performs.&nbsp;&nbsp; This is an important step in assuring software, but it can only demonstrate flaws in software not their absence.&nbsp;&nbsp; In contrast static analysis techniques seek to prove the absence of errors and this has the potential to provide much higher degrees of assurance that software behavior can be trusted.</p>\n<p>Static analysis is generally forced to make a tradeoff between efficiency and accuracy.&nbsp;&nbsp; This project developed a new framework, called alternating conditional analysis (ACA), that can effectively balance these opposing forces.&nbsp; It achieves this by employing a portfolio of algorithmically diverse static analyzers.&nbsp; Each analyzer considers a portion of the software behavior and ACA consolidates that information to formulate a new analysis problem on the portion of the software behavior that remains unanalyzed.&nbsp;&nbsp; This progressively narrows the scope of analysis thereby allowing subsequent application of analyzers to be faster and more accurate.</p>\n<p>ACA has been realized in a toolset called ALPACA that can incorporates more than a dozen underlying analyzers to target programs written in C.&nbsp;&nbsp; ALPACA has, in turn, been applied as a building block to produce state-of-the-art software analyzers that are capable of computing quantitative characterizations of program behavior, e.g., the probability of failure given an input probability distribution.&nbsp; Ongoing work is exploring further applications of the framework to realize new forms of compositional analysis that can scale to large software systems while producing accurate results.</p>\n<p>ACA established a new paradigm in static analysis and the open-source ALPACA toolset allows the broader research community to build on the outcomes of this project to further broaden its impact.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 07/22/2020<br>\n\t\t\t\t\tModified by: Matthew&nbsp;Dwyer</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nSoftware is at the heart of technology upon which modern society depends.   To determine whether software behaves as intended current practice is to test it - to run the software on sample inputs and observe how it performs.   This is an important step in assuring software, but it can only demonstrate flaws in software not their absence.   In contrast static analysis techniques seek to prove the absence of errors and this has the potential to provide much higher degrees of assurance that software behavior can be trusted.\n\nStatic analysis is generally forced to make a tradeoff between efficiency and accuracy.   This project developed a new framework, called alternating conditional analysis (ACA), that can effectively balance these opposing forces.  It achieves this by employing a portfolio of algorithmically diverse static analyzers.  Each analyzer considers a portion of the software behavior and ACA consolidates that information to formulate a new analysis problem on the portion of the software behavior that remains unanalyzed.   This progressively narrows the scope of analysis thereby allowing subsequent application of analyzers to be faster and more accurate.\n\nACA has been realized in a toolset called ALPACA that can incorporates more than a dozen underlying analyzers to target programs written in C.   ALPACA has, in turn, been applied as a building block to produce state-of-the-art software analyzers that are capable of computing quantitative characterizations of program behavior, e.g., the probability of failure given an input probability distribution.  Ongoing work is exploring further applications of the framework to realize new forms of compositional analysis that can scale to large software systems while producing accurate results.\n\nACA established a new paradigm in static analysis and the open-source ALPACA toolset allows the broader research community to build on the outcomes of this project to further broaden its impact.\n\n\t\t\t\t\tLast Modified: 07/22/2020\n\n\t\t\t\t\tSubmitted by: Matthew Dwyer"
 }
}