{
 "awd_id": "1916817",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "CAREER:Cross-Core Learning in Future Manycore Systems",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927885",
 "po_email": "abanerje@nsf.gov",
 "po_sign_block_name": "Anindya Banerjee",
 "awd_eff_date": "2019-01-01",
 "awd_exp_date": "2020-06-30",
 "tot_intn_awd_amt": 126608.0,
 "awd_amount": 126608.0,
 "awd_min_amd_letter_date": "2019-02-11",
 "awd_max_amd_letter_date": "2019-02-11",
 "awd_abstract_narration": "As computing devices solve increasingly complex and diverse problems, engineers seek to design processors that provide higher performance, while remaining energy-efficient for environmental reasons. To achieve this, processor vendors have embraced manycore devices, where thousands of cores cooperate on a single chip to solve large-scale problems in a parallel manner. They have further incorporated heterogeneity, combining cores with different architectures on a single chip in a bid to provide ever-increasing performance per watt. This project boosts the search for higher energy-efficient performance by inventing novel cross-core learning techniques. Cores in current chips individually learn about the behavior of parallel programs in order to run programs more efficiently in the future, devoting complex and power-hungry hardware structures to do this. However, this research observes that parallel programs tend to exercise the hardware structures of different cores in correlated ways, meaning that the behavior of the program run on one core can be communicated to other cores for various performance and power benefits. As such, this form of intelligent cross-core information exchange is effective in achieving high performance per watt across computing domains from datacenters to embedded systems\r\n\r\nIn this light, this research provides techniques to deduce how similarly a parallel program's various threads exercise their cores' hardware structures (looking at a range of different programmer, compiler, and architectural mechanisms to do so). When this is detected, cross-core learning hardware gleans the information that is most useful to exchange to improve performance or power, and then transmits this information among heterogeneous cores using low-overhead hardware/software techniques. This project develops a lightweight runtime software layer to orchestrate this information exchange, relying on dedicated hardware support when necessary. Through developing this framework, cross-core learning is applied to a number of specific cases, ranging from higher-performance manycore cache prefetching and branch prediction, to performance and power-management techniques for interrupts and exceptions in scale-out systems, as well as thread and instruction scheduling.  Furthermore, this project heavily disseminates knowledge on how to design and program large-scale manycore systems (or scale-out systems) by involving students at the graduate, undergraduate, and high-school levels through active research and coursework. Overall, this work impacts the engineering community and broader society by: (1) helping to achieve high-performance, but also energy-efficient and environmentally-friendly computing systems; (2) providing academics and chip designers a design methodology and infrastructure to study manycore design; (3) broadening the participation of underrepresented groups in computer science; (4) educating graduate, undergraduate, and high-school students on parallel programming for manycore systems.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Abhishek",
   "pi_last_name": "Bhattacharjee",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Abhishek Bhattacharjee",
   "pi_email_addr": "abhishek.bhattacharjee@yale.edu",
   "nsf_id": "000580469",
   "pi_start_date": "2019-02-11",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Yale University",
  "inst_street_address": "150 MUNSON ST",
  "inst_street_address_2": "",
  "inst_city_name": "NEW HAVEN",
  "inst_state_code": "CT",
  "inst_state_name": "Connecticut",
  "inst_phone_num": "2037854689",
  "inst_zip_code": "065113572",
  "inst_country_name": "United States",
  "cong_dist_code": "03",
  "st_cong_dist_code": "CT03",
  "org_lgl_bus_name": "YALE UNIV",
  "org_prnt_uei_num": "FL6GV84CKN57",
  "org_uei_num": "FL6GV84CKN57"
 },
 "perf_inst": {
  "perf_inst_name": "Department of Computer Science",
  "perf_str_addr": "51 Prospect Street",
  "perf_city_name": "New Haven",
  "perf_st_code": "CT",
  "perf_st_name": "Connecticut",
  "perf_zip_code": "065118937",
  "perf_ctry_code": "US",
  "perf_cong_dist": "03",
  "perf_st_cong_dist": "CT03",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "1045",
   "pgm_ref_txt": "CAREER-Faculty Erly Career Dev"
  },
  {
   "pgm_ref_code": "7941",
   "pgm_ref_txt": "COMPUTER ARCHITECTURE"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  }
 ],
 "app_fund": [
  {
   "app_code": "0116",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001617DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0117",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001718DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2016,
   "fund_oblg_amt": 24324.0
  },
  {
   "fund_oblg_fiscal_yr": 2017,
   "fund_oblg_amt": 102283.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p class=\"p1\">As Moore's Law and Dennard scaling have waned, the computer systems community has turned away from single-thread performance as a primary means of performance scaling, and has instead embraced multi-core architectures. Today, all major hardware vendors build platforms that integrate multiple cores in dual-, quad-, eight-core formations, even ranging in the tens of cores. Indeed, researchers have already begun actively exploring the challenges of building&nbsp;platforms with hundreds of cores. While this multi- and many-core era offers continued performance scaling, it does require software refactoring to take advantage of the parallel hardware resources. In other words, a single program must be refactored into multiple threads of execution to concurrently extract performance from different cores.</p>\n<p class=\"p1\">This project's goal is to take advantage of the fact that a single program is decomposed into multiple threads, so that information gleaned by a single core about a thread of the program can be used to infer execution properties of other threads of the same program running on other cores. These cross-core learning techniques can then be used to accelerate performance of the overall system.<span>&nbsp;</span>&nbsp;</p>\n<p class=\"p1\">Over the lifetime of this project, several opportunities for cross-core learning were investigated and leveraged for performance improvement. Most of these cross-core learning opportunities focused on hardware optimizations, but some of them also focused on operating system improvements. Moreover, the majority of techniques focused on the address translation stack of modern server systems. Address translation is vital to supporting modern virtual memory abstractions, but has become a significant performance, power, and area consumer, especially with the advent of big-data workloads that use ever-increasing memory footprints with increasingly poor locality of reference. Via this project, we present several innovations that contribute to better address translation efficiency, as measured along a number of these metrics. A running theme through these techniques is that cross-core learning is leveraged so that performance is improved not just on a single core, but also on other cores in the same socket and across sockets. And looking forward, although we focus on single platforms, we believe that these techniques can be extended to enable cross-server learning in order to improve the performance of large-scale data centers.</p>\n<p class=\"p1\">Beyond the technical content of this work, this project has also led to the education of several generations of PhD and MS students, as well as undergraduates and even high-school students. Relevant training has been offered via research projects, theses, and course work at the graduate and undergraduate levels.<span>&nbsp;</span></p><br>\n<p>\n\t\t\t\t      \tLast Modified: 01/11/2021<br>\n\t\t\t\t\tModified by: Abhishek&nbsp;Bhattacharjee</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "As Moore's Law and Dennard scaling have waned, the computer systems community has turned away from single-thread performance as a primary means of performance scaling, and has instead embraced multi-core architectures. Today, all major hardware vendors build platforms that integrate multiple cores in dual-, quad-, eight-core formations, even ranging in the tens of cores. Indeed, researchers have already begun actively exploring the challenges of building platforms with hundreds of cores. While this multi- and many-core era offers continued performance scaling, it does require software refactoring to take advantage of the parallel hardware resources. In other words, a single program must be refactored into multiple threads of execution to concurrently extract performance from different cores.\nThis project's goal is to take advantage of the fact that a single program is decomposed into multiple threads, so that information gleaned by a single core about a thread of the program can be used to infer execution properties of other threads of the same program running on other cores. These cross-core learning techniques can then be used to accelerate performance of the overall system.  \nOver the lifetime of this project, several opportunities for cross-core learning were investigated and leveraged for performance improvement. Most of these cross-core learning opportunities focused on hardware optimizations, but some of them also focused on operating system improvements. Moreover, the majority of techniques focused on the address translation stack of modern server systems. Address translation is vital to supporting modern virtual memory abstractions, but has become a significant performance, power, and area consumer, especially with the advent of big-data workloads that use ever-increasing memory footprints with increasingly poor locality of reference. Via this project, we present several innovations that contribute to better address translation efficiency, as measured along a number of these metrics. A running theme through these techniques is that cross-core learning is leveraged so that performance is improved not just on a single core, but also on other cores in the same socket and across sockets. And looking forward, although we focus on single platforms, we believe that these techniques can be extended to enable cross-server learning in order to improve the performance of large-scale data centers.\nBeyond the technical content of this work, this project has also led to the education of several generations of PhD and MS students, as well as undergraduates and even high-school students. Relevant training has been offered via research projects, theses, and course work at the graduate and undergraduate levels. \n\n\t\t\t\t\tLast Modified: 01/11/2021\n\n\t\t\t\t\tSubmitted by: Abhishek Bhattacharjee"
 }
}