{
 "awd_id": "1907727",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Small: Testing and Profiling Asynchronous Software",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927841",
 "po_email": "sgreensp@nsf.gov",
 "po_sign_block_name": "Sol Greenspan",
 "awd_eff_date": "2019-10-01",
 "awd_exp_date": "2023-09-30",
 "tot_intn_awd_amt": 499828.0,
 "awd_amount": 507828.0,
 "awd_min_amd_letter_date": "2019-07-03",
 "awd_max_amd_letter_date": "2021-05-19",
 "awd_abstract_narration": "Asynchronous programming is an increasingly popular programming paradigm that targets scenarios where actions need to be performed in response to events. Typical examples of such scenarios include user input being entered in the graphical user interface of a web application, or messages arriving via network connections in a server application. In such scenarios, is undesirable for program execution to block until an event arrives. Event-driven programming is widely used to accommodate asynchrony, and involves structuring an application as a collection of event handlers that are executed in response to detected events. However, recent years have seen the introduction, and broad adoption, of more advanced programming-language features for asynchronous programming. These features are complex, and lack of familiarity with their use may lead to asynchronous software that is insufficiently well-tested, and that may exhibit poor performance. Existing techniques for testing and performance analysis do not work well for asynchronous applications. The main goal of this project is the development of practical algorithms and tools for testing and profiling asynchronous software. The project's broader significance and importance follows from improvements in the quality of asynchronous software that are enabled by the developed algorithms and tools.\r\n\r\nThe technical focus of this project is on the development of techniques for testing and profiling asynchronous software. This includes the design, implementation, and evaluation of feedback-directed random-testing techniques for event-driven asynchronous applications. In addition, the research includes the establishment of coverage criteria for promise-based asynchronous software and the development of techniques for systematically exploring the execution paths in such programs with the objective of maximizing coverage. The project also includes the design, implementation, and evaluation of profiling tools for detecting situations where suboptimal scheduling of asynchronous computations causes performance degradation.  The research targets software written in the JavaScript programming language, a setting where asynchronous programming is practiced out of necessity due to the absence of concurrency at the language level. Together, the developed techniques facilitate the development of more reliable and efficient asynchronous software, by providing programmers with suitable tools for testing and detecting performance bottlenecks.\r\n\r\nThis award reflects NSF's statutory mission and has been deemed worthy of support through evaluation using the Foundation's intellectual merit and broader impacts review criteria.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Frank",
   "pi_last_name": "Tip",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Frank Tip",
   "pi_email_addr": "f.tip@northeastern.edu",
   "nsf_id": "000129422",
   "pi_start_date": "2019-07-03",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Northeastern University",
  "inst_street_address": "360 HUNTINGTON AVE",
  "inst_street_address_2": "",
  "inst_city_name": "BOSTON",
  "inst_state_code": "MA",
  "inst_state_name": "Massachusetts",
  "inst_phone_num": "6173735600",
  "inst_zip_code": "021155005",
  "inst_country_name": "United States",
  "cong_dist_code": "07",
  "st_cong_dist_code": "MA07",
  "org_lgl_bus_name": "NORTHEASTERN UNIVERSITY",
  "org_prnt_uei_num": "",
  "org_uei_num": "HLTMVS2JZBS6"
 },
 "perf_inst": {
  "perf_inst_name": "Northeastern University",
  "perf_str_addr": "360 Huntington Ave",
  "perf_city_name": "Boston",
  "perf_st_code": "MA",
  "perf_st_name": "Massachusetts",
  "perf_zip_code": "021155005",
  "perf_ctry_code": "US",
  "perf_cong_dist": "07",
  "perf_st_cong_dist": "MA07",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7944",
   "pgm_ref_txt": "SOFTWARE ENG & FORMAL METHODS"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  }
 ],
 "app_fund": [
  {
   "app_code": "0119",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001920DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0121",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01002122DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2019,
   "fund_oblg_amt": 499828.0
  },
  {
   "fund_oblg_fiscal_yr": 2021,
   "fund_oblg_amt": 8000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p class=\"p1\">Asynchronous programming is an increasingly popular programming paradigm that targets scenarios where actions need to be performed in response to events. Typical examples of such scenarios include user input being entered in the graphical user interface of a web application, or messages arriving via network connections in a server application. In such scenarios, is undesirable for execution to block until an event arrives, as it would render the application unresponsive, resulting in a degraded user experience. To avoid this, programming languages support various features to support asynchrony. Traditionally, asynchrony was supported by structuring an application as a collection of event handlers that are executed in response to designated events. However, event-driven programming leads to code that is error-prone and difficult to understand, and it does not provide good support for error handling. To address this, programming languages have adopted new features in recent years, such as promises, futures, and async/await, that provide improved support for asynchrony. However, these features are complex and still unfamiliar to many programmers, leading to code with bugs and suboptimal performance characteristics. This research project studied the development of tools and techniques for improving the quality and performance of asynchronous code.</p>\n<p class=\"p1\">This project focused on the development of practical algorithms and tools for testing and profiling asynchronous applications. As part of this project, algorithms were developed for generating tests for event-driven applications in which the results observed when executing generated tests was used to direct the generation of additional tests in a feedback-directed manner. The developed algorithms were incorporated in LambdaTester and Nessie, two practical test generation tools for JavaScript, which outperformed previous test generation techniques in terms of the amount of code executed by generated tests.</p>\n<p class=\"p1\">Another contribution of this project was the development of code coverage criteria for applications that use promises and async/await. These criteria are defined as metrics that reflect to what extent an application's test suite exercises various key events in the lifetime of promises. These metrics were carefully defined to take into account how asynchronous activities may depend on other asynchronous activities and also reflect to what extent such dependences are tested.</p>\n<p class=\"p1\">The project also involved the development of several practical tools for finding and remediating performance bottlenecks in asynchronous software. One effort in this category was the classification of a number of anti-patterns in promise-based asynchronous JavaScript code that result in suboptimal performance. This included a tool named DrAsync, which reports these anti-patterns and also creates a visualization of the lifetimes of promises created by an asynchronous JavaScript application, which helps developers identify performance bottlenecks. Another tool, named Reformulator identifies situations where an application interacts with a database in a way that results in the creation of unnecessary queries and produces suggestions how the code can be refactored to generated fewer queries, resulting in improved performance. Another tool, named Stubbifier, was developed to identify situations where code of server-side JavaScript applications can be restructured to avoid loading parts of applications that are likely to be unused. A tool called Lazifier targets a similar scenario in browser-based JavaScript software and provides suggestions for how to restructure such applications to defer the loading of code that is unnecessary upon start-up of the application for improved responsiveness.</p>\n<p class=\"p1\">The results of this research have been published in premier publication venues in the areas of Programming Languages and Software&nbsp;Engineering and&nbsp;all tools developed in the context of this project have been made available to the public as open-source software. In Summer 2023, two students successfully defended PhD theses that were based on publications associated with this project.</p>\n<p class=\"p1\">&nbsp;</p>\n<p class=\"p1\">&nbsp;</p>\n<p class=\"p1\">&nbsp;</p>\n<p class=\"p1\">&nbsp;</p>\n<p>&nbsp;</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 10/06/2023<br>\n\t\t\t\t\tModified by: Frank&nbsp;Tip</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "Asynchronous programming is an increasingly popular programming paradigm that targets scenarios where actions need to be performed in response to events. Typical examples of such scenarios include user input being entered in the graphical user interface of a web application, or messages arriving via network connections in a server application. In such scenarios, is undesirable for execution to block until an event arrives, as it would render the application unresponsive, resulting in a degraded user experience. To avoid this, programming languages support various features to support asynchrony. Traditionally, asynchrony was supported by structuring an application as a collection of event handlers that are executed in response to designated events. However, event-driven programming leads to code that is error-prone and difficult to understand, and it does not provide good support for error handling. To address this, programming languages have adopted new features in recent years, such as promises, futures, and async/await, that provide improved support for asynchrony. However, these features are complex and still unfamiliar to many programmers, leading to code with bugs and suboptimal performance characteristics. This research project studied the development of tools and techniques for improving the quality and performance of asynchronous code.\nThis project focused on the development of practical algorithms and tools for testing and profiling asynchronous applications. As part of this project, algorithms were developed for generating tests for event-driven applications in which the results observed when executing generated tests was used to direct the generation of additional tests in a feedback-directed manner. The developed algorithms were incorporated in LambdaTester and Nessie, two practical test generation tools for JavaScript, which outperformed previous test generation techniques in terms of the amount of code executed by generated tests.\nAnother contribution of this project was the development of code coverage criteria for applications that use promises and async/await. These criteria are defined as metrics that reflect to what extent an application's test suite exercises various key events in the lifetime of promises. These metrics were carefully defined to take into account how asynchronous activities may depend on other asynchronous activities and also reflect to what extent such dependences are tested.\nThe project also involved the development of several practical tools for finding and remediating performance bottlenecks in asynchronous software. One effort in this category was the classification of a number of anti-patterns in promise-based asynchronous JavaScript code that result in suboptimal performance. This included a tool named DrAsync, which reports these anti-patterns and also creates a visualization of the lifetimes of promises created by an asynchronous JavaScript application, which helps developers identify performance bottlenecks. Another tool, named Reformulator identifies situations where an application interacts with a database in a way that results in the creation of unnecessary queries and produces suggestions how the code can be refactored to generated fewer queries, resulting in improved performance. Another tool, named Stubbifier, was developed to identify situations where code of server-side JavaScript applications can be restructured to avoid loading parts of applications that are likely to be unused. A tool called Lazifier targets a similar scenario in browser-based JavaScript software and provides suggestions for how to restructure such applications to defer the loading of code that is unnecessary upon start-up of the application for improved responsiveness.\nThe results of this research have been published in premier publication venues in the areas of Programming Languages and Software Engineering and all tools developed in the context of this project have been made available to the public as open-source software. In Summer 2023, two students successfully defended PhD theses that were based on publications associated with this project.\n \n \n \n \n\n \n\n\t\t\t\t\tLast Modified: 10/06/2023\n\n\t\t\t\t\tSubmitted by: Frank Tip"
 }
}