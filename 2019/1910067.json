{
 "awd_id": "1910067",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Small: Idiomatic Decompilation.",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927841",
 "po_email": "sgreensp@nsf.gov",
 "po_sign_block_name": "Sol Greenspan",
 "awd_eff_date": "2019-10-01",
 "awd_exp_date": "2023-09-30",
 "tot_intn_awd_amt": 425000.0,
 "awd_amount": 433000.0,
 "awd_min_amd_letter_date": "2019-07-05",
 "awd_max_amd_letter_date": "2023-03-09",
 "awd_abstract_narration": "Experts known as reverse engineers specialize in studying executable programs, which are computer software programs without source code, expressed as low-level machine instructions on a computer. This task is difficult because the process of translating a program to the machine level throws away all of the information provided by high level programming languages like Java or C that are relevant to helping humans understand what the program does.  This project develops analysis and machine learning techniques to augment and transform non-intuitive executable programs into more idiomatic and understandable software code. This work will help professional reverse engineers do their jobs more effectively; these professionals engage in security-critical and economically-critical activities like understanding and responding to malware and viruses, discovering vulnerabilities, and fixing bugs in legacy software systems.\r\n\r\nReverse engineers specialize in reading and understanding a program's behavior from its executable to analyze malware, discover software vulnerabilities, or patch legacy bugs.  Unfortunately, compilers discard considerable information that is key to human understanding: comments, names, user-defined datatypes, and idiomatic structure.  State-of-the-art de-compilation tools produce code that is largely not idiomatic, and can be very difficult for even experts to understand.  This project develops techniques that combine insight from program analysis and machine learning to construct models to automatically transform non-intuitive compiled code into more idiomatic and understandable code. In particular, these models (A) Provide generic variable identifiers with more informative names. (B) Reconstruct names and structure of user-defined types. (C) Transform non-intuitive control flow into more idiomatic programming patterns. The project advances the state-of-the-art in both language models (requiring novelties in, e.g., neural language models and tree-based machine learning) and program analysis and transformation to constrain the search problems.\r\n\r\nThis award reflects NSF's statutory mission and has been deemed worthy of support through evaluation using the Foundation's intellectual merit and broader impacts review criteria.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Claire",
   "pi_last_name": "Le Goues",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Claire Le Goues",
   "pi_email_addr": "clegoues@cs.cmu.edu",
   "nsf_id": "000654066",
   "pi_start_date": "2019-07-05",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Graham",
   "pi_last_name": "Neubig",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Graham Neubig",
   "pi_email_addr": "gneubig@andrew.cmu.edu",
   "nsf_id": "000732016",
   "pi_start_date": "2019-07-05",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Carnegie-Mellon University",
  "inst_street_address": "5000 FORBES AVE",
  "inst_street_address_2": "",
  "inst_city_name": "PITTSBURGH",
  "inst_state_code": "PA",
  "inst_state_name": "Pennsylvania",
  "inst_phone_num": "4122688746",
  "inst_zip_code": "152133815",
  "inst_country_name": "United States",
  "cong_dist_code": "12",
  "st_cong_dist_code": "PA12",
  "org_lgl_bus_name": "CARNEGIE MELLON UNIVERSITY",
  "org_prnt_uei_num": "U3NKNFLNQ613",
  "org_uei_num": "U3NKNFLNQ613"
 },
 "perf_inst": {
  "perf_inst_name": "CARNEGIE MELLON UNIVERSITY",
  "perf_str_addr": "5000 Forbes Ave",
  "perf_city_name": "Pittsburgh",
  "perf_st_code": "PA",
  "perf_st_name": "Pennsylvania",
  "perf_zip_code": "152133890",
  "perf_ctry_code": "US",
  "perf_cong_dist": "12",
  "perf_st_cong_dist": "PA12",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  },
  {
   "pgm_ele_code": "806000",
   "pgm_ele_name": "Secure &Trustworthy Cyberspace"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "025Z",
   "pgm_ref_txt": "SaTC: Secure and Trustworthy Cyberspace"
  },
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7944",
   "pgm_ref_txt": "SOFTWARE ENG & FORMAL METHODS"
  },
  {
   "pgm_ref_code": "9102",
   "pgm_ref_txt": "WOMEN, MINORITY, DISABLED, NEC"
  },
  {
   "pgm_ref_code": "9178",
   "pgm_ref_txt": "UNDERGRADUATE EDUCATION"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  }
 ],
 "app_fund": [
  {
   "app_code": "",
   "app_name": "",
   "app_symb_id": "",
   "fund_code": "01002324DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0119",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001920DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2019,
   "fund_oblg_amt": 425000.0
  },
  {
   "fund_oblg_fiscal_yr": 2023,
   "fund_oblg_amt": 8000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Reverse engineering entails studying a program that has been translated from programming languages understandable to human software engineers into machine language, but for which the source code has been lost or discarded. This is common for malware or other malicious code, where adversaries deliberately obscure the programs' purposes and effects; it also applies to long-running systems that must be maintained over decades. Reverse engineers, security experts who specialize in this work, attempt to understand these programs despite the lack of source code.</p>\n<p>A major reason that reverse engineering is difficult is that programming languages, like the ones that software engineers use to write programs before they are translated into the code that computers actually execute, are designed to include information that help those engineers understand it. For example, software engineers typically use informative naming for variable names and methods, comments or annotations that explain what code does and why, and useful or idiomatic programming structures that are well-understood and recognized by other engineers. However, virtually all of this type of helpful information way is unnecessary to actually execute the program --- it simply serves to improve understandability by engineers working on it. It is therefore discarded when the program is translated into the language that a computer actually executes.</p>\n<p>As a result, reverse engineers' have a difficult job. Fortunately, there exist programs called decompilers that can convert machine-level code into a structure that is easier for human reverse engineers to comprehend. However, the most useful types of information --- names, custom structures, types, comments --- cannot be reconstructed this way. So, the code produced by these tools is still quite hard to understand, requiring significant effort and expertise to make sense of.&nbsp;The high-level goal of this project was to combine mathematical analysis of a computer program with state-of-the-art machine learning approaches originally designed for machine translation of natural languages to make decompiled code easier to understand by security experts.</p>\n<p>Intellectual Merit. This project developed ways to use machine learning approaches from natural language processing to (1) automatically choose informative names for the variables in source code produced by decompilers, significantly more accurately than the previous state-of-the-art or -practice, (2) select informative type definitions, and restructure the code accordingly, (3) evaluate the accuracy of these types of techniques effectively, in ways that capture the meaning humans actually derive from names in source code, and (4) optimize programs more effectively, using machine translation techniques. It also produced rigorous qualitative understanding of the challenges of decompilation and of using neural techniques to improve it, as well as higher-level insights on how to combine information about programs with machine translation to make better tools for software engineers.&nbsp;</p>\n<p>Broader Impacts. Decompilation is important because security experts use the technology to understand compiled programs. This is especially relevant for understanding and guarding against malware and other malicious programs, which attackers deliberately obscure. The project involved collaborating with domain experts and practicing reverse engineers to improve their tools and thus their work.&nbsp; The outcomes of this project therefore directly impact the practice of reverse engineering, and thus improve its potential to mitigate malicious programs in practice.</p>\n<p>&nbsp;</p><br>\n<p>\n Last Modified: 01/27/2024<br>\nModified by: Claire&nbsp;Le Goues</p></div>\n<div class=\"porSideCol\"\n></div>\n</div>\n",
  "por_txt_cntn": "\n\nReverse engineering entails studying a program that has been translated from programming languages understandable to human software engineers into machine language, but for which the source code has been lost or discarded. This is common for malware or other malicious code, where adversaries deliberately obscure the programs' purposes and effects; it also applies to long-running systems that must be maintained over decades. Reverse engineers, security experts who specialize in this work, attempt to understand these programs despite the lack of source code.\n\n\nA major reason that reverse engineering is difficult is that programming languages, like the ones that software engineers use to write programs before they are translated into the code that computers actually execute, are designed to include information that help those engineers understand it. For example, software engineers typically use informative naming for variable names and methods, comments or annotations that explain what code does and why, and useful or idiomatic programming structures that are well-understood and recognized by other engineers. However, virtually all of this type of helpful information way is unnecessary to actually execute the program --- it simply serves to improve understandability by engineers working on it. It is therefore discarded when the program is translated into the language that a computer actually executes.\n\n\nAs a result, reverse engineers' have a difficult job. Fortunately, there exist programs called decompilers that can convert machine-level code into a structure that is easier for human reverse engineers to comprehend. However, the most useful types of information --- names, custom structures, types, comments --- cannot be reconstructed this way. So, the code produced by these tools is still quite hard to understand, requiring significant effort and expertise to make sense of.The high-level goal of this project was to combine mathematical analysis of a computer program with state-of-the-art machine learning approaches originally designed for machine translation of natural languages to make decompiled code easier to understand by security experts.\n\n\nIntellectual Merit. This project developed ways to use machine learning approaches from natural language processing to (1) automatically choose informative names for the variables in source code produced by decompilers, significantly more accurately than the previous state-of-the-art or -practice, (2) select informative type definitions, and restructure the code accordingly, (3) evaluate the accuracy of these types of techniques effectively, in ways that capture the meaning humans actually derive from names in source code, and (4) optimize programs more effectively, using machine translation techniques. It also produced rigorous qualitative understanding of the challenges of decompilation and of using neural techniques to improve it, as well as higher-level insights on how to combine information about programs with machine translation to make better tools for software engineers.\n\n\nBroader Impacts. Decompilation is important because security experts use the technology to understand compiled programs. This is especially relevant for understanding and guarding against malware and other malicious programs, which attackers deliberately obscure. The project involved collaborating with domain experts and practicing reverse engineers to improve their tools and thus their work. The outcomes of this project therefore directly impact the practice of reverse engineering, and thus improve its potential to mitigate malicious programs in practice.\n\n\n\t\t\t\t\tLast Modified: 01/27/2024\n\n\t\t\t\t\tSubmitted by: ClaireLe Goues\n"
 }
}