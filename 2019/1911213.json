{
 "awd_id": "1911213",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Small: Collaborative research: Language-Integrated Verification for Determininistic Parallelism",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927885",
 "po_email": "abanerje@nsf.gov",
 "po_sign_block_name": "Anindya Banerjee",
 "awd_eff_date": "2019-10-01",
 "awd_exp_date": "2022-09-30",
 "tot_intn_awd_amt": 250000.0,
 "awd_amount": 250000.0,
 "awd_min_amd_letter_date": "2019-06-14",
 "awd_max_amd_letter_date": "2019-06-14",
 "awd_abstract_narration": "Formal verification promises to deliver software that works precisely according to a given mathematical specification. The last decade has seen several impressive formally verified software artifacts that are provably free of large classes of defects. However, these artifacts required Herculean feats of engineering, using specialized proof assistants that are separated, by a wide chasm, from the legacy languages and libraries that are used to engineer efficient parallel software. This project's novelties are in new techniques to enable the development of efficient parallel computing systems with formal assurances about correctness and reliability. This project's impacts will be to make formal verification a part of mainstream software development.\r\n\r\nThis project will build on two approaches discovered by the investigators. The first is refinement reflection, which turns existing programming languages into theorem provers, where the proofs are merely programs in that same language. Second, the investigators have introduced lattice variables, scheduling algorithms and a new linear type system to simplify the construction of efficient parallel software with well-defined behavior. This project will combine the above ideas into a framework wherein engineers can develop and verify parallel software, simply by writing programs in their host language, thereby economically integrating formal proofs within existing software development cycles.\r\n\r\nThis award reflects NSF's statutory mission and has been deemed worthy of support through evaluation using the Foundation's intellectual merit and broader impacts review criteria.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Ranjit",
   "pi_last_name": "Jhala",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Ranjit Jhala",
   "pi_email_addr": "jhala@cs.ucsd.edu",
   "nsf_id": "000486287",
   "pi_start_date": "2019-06-14",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of California-San Diego",
  "inst_street_address": "9500 GILMAN DR",
  "inst_street_address_2": "",
  "inst_city_name": "LA JOLLA",
  "inst_state_code": "CA",
  "inst_state_name": "California",
  "inst_phone_num": "8585344896",
  "inst_zip_code": "920930021",
  "inst_country_name": "United States",
  "cong_dist_code": "50",
  "st_cong_dist_code": "CA50",
  "org_lgl_bus_name": "UNIVERSITY OF CALIFORNIA, SAN DIEGO",
  "org_prnt_uei_num": "",
  "org_uei_num": "UYTTZT6G9DT1"
 },
 "perf_inst": {
  "perf_inst_name": "University of California-San Diego",
  "perf_str_addr": "",
  "perf_city_name": "",
  "perf_st_code": "CA",
  "perf_st_name": "California",
  "perf_zip_code": "920930404",
  "perf_ctry_code": "US",
  "perf_cong_dist": "50",
  "perf_st_cong_dist": "CA50",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7943",
   "pgm_ref_txt": "PROGRAMMING LANGUAGES"
  }
 ],
 "app_fund": [
  {
   "app_code": "0119",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001920DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2019,
   "fund_oblg_amt": 250000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>This project aimed to devise ways to integrate full functional verification directly<br />into a programming language with a rich ecosystem, thereby enabling proofs of real-world<br />code bases written in existing languages.<br /><br />The project had several significant outcomes, both in terms of new ways to integrate<br />formal verification techniques inside existing languages, as well as in new applications<br />of the verification methodology to important programming domains.<br /><br />First, we showed how LIVE can be used to verify the correctness of<br />sorting algorithms, that use Haskell's extensive support for parallelism<br />to achieve high-performance comparable to a C implementation.<br /><br />Second, we developed the notion of refined propositions and used it to<br />to formally establish the soundness of LIVE itself, and to design a methodology<br />for creating embedded domain specific verifiers for other languages, as libraries<br />within Haskell.<br /><br />Third, this project laid the foundations for building language integrated verifiers<br />for Rust, a modern systems programming language that has recently gained significant<br />popularity. In particular, we showed how Rust's ownership mechanisms allow us to retrofit<br />refinement types onto Rust in a manner that allows for compositional and highly ergonomic<br />verification.<br /><br />The work has already had significant impact --- several other groups in academia<br />and industry are building on our results, e.g. to build verified distributed<br />systems (Kuper et al OOPSLA 2021), secure information flow controls (Parker et al. POPL 2019).<br />Finally, we expect that the Rust verification work resulting from this project<br />will make it considerably easier to use LIVE to establish the security and correctness<br />properties of large computing systems infrastructure in years to come.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 04/26/2023<br>\n\t\t\t\t\tModified by: Ranjit&nbsp;Jhala</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nThis project aimed to devise ways to integrate full functional verification directly\ninto a programming language with a rich ecosystem, thereby enabling proofs of real-world\ncode bases written in existing languages.\n\nThe project had several significant outcomes, both in terms of new ways to integrate\nformal verification techniques inside existing languages, as well as in new applications\nof the verification methodology to important programming domains.\n\nFirst, we showed how LIVE can be used to verify the correctness of\nsorting algorithms, that use Haskell's extensive support for parallelism\nto achieve high-performance comparable to a C implementation.\n\nSecond, we developed the notion of refined propositions and used it to\nto formally establish the soundness of LIVE itself, and to design a methodology\nfor creating embedded domain specific verifiers for other languages, as libraries\nwithin Haskell.\n\nThird, this project laid the foundations for building language integrated verifiers\nfor Rust, a modern systems programming language that has recently gained significant\npopularity. In particular, we showed how Rust's ownership mechanisms allow us to retrofit\nrefinement types onto Rust in a manner that allows for compositional and highly ergonomic\nverification.\n\nThe work has already had significant impact --- several other groups in academia\nand industry are building on our results, e.g. to build verified distributed\nsystems (Kuper et al OOPSLA 2021), secure information flow controls (Parker et al. POPL 2019).\nFinally, we expect that the Rust verification work resulting from this project\nwill make it considerably easier to use LIVE to establish the security and correctness\nproperties of large computing systems infrastructure in years to come.\n\n\t\t\t\t\tLast Modified: 04/26/2023\n\n\t\t\t\t\tSubmitted by: Ranjit Jhala"
 }
}