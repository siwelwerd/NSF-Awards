{
 "awd_id": "1909143",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Small: Collaborative Research: A Rational Reconstruction of the Julia Type System",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927885",
 "po_email": "abanerje@nsf.gov",
 "po_sign_block_name": "Anindya Banerjee",
 "awd_eff_date": "2019-10-01",
 "awd_exp_date": "2022-09-30",
 "tot_intn_awd_amt": 252742.0,
 "awd_amount": 252742.0,
 "awd_min_amd_letter_date": "2019-06-14",
 "awd_max_amd_letter_date": "2020-07-27",
 "awd_abstract_narration": "Julia is an up-and-coming language in scientific computing. Julia straddles the line between being general-purpose and being domain-specific, and the line between being statically typed versus being dynamically typed. Despite being only six years old, Julia has been downloaded over 2 million times and has had nearly 2,000 packages developed by its community. The novelty of this project is to develop some of the foundations of the Julia type system which have not been formalized to date. The project's impacts are to provide a well-grounded specification to the language so that the specification can be used by programmers to reason about their code, and by tool developers to write program analysis and transformation software for the Julia community.\r\n\r\nJulia supports dynamic typing. Programs can be written without any type annotations as they would be written in, say, Python. Yet, Julia's grammar of types and its subtyping system is reminiscent of what one would expect of a modern statically typed language with an original combination of structural subtyping, invariant nominal generics, union types, existential types, covariant tuples, distributivity, and singleton types, as well as the, so-called, diagonal rule. This complex system is used to determine the run-time behavior of Julia programs. Specifically it is used to determine, for a given multimethod, which of its implementations is applicable. To make this determination, Julia compares the run-time types of arguments with the static types of the parameters of various overloadings. This means that the algorithmic behavior of Julia's type system is central to the language's semantics, performance, and usage. Yet Julia uses features, such as iterated unions, for which the research community has not yet developed adequate algorithms. As such, Julia's type system is currently specified by a reference implementation in C, one that has been made complex after years of balancing performance trade-offs with the need to patch bug reports filed by the language's users. The project, therefore, aims to perform experiments and studies to determine what the underlying intent of the implementation is, formalize that intent axiomatically as a type system, and then develop and verify the key algorithms for implementing the core of the Julia language.\r\n\r\nThis award reflects NSF's statutory mission and has been deemed worthy of support through evaluation using the Foundation's intellectual merit and broader impacts review criteria.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Former Principal Investigator",
   "pi_first_name": "Ross",
   "pi_last_name": "Tate",
   "pi_mid_init": "E",
   "pi_sufx_name": "",
   "pi_full_name": "Ross E Tate",
   "pi_email_addr": "ross@cs.cornell.edu",
   "nsf_id": "000579898",
   "pi_start_date": "2019-06-14",
   "pi_end_date": "2020-07-27"
  },
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Adrian",
   "pi_last_name": "Sampson",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Adrian Sampson",
   "pi_email_addr": "asampson@cornell.edu",
   "nsf_id": "000719636",
   "pi_start_date": "2020-07-27",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Cornell University",
  "inst_street_address": "341 PINE TREE RD",
  "inst_street_address_2": "",
  "inst_city_name": "ITHACA",
  "inst_state_code": "NY",
  "inst_state_name": "New York",
  "inst_phone_num": "6072555014",
  "inst_zip_code": "148502820",
  "inst_country_name": "United States",
  "cong_dist_code": "19",
  "st_cong_dist_code": "NY19",
  "org_lgl_bus_name": "CORNELL UNIVERSITY",
  "org_prnt_uei_num": "",
  "org_uei_num": "G56PUALJ3KT5"
 },
 "perf_inst": {
  "perf_inst_name": "Cornell University",
  "perf_str_addr": "107 Hoy Road",
  "perf_city_name": "Ithaca",
  "perf_st_code": "NY",
  "perf_st_name": "New York",
  "perf_zip_code": "148537501",
  "perf_ctry_code": "US",
  "perf_cong_dist": "19",
  "perf_st_cong_dist": "NY19",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7943",
   "pgm_ref_txt": "PROGRAMMING LANGUAGES"
  }
 ],
 "app_fund": [
  {
   "app_code": "0119",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001920DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2019,
   "fund_oblg_amt": 252742.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>The Julia programming language is growing in popularity as a way to make it easy to develop high-performance scientific computing software. Part of what makes Julia effective at combining productivity and computational efficiency is its advanced type system, which combines aspects of static typing (as in Java or OCaml) with dynamic typing (as in Python or JavaScript). However, this unique combination of typing styles grew organically, and it has subtle effects on the meaning of programs in the Julia language that can be difficult to describe in detail. The result is that there are \"dark corners\" of the programming language that can become pitfalls for programmers, introducing subtle bugs.<br />This project developed a scientific understanding of the Julia programming language and distilled its core principles in a way that is useful to the broader community of programming language design and research. In the process, it also yielded new guidelines for understanding what makes Julia programs fast or slow because of the way they interact with the languages just-in-time (JIT) compilation strategy. The resulting understanding and guidelines will make it easier to develop fast, correct software in Julia, guide the evolution of the Julia language, and inform the development of future languages that borrow ideas from Julia.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 03/09/2023<br>\n\t\t\t\t\tModified by: Adrian&nbsp;Sampson</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nThe Julia programming language is growing in popularity as a way to make it easy to develop high-performance scientific computing software. Part of what makes Julia effective at combining productivity and computational efficiency is its advanced type system, which combines aspects of static typing (as in Java or OCaml) with dynamic typing (as in Python or JavaScript). However, this unique combination of typing styles grew organically, and it has subtle effects on the meaning of programs in the Julia language that can be difficult to describe in detail. The result is that there are \"dark corners\" of the programming language that can become pitfalls for programmers, introducing subtle bugs.\nThis project developed a scientific understanding of the Julia programming language and distilled its core principles in a way that is useful to the broader community of programming language design and research. In the process, it also yielded new guidelines for understanding what makes Julia programs fast or slow because of the way they interact with the languages just-in-time (JIT) compilation strategy. The resulting understanding and guidelines will make it easier to develop fast, correct software in Julia, guide the evolution of the Julia language, and inform the development of future languages that borrow ideas from Julia.\n\n\t\t\t\t\tLast Modified: 03/09/2023\n\n\t\t\t\t\tSubmitted by: Adrian Sampson"
 }
}