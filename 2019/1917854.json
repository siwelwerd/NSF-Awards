{
 "awd_id": "1917854",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "FMitF: Track II:  Refinement Types in the Haskell Ecosystem",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927885",
 "po_email": "abanerje@nsf.gov",
 "po_sign_block_name": "Anindya Banerjee",
 "awd_eff_date": "2019-07-01",
 "awd_exp_date": "2020-12-31",
 "tot_intn_awd_amt": 100000.0,
 "awd_amount": 100000.0,
 "awd_min_amd_letter_date": "2019-07-02",
 "awd_max_amd_letter_date": "2019-07-02",
 "awd_abstract_narration": "Formal methods for ensuring the reliability of software will only become ubiquitous if they can be seamlessly integrated within widely used language ecosystems. The Liquid Haskell (LH) system integrates verification within the Haskell programming language, by allowing developers to specify correctness requirements as contracts extending Haskell's types. LH can then automatically verify these contracts at compile-time ensuring the deployed program will always execute according to its specification. This project's novelties are in new methods to integrate LH within the Glasgow Haskell Compiler (GHC) toolchain. Consequently, the project's impacts will be to enable tight integration within the engineering workflow used in industry making it possible to run LH on large, industrial code bases.\r\n\r\nThis project will build on GHC's recently added plugins and annotations mechanisms to integrate refinement types within the compiler. This integration will allow LH to reuse GHC's module system to allow programmers to publish specifications for their libraries that can be reused by clients of those modules, and to support incremental verification that is essential for scaling verification to industrial sized code bases. As a result, the project will yield a tool that is tightly integrated within a widely used, industrial strength compiler, enabling engineers to utilize decades worth of formal methods research to eliminate hard-to-find correctness bugs from deployed systems.\r\n\r\nThis award reflects NSF's statutory mission and has been deemed worthy of support through evaluation using the Foundation's intellectual merit and broader impacts review criteria.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Ranjit",
   "pi_last_name": "Jhala",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Ranjit Jhala",
   "pi_email_addr": "jhala@cs.ucsd.edu",
   "nsf_id": "000486287",
   "pi_start_date": "2019-07-02",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of California-San Diego",
  "inst_street_address": "9500 GILMAN DR",
  "inst_street_address_2": "",
  "inst_city_name": "LA JOLLA",
  "inst_state_code": "CA",
  "inst_state_name": "California",
  "inst_phone_num": "8585344896",
  "inst_zip_code": "920930021",
  "inst_country_name": "United States",
  "cong_dist_code": "50",
  "st_cong_dist_code": "CA50",
  "org_lgl_bus_name": "UNIVERSITY OF CALIFORNIA, SAN DIEGO",
  "org_prnt_uei_num": "",
  "org_uei_num": "UYTTZT6G9DT1"
 },
 "perf_inst": {
  "perf_inst_name": "University of California-San Diego",
  "perf_str_addr": "9500 Gilman Drive",
  "perf_city_name": "San Diego",
  "perf_st_code": "CA",
  "perf_st_name": "California",
  "perf_zip_code": "920930404",
  "perf_ctry_code": "US",
  "perf_cong_dist": "50",
  "perf_st_cong_dist": "CA50",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "094Y00",
   "pgm_ele_name": "FMitF: Formal Methods in the F"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "062Z",
   "pgm_ref_txt": "Harnessing the Data Revolution"
  },
  {
   "pgm_ref_code": "071Z",
   "pgm_ref_txt": "FMitF-Formal Methods in the Field"
  },
  {
   "pgm_ref_code": "7943",
   "pgm_ref_txt": "PROGRAMMING LANGUAGES"
  },
  {
   "pgm_ref_code": "8206",
   "pgm_ref_txt": "Formal Methods and Verification"
  }
 ],
 "app_fund": [
  {
   "app_code": "0119",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001920DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2019,
   "fund_oblg_amt": 100000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p><br />The LiquidHaskell (LH) system integrates verificationin the Haskell programming language. LH allows programmers write expressive specifications about how their code should behave, and lets the compiler verify those specifications automatically, thereby catching important classes of software errors and security vulnerabilities before the code is even deployed.</p>\n<p>Users find it difficult to adopt LH as it lacks integration within compilation and package (module)management toolchain built around Haskell's GHC toolchain.<br />This project used&nbsp;GHC?s recently added \"plugin\" mechanisms to integrate LH withinthe GHC compiler, greatly simplifying the use of LH in real-world software engineering.&nbsp;<br /><br />In other words, this work allows Haskell developers to integrate LHroutinely into the development cycle, starting with generic, automaticallychecked properties (excep- tion safety, memory safety, termination)and providing a gradual path to more detailed application specific properties, which in turn, will allow regular developers to use verification in day-to-day software engineering.<br /><br />The project has been extremely well received by the Haskell community, as summed up by this note by an author of many of the most widely used Haskell libraries:&nbsp;<br /><br />\"Liquid Haskell becoming a GHC plugin took it from being a mostly-academic&nbsp; toy to an amazing power tool overnight.\"<br /><br />We know of several companies that are using or investigating deploying LH as part of their regular code builds, and we have used the new architecture to build a new framework to build and deploy secure web applications.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 06/01/2021<br>\n\t\t\t\t\tModified by: Ranjit&nbsp;Jhala</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\n\nThe LiquidHaskell (LH) system integrates verificationin the Haskell programming language. LH allows programmers write expressive specifications about how their code should behave, and lets the compiler verify those specifications automatically, thereby catching important classes of software errors and security vulnerabilities before the code is even deployed.\n\nUsers find it difficult to adopt LH as it lacks integration within compilation and package (module)management toolchain built around Haskell's GHC toolchain.\nThis project used GHC?s recently added \"plugin\" mechanisms to integrate LH withinthe GHC compiler, greatly simplifying the use of LH in real-world software engineering. \n\nIn other words, this work allows Haskell developers to integrate LHroutinely into the development cycle, starting with generic, automaticallychecked properties (excep- tion safety, memory safety, termination)and providing a gradual path to more detailed application specific properties, which in turn, will allow regular developers to use verification in day-to-day software engineering.\n\nThe project has been extremely well received by the Haskell community, as summed up by this note by an author of many of the most widely used Haskell libraries: \n\n\"Liquid Haskell becoming a GHC plugin took it from being a mostly-academic  toy to an amazing power tool overnight.\"\n\nWe know of several companies that are using or investigating deploying LH as part of their regular code builds, and we have used the new architecture to build a new framework to build and deploy secure web applications.\n\n\t\t\t\t\tLast Modified: 06/01/2021\n\n\t\t\t\t\tSubmitted by: Ranjit Jhala"
 }
}