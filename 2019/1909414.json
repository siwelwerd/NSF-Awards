{
 "awd_id": "1909414",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Small: Explicating and Exploiting the Physical Semantics of Code",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927841",
 "po_email": "sgreensp@nsf.gov",
 "po_sign_block_name": "Sol Greenspan",
 "awd_eff_date": "2019-10-01",
 "awd_exp_date": "2024-09-30",
 "tot_intn_awd_amt": 515022.0,
 "awd_amount": 515022.0,
 "awd_min_amd_letter_date": "2019-08-03",
 "awd_max_amd_letter_date": "2023-04-05",
 "awd_abstract_narration": "Code drives robots, space vehicles, weapons systems, and cyber-physical systems more generally, to interact with the world. Yet in most cases, code consists of machine logic stripped of real world semantics. This means that there is no way for the computing machine to prevent operations specified in code from violating physical constraints inherited from the physical world. Traditional programming semantics can tell us that the expression, 3.0 + 4.0 means 7.0, in the sense that 7.0 is the result of evaluating that expression. But our traditional conception of programming semantics does not address the questions, 3 of what, 4 of what, or 7 of what, or whether such a sum makes any physical sense.  For example 3 meters plus 4 grams does not make physical sense. Major systems malfunctions have occurred due to the machine-permitted evaluation of expressions that have no well defined physical meanings. To improve the safety and reliability of cyber-physical systems, this project will develop and evaluate the proposition that the software code of the future should comprise machine logic paired with interpretations that map terms in code, and eventually in program executions, to formal specifications of their intended physical meaning so that the consistency of code with the physics of the larger system can be automatically checked. The investigators aim to establish a new and formal concept of the physical semantics of programs based on interpretations that map code elements to mathematical quantities that precisely represent objects and other phenomena in the physical world. Having such mappings will in turn support the evaluation of code for consistency with its intended physical interpretation, enabling significant improvements in system dependability.\r\n \r\n\r\nThis project will establish theoretical foundations for physical semantics of cyber-physical code by augmenting code with interpretation mappings from code-level terms to mechanically checkable specifications of dimensionful physical quantities, such as points and transformations, formalized in the higher-order logic of a constructive logic proof assistant. This project will establish mechanisms to substantially automate the construction of interpretations to enable practical physics-level analysis and checking of software-intensive systems. It will advance software-engineering theory and practice by investigating means for specifying and analyzing such interpretations, including mechanisms for automated inference of physical semantics, libraries of formalized physical abstractions, systems to enforce interpretations imposed on code, and means for exploiting physical interpretations for testing, program understanding, system integration, and other use cases. The project will contribute to education by developing teaching materials on formalized physical abstractions and by supporting the ongoing development of a discrete mathematics course for undergraduates based on the use of a constructive-logic proof assistant. It will contribute to workforce development in research and in software engineering for cyber-physical systems.\r\n\r\nThis award reflects NSF's statutory mission and has been deemed worthy of support through evaluation using the Foundation's intellectual merit and broader impacts review criteria.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Kevin",
   "pi_last_name": "Sullivan",
   "pi_mid_init": "J",
   "pi_sufx_name": "",
   "pi_full_name": "Kevin J Sullivan",
   "pi_email_addr": "sullivan@cs.virginia.edu",
   "nsf_id": "000086645",
   "pi_start_date": "2019-08-03",
   "pi_end_date": null
  },
  {
   "pi_role": "Former Co-Principal Investigator",
   "pi_first_name": "Sebastian",
   "pi_last_name": "Elbaum",
   "pi_mid_init": "G",
   "pi_sufx_name": "",
   "pi_full_name": "Sebastian G Elbaum",
   "pi_email_addr": "selbaum@virginia.edu",
   "nsf_id": "000412723",
   "pi_start_date": "2019-08-03",
   "pi_end_date": "2023-04-05"
  }
 ],
 "inst": {
  "inst_name": "University of Virginia Main Campus",
  "inst_street_address": "1001 EMMET ST N",
  "inst_street_address_2": "",
  "inst_city_name": "CHARLOTTESVILLE",
  "inst_state_code": "VA",
  "inst_state_name": "Virginia",
  "inst_phone_num": "4349244270",
  "inst_zip_code": "229034833",
  "inst_country_name": "United States",
  "cong_dist_code": "05",
  "st_cong_dist_code": "VA05",
  "org_lgl_bus_name": "RECTOR & VISITORS OF THE UNIVERSITY OF VIRGINIA",
  "org_prnt_uei_num": "",
  "org_uei_num": "JJG6HU8PA4S5"
 },
 "perf_inst": {
  "perf_inst_name": "University of Virginia Main Campus",
  "perf_str_addr": "PO Box 400740",
  "perf_city_name": "Charlottesville",
  "perf_st_code": "VA",
  "perf_st_name": "Virginia",
  "perf_zip_code": "229044195",
  "perf_ctry_code": "US",
  "perf_cong_dist": "05",
  "perf_st_cong_dist": "VA05",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7944",
   "pgm_ref_txt": "SOFTWARE ENG & FORMAL METHODS"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  }
 ],
 "app_fund": [
  {
   "app_code": "0119",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001920DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2019,
   "fund_oblg_amt": 515022.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>This project addressed an important source of errors in software for cyberphysical systems. The key insight is that code implements mathematical abstractions of physical reality (e.g., with concepts in linear and affine algebra representing points and intervals in classical time and space), but code is not constrained by traditional programming type systems to be consistent with the rules (axioms) of these mathematical structures, so errors can easily slip into code that cannot be captured by programming type systems. The new idea was to generalize the from traditional annotations of scalar values with physical semantics (e.g., physical units) to annotations that would connect code to much richer mathematical abstractions, taking advantage of advances in formalization of abstract mathematics around the language and tooling of the Lean 4 \"proof assistant.\" What we found was that annotating code to make its physical semantics explicit did not work well. The problem is that complex abstractions when implemented tend to be spread across to code of a given system. This insight led the team to focus instead of understanding in a granular way how abstract mathematical models are mapped to code, with a focus on the erasure of critical information present in these abstract models but not in the code. As an example, one can represent points in an affine space as tuples of floating point numbers. At the code level, one can easily add together these tuples. The upshot is that, e.g., in widely used robotics libraries, one can add together two *points* in an affine space, even those that operation is not defined or permitted in abstract algebra.</p>\r\n<p>Given the finding that reverse mapping from code to formalized mathematics was not going to work, the team turned its attention to forward, but often forgetful, mappings from mathematical abstractions to code. The team took advantage of needs for tooling in another application domain (in healthcare) to develop a novel mathematical theory of \"concept algebras\" (building on work of MIT's Prof. Daniel Jackson), with an advanced forward-mapping toolset taking abstract models in this formal style to industrially viable, cloud-based, provably securable software systems. This infrastructure is the basis for currently advanced planning for a commercial spin-out. It has also resulted in the production of an experimental demonstration system with significant apparent value in the area of healthcare delivery systems around the issue of moral distress.<br /><br />One of the most important outcomes of this work is the development, testing, and evaluation of a highly novel new foundational course for undergraduate students in computer science. Simply put, generations of computer science students have been trained exceptionally well in computation and programming languages, but exceptionally poorly in formal reasoning and formal languages, particular in the ones most capable of clearly expressing the kinds of complex mathematics that underlies physics and many other fields. Indeed, the only course that most CS students ever take in reasoning is \"CS2: Discrete Mathematics and Theory.\" In most cases, such courses teach basic first-order logic, set theory, and induction on natural numbers as paper-and-pencil affairs with little or no obvious relevance to computing or industry.<br /><br />At the outset of this project, the PI speculated that the incredibly expressive Language of the Lean 4 prover, along with its excellent tooling, and the deep connections it establishes betwen reasoning and computation (via the Curry Howard Correspondence) would emerge as the world's preeminent language for the formalization of advanced mathematics in a way that computer science world could then exploit. That predication has been bourne out. The entire new course is thus presented using Lean, with major advantages for students. First, there is now exploding demand for students trained to use it, especially for reasoning about security in indstrial organizations, such as Amazon Web Services (AWS). Second, all of the concepts taught in such a course can be expressed with great clarity and precision in the&nbsp; higher-order logic of the Lean prover, but&nbsp; not in the language of first-order logic that such courses traditionally teach. Third, the course teaches formal reasoning as a *kind of computation*, connecting what is otherwise just dreary and arcane subject matter, divorced from students' intrinsic interest in computing, into a displine that is profounding computational at is core. This course is presented to the community as a model for completely replacing traditional paper-pencil, first-order-based \"CS2: Discrete Math and Theory\" in the undergraduate curriculum with a new course that will provide students with deep intellectual insights that are now also of high value in industry and practice. The course can also serve as the first major unit (approximately 1/2 semester) of an introductory graduate-level course in formal languages, reasoning, and the formalization of abstract mathematics of high relevance in the design of cyber-physical and many other kinds of systems. Applications to providing ultra-high assurance of system security emerges as a particular commpelling use case.</p><br>\n<p>\n Last Modified: 02/14/2025<br>\nModified by: Kevin&nbsp;J&nbsp;Sullivan</p></div>\n<div class=\"porSideCol\"\n></div>\n</div>\n",
  "por_txt_cntn": "\n\nThis project addressed an important source of errors in software for cyberphysical systems. The key insight is that code implements mathematical abstractions of physical reality (e.g., with concepts in linear and affine algebra representing points and intervals in classical time and space), but code is not constrained by traditional programming type systems to be consistent with the rules (axioms) of these mathematical structures, so errors can easily slip into code that cannot be captured by programming type systems. The new idea was to generalize the from traditional annotations of scalar values with physical semantics (e.g., physical units) to annotations that would connect code to much richer mathematical abstractions, taking advantage of advances in formalization of abstract mathematics around the language and tooling of the Lean 4 \"proof assistant.\" What we found was that annotating code to make its physical semantics explicit did not work well. The problem is that complex abstractions when implemented tend to be spread across to code of a given system. This insight led the team to focus instead of understanding in a granular way how abstract mathematical models are mapped to code, with a focus on the erasure of critical information present in these abstract models but not in the code. As an example, one can represent points in an affine space as tuples of floating point numbers. At the code level, one can easily add together these tuples. The upshot is that, e.g., in widely used robotics libraries, one can add together two *points* in an affine space, even those that operation is not defined or permitted in abstract algebra.\r\n\n\nGiven the finding that reverse mapping from code to formalized mathematics was not going to work, the team turned its attention to forward, but often forgetful, mappings from mathematical abstractions to code. The team took advantage of needs for tooling in another application domain (in healthcare) to develop a novel mathematical theory of \"concept algebras\" (building on work of MIT's Prof. Daniel Jackson), with an advanced forward-mapping toolset taking abstract models in this formal style to industrially viable, cloud-based, provably securable software systems. This infrastructure is the basis for currently advanced planning for a commercial spin-out. It has also resulted in the production of an experimental demonstration system with significant apparent value in the area of healthcare delivery systems around the issue of moral distress.\n\nOne of the most important outcomes of this work is the development, testing, and evaluation of a highly novel new foundational course for undergraduate students in computer science. Simply put, generations of computer science students have been trained exceptionally well in computation and programming languages, but exceptionally poorly in formal reasoning and formal languages, particular in the ones most capable of clearly expressing the kinds of complex mathematics that underlies physics and many other fields. Indeed, the only course that most CS students ever take in reasoning is \"CS2: Discrete Mathematics and Theory.\" In most cases, such courses teach basic first-order logic, set theory, and induction on natural numbers as paper-and-pencil affairs with little or no obvious relevance to computing or industry.\n\nAt the outset of this project, the PI speculated that the incredibly expressive Language of the Lean 4 prover, along with its excellent tooling, and the deep connections it establishes betwen reasoning and computation (via the Curry Howard Correspondence) would emerge as the world's preeminent language for the formalization of advanced mathematics in a way that computer science world could then exploit. That predication has been bourne out. The entire new course is thus presented using Lean, with major advantages for students. First, there is now exploding demand for students trained to use it, especially for reasoning about security in indstrial organizations, such as Amazon Web Services (AWS). Second, all of the concepts taught in such a course can be expressed with great clarity and precision in the higher-order logic of the Lean prover, but not in the language of first-order logic that such courses traditionally teach. Third, the course teaches formal reasoning as a *kind of computation*, connecting what is otherwise just dreary and arcane subject matter, divorced from students' intrinsic interest in computing, into a displine that is profounding computational at is core. This course is presented to the community as a model for completely replacing traditional paper-pencil, first-order-based \"CS2: Discrete Math and Theory\" in the undergraduate curriculum with a new course that will provide students with deep intellectual insights that are now also of high value in industry and practice. The course can also serve as the first major unit (approximately 1/2 semester) of an introductory graduate-level course in formal languages, reasoning, and the formalization of abstract mathematics of high relevance in the design of cyber-physical and many other kinds of systems. Applications to providing ultra-high assurance of system security emerges as a particular commpelling use case.\t\t\t\t\tLast Modified: 02/14/2025\n\n\t\t\t\t\tSubmitted by: KevinJSullivan\n"
 }
}