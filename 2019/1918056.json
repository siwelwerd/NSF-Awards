{
 "awd_id": "1918056",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "FMitF: Collaborative Research: Track I: Finding and Eliminating Bugs in Operating Systems",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032922585",
 "po_email": "pprabhak@nsf.gov",
 "po_sign_block_name": "Pavithra Prabhakar",
 "awd_eff_date": "2019-07-01",
 "awd_exp_date": "2023-06-30",
 "tot_intn_awd_amt": 250000.0,
 "awd_amount": 250000.0,
 "awd_min_amd_letter_date": "2019-06-19",
 "awd_max_amd_letter_date": "2019-06-19",
 "awd_abstract_narration": "Operating systems are both huge -- tens of millions of lines of code -- and hugely important -- they manage resources and provide services to the applications that run society. Like all software, operating systems contain bugs. Unfortunately, bugs in such foundational systems can have catastrophic consequences, from large-scale data leaks to complete machine takeovers by malicious agents. The team of researchers develops new tools that can be used to find and eliminate such bugs before a system is deployed, when the bugs can compromise performance, reliability, and security. The project's novelties are foundational techniques, languages, and algorithms that empower software developers to describe buggy patterns that allow automated tools to scale and find bugs in many millions of lines of code. The project's impacts will be in improving the robustness, reliability, and security of real-world operating systems.\r\n    \r\nExisting approaches to bug finding either are precise or scale to large systems but not both. This project reconciles scalability and precision with a key insight: that system-specific extensibility will allow developers to extend core algorithms to check for properties and patterns that are important to their particular systems in a way that scales to large code bases. To this end, the researchers develop new symbolic-execution-based methods that are extensible, precise and scalable, thereby allowing developers to easily customize extensions to focus on likely error patterns while allowing them to swiftly ignore many millions of lines of irrelevant code. The speed, precision and scalability in turn allows developers to directly integrate the project's tools into their software-development cycle to eliminate bugs well before deployment.\r\n\r\nThis award reflects NSF's statutory mission and has been deemed worthy of support through evaluation using the Foundation's intellectual merit and broader impacts review criteria.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Dawson",
   "pi_last_name": "Engler",
   "pi_mid_init": "R",
   "pi_sufx_name": "",
   "pi_full_name": "Dawson R Engler",
   "pi_email_addr": "engler@csl.stanford.edu",
   "nsf_id": "000485661",
   "pi_start_date": "2019-06-19",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Stanford University",
  "inst_street_address": "450 JANE STANFORD WAY",
  "inst_street_address_2": "",
  "inst_city_name": "STANFORD",
  "inst_state_code": "CA",
  "inst_state_name": "California",
  "inst_phone_num": "6507232300",
  "inst_zip_code": "943052004",
  "inst_country_name": "United States",
  "cong_dist_code": "16",
  "st_cong_dist_code": "CA16",
  "org_lgl_bus_name": "THE LELAND STANFORD JUNIOR UNIVERSITY",
  "org_prnt_uei_num": "",
  "org_uei_num": "HJD6G4D6TJY5"
 },
 "perf_inst": {
  "perf_inst_name": "Stanford University",
  "perf_str_addr": "353 Serra Mall, Gates 314",
  "perf_city_name": "Stanford",
  "perf_st_code": "CA",
  "perf_st_name": "California",
  "perf_zip_code": "943055008",
  "perf_ctry_code": "US",
  "perf_cong_dist": "16",
  "perf_st_cong_dist": "CA16",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "094Y00",
   "pgm_ele_name": "FMitF: Formal Methods in the F"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "062Z",
   "pgm_ref_txt": "Harnessing the Data Revolution"
  },
  {
   "pgm_ref_code": "8206",
   "pgm_ref_txt": "Formal Methods and Verification"
  }
 ],
 "app_fund": [
  {
   "app_code": "0119",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001920DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2019,
   "fund_oblg_amt": 250000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>&nbsp;</p>\n<div class=\"adM\">\n<div class=\"im\">Our two most significant outcomes are (1) the sys<br />extensible symbolic execution system and (2) a new approach<br />to writing dynamic kernel checkers that is both simple<br />and effective.<br /><br /></div>\n</div>\n<p><span>I. Sys: symbolic execution for massive industrial software.</span><br /><br /><span>Sys clients write small, custom checkers that use a</span><br /><span>combination of static analysis and symbolic execution to</span><br /><span>find tricky errors.&nbsp; Their static extensions quickly find</span><br /><span>many potential error sites (i.e., achieve high recall),</span><br /><span>while their symbolic extensions use sys's bit-accurate</span><br /><span>symbolic engine to do deep, effective reasoning about</span><br /><span>these potential errors (i.e., achieve high precision). We</span><br /><span>check enormous code-bases, so sys massively improves the</span><br /><span>scalability of the symbolic checkers by jumping right to</span><br /><span>potential error sites.</span><br /><br /><span>Sys's extensibility lets clients easily exploit</span><br /><span>domain-specific or even program-specific information both</span><br /><span>to detect novel errors and to eliminate false positives,</span><br /><span>thereby finding errors beyond the reach of a rigid system.</span><br /><br /><span>At under 5K lines of code, it is roughly an order of</span><br /><span>magnitude smaller than many other tools.&nbsp; This simplicity</span><br /><span>improves both robustness (less code, fewer bugs) and</span><br /><span>power (the simpler the system, the easier it is to add</span><br /><span>new analysis methods).</span><br /><br /><span>The combination of these methods produces a tool that</span><br /><span>regularly, robustly finds deep bugs in the hardest</span><br /><span>open-source code I know of to check: Google Chrome,</span><br /><span>Firefox, and SQLite. These are enormous, complex code</span><br /><span>bases that have undergone years of aggressive professional</span><br /><span>checking.&nbsp; As one example, Chrome is tens of millions</span><br /><span>of lines of C++ code.&nbsp; Its dedicated professional team</span><br /><span>constantly scans its source using a wide set of static</span><br /><span>and dynamic tools (which appears to be the set of any</span><br /><span>tool that works that they can get a copy of). Its code</span><br /><span>has undergone 24/7 random ``fuzz'' testing on over 25,000</span><br /><span>machines for the past several years. On top of all this,</span><br /><span>they solicit bugs from anyone and pay cash bounties of</span><br /><span>hundreds to tens of thousands of dollars for any bug they</span><br /><span>deem serious. As a result, the code has been picked clean</span><br /><span>of easily found bugs. Firefox has a similar process. SQLite</span><br /><span>gets the union of both since it is included in both Firefox</span><br /><span>and Chrome. I don't know of any other open-source projects</span><br /><span>that have anywhere close to this aggressive an effort.</span><br /><br /><span>II. A new approach to kernel dynamic checkers.</span><br /><br /><span>If an operating system hits a bug and crashes, tracking</span><br /><span>down the root cause can easily take days. &nbsp;(It can also</span><br /><span>take never.) &nbsp;Worse, if the OS hits a bug and does not</span><br /><span>crash, but instead subtly corrupts state, or leaves one</span><br /><span>of the many many machine caches with a stale entry, the</span><br /><span>expected value of finding this bug is ``good luck.''</span><br /><span>When it works, dynamic binary analysis tools can be a</span><br /><span>good way to such bugs.&nbsp; It checks exactly what runs on</span><br /><span>the machine, it has a complete accurate view into register</span><br /><span>and memory state, and by checking code that that runs on</span><br /><span>native hardware (such as devices) it does not have to make</span><br /><span>fake versions of them.</span><br /><br /><span>The current state of the practice for dynamic tools</span><br /><span>is to use a dynamic translation (for code discovery)</span><br /><span>and then form of instruction emulation to determine an</span><br /><span>instruction's effects.&nbsp; The code to do this can easily be</span><br /><span>over a hundred thousand lines of complex, difficult code</span><br /><span>(both to write and debug).&nbsp; One cascading effect of this</span><br /><span>complexity is that few dynamic tools run on kernel code.</span><br /><br /><span>Our second major result is showing how to use common</span><br /><span>debugging hardware support for single-step execution</span><br /><span>to make writing powerful dynamic tools easy --- often a</span><br /><span>few hundred lines of code.&nbsp; Unlike most current tools,</span><br /><span>these work well on kernel code. This novel ease makes</span><br /><span>it correspondingly easy to quickly build novel tools. We</span><br /><span>present a number of unique tools based on this approach</span><br /><span>to precisely and immediately find kernel bugs extremely</span><br /><span>difficult to track down without them.</span><br /><br /><span>We have written numerous checkers (examples include</span><br /><span>memory corruption, concurrency, and that routines</span><br /><span>are bit-equivalent after patching or modification).</span><br /><span>We have shown that the approach works on both ARM and</span><br /><span>RISC-V hardware.&nbsp; The approach is simple enough that we've</span><br /><span>had hundreds of Stanford students students over the past</span><br /><span>few years write their own implementations, typically in</span><br /><span>less than 6 hours.&nbsp; The labs for these classes can be</span><br /><span>seen in the open github repositories for 140e and 240lx.</span></p>\n<div><br />Two examples:<br />&nbsp;- dynamic race detection<br />&nbsp;<a href=\"https://github.com/dddrrreee/cs240lx-22spr/tree/main/labs/16-eraser\" target=\"_blank\">https://github.com/dddrrreee/cs240lx-22spr/tree/main/labs/16-eraser</a><br />&nbsp;- memory corruption<br />&nbsp;<a href=\"https://github.com/dddrrreee/cs240lx-22spr/tree/main/labs/11-memcheck-trap\" target=\"_blank\">https://github.com/dddrrreee/cs240lx-22spr/tree/main/labs/11-memcheck-trap</a></div>\n<p>&nbsp;</p>\n<p>&nbsp;</p><br>\n<p>\n Last Modified: 05/09/2024<br>\nModified by: Dawson&nbsp;R&nbsp;Engler</p></div>\n<div class=\"porSideCol\"\n></div>\n</div>\n",
  "por_txt_cntn": "\n\n\n\nOur two most significant outcomes are (1) the sys\nextensible symbolic execution system and (2) a new approach\nto writing dynamic kernel checkers that is both simple\nand effective.\n\n\n\n\n\nI. Sys: symbolic execution for massive industrial software.\n\nSys clients write small, custom checkers that use a\ncombination of static analysis and symbolic execution to\nfind tricky errors. Their static extensions quickly find\nmany potential error sites (i.e., achieve high recall),\nwhile their symbolic extensions use sys's bit-accurate\nsymbolic engine to do deep, effective reasoning about\nthese potential errors (i.e., achieve high precision). We\ncheck enormous code-bases, so sys massively improves the\nscalability of the symbolic checkers by jumping right to\npotential error sites.\n\nSys's extensibility lets clients easily exploit\ndomain-specific or even program-specific information both\nto detect novel errors and to eliminate false positives,\nthereby finding errors beyond the reach of a rigid system.\n\nAt under 5K lines of code, it is roughly an order of\nmagnitude smaller than many other tools. This simplicity\nimproves both robustness (less code, fewer bugs) and\npower (the simpler the system, the easier it is to add\nnew analysis methods).\n\nThe combination of these methods produces a tool that\nregularly, robustly finds deep bugs in the hardest\nopen-source code I know of to check: Google Chrome,\nFirefox, and SQLite. These are enormous, complex code\nbases that have undergone years of aggressive professional\nchecking. As one example, Chrome is tens of millions\nof lines of C++ code. Its dedicated professional team\nconstantly scans its source using a wide set of static\nand dynamic tools (which appears to be the set of any\ntool that works that they can get a copy of). Its code\nhas undergone 24/7 random ``fuzz'' testing on over 25,000\nmachines for the past several years. On top of all this,\nthey solicit bugs from anyone and pay cash bounties of\nhundreds to tens of thousands of dollars for any bug they\ndeem serious. As a result, the code has been picked clean\nof easily found bugs. Firefox has a similar process. SQLite\ngets the union of both since it is included in both Firefox\nand Chrome. I don't know of any other open-source projects\nthat have anywhere close to this aggressive an effort.\n\nII. A new approach to kernel dynamic checkers.\n\nIf an operating system hits a bug and crashes, tracking\ndown the root cause can easily take days. (It can also\ntake never.) Worse, if the OS hits a bug and does not\ncrash, but instead subtly corrupts state, or leaves one\nof the many many machine caches with a stale entry, the\nexpected value of finding this bug is ``good luck.''\nWhen it works, dynamic binary analysis tools can be a\ngood way to such bugs. It checks exactly what runs on\nthe machine, it has a complete accurate view into register\nand memory state, and by checking code that that runs on\nnative hardware (such as devices) it does not have to make\nfake versions of them.\n\nThe current state of the practice for dynamic tools\nis to use a dynamic translation (for code discovery)\nand then form of instruction emulation to determine an\ninstruction's effects. The code to do this can easily be\nover a hundred thousand lines of complex, difficult code\n(both to write and debug). One cascading effect of this\ncomplexity is that few dynamic tools run on kernel code.\n\nOur second major result is showing how to use common\ndebugging hardware support for single-step execution\nto make writing powerful dynamic tools easy --- often a\nfew hundred lines of code. Unlike most current tools,\nthese work well on kernel code. This novel ease makes\nit correspondingly easy to quickly build novel tools. We\npresent a number of unique tools based on this approach\nto precisely and immediately find kernel bugs extremely\ndifficult to track down without them.\n\nWe have written numerous checkers (examples include\nmemory corruption, concurrency, and that routines\nare bit-equivalent after patching or modification).\nWe have shown that the approach works on both ARM and\nRISC-V hardware. The approach is simple enough that we've\nhad hundreds of Stanford students students over the past\nfew years write their own implementations, typically in\nless than 6 hours. The labs for these classes can be\nseen in the open github repositories for 140e and 240lx.\n\nTwo examples:\n- dynamic race detection\nhttps://github.com/dddrrreee/cs240lx-22spr/tree/main/labs/16-eraser\n- memory corruption\nhttps://github.com/dddrrreee/cs240lx-22spr/tree/main/labs/11-memcheck-trap\n\n\n\n\n\n\t\t\t\t\tLast Modified: 05/09/2024\n\n\t\t\t\t\tSubmitted by: DawsonREngler\n"
 }
}