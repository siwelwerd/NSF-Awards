{
 "awd_id": "1931750",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "CPS: Medium: Secure Smart Machining",
 "cfda_num": "47.041",
 "org_code": "07030000",
 "po_phone": null,
 "po_email": "",
 "po_sign_block_name": "Bruce Kramer",
 "awd_eff_date": "2019-09-01",
 "awd_exp_date": "2023-08-31",
 "tot_intn_awd_amt": 1200000.0,
 "awd_amount": 1200000.0,
 "awd_min_amd_letter_date": "2019-08-20",
 "awd_max_amd_letter_date": "2019-08-20",
 "awd_abstract_narration": "Machining is software. Gcode, the programming language for machining tools such as milling machines, lathes, and plasma cutters, was developed in the late 1950s and remains the dominant language today. In the past 60 years, programming languages and software have changed and advanced tremendously, but Gcode remains mostly unchanged. This is true both for legacy systems as well as new ones, such as 3D printers. Machining pioneered cyber-physical systems but, from a computing perspective, remains half a century in the past. Enabling machine tools as modern, networked programming systems has the potential to revolutionize the $40B machining industry.\r\n\r\nThis research project will demonstrate new techniques that safely and securely improve machining automation, using new embedded operating systems, program analysis, secure code distribution, and user tools.  The research relies on three important principles: discretization, programmable safety, and end-to-end integrity with auditing. The first principle, discretization, is a method of program representation that greatly simplifies correctness checks and verifying invariants.  Rather than rely on implicit curves and geometric to define physical shapes, programs use an explicit, discretized representation defined by the desired machining precision. The second principle, programmable safety, allows quickly-changing software to have the same physical safety as traditional machining systems, by using high-assurance software that operates correctly even if the entire system crashes. Finally, end-to-end integrity and auditing allows operators to verify code before running it and allows the system to prove that programs executed correctly.\r\n\r\nThis award reflects NSF's statutory mission and has been deemed worthy of support through evaluation using the Foundation's intellectual merit and broader impacts review criteria.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "ENG",
 "org_dir_long_name": "Directorate for Engineering",
 "div_abbr": "CMMI",
 "org_div_long_name": "Division of Civil, Mechanical, and Manufacturing Innovation",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Philip",
   "pi_last_name": "Levis",
   "pi_mid_init": "A",
   "pi_sufx_name": "",
   "pi_full_name": "Philip A Levis",
   "pi_email_addr": "pal@cs.stanford.edu",
   "nsf_id": "000092250",
   "pi_start_date": "2019-08-20",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Dawson",
   "pi_last_name": "Engler",
   "pi_mid_init": "R",
   "pi_sufx_name": "",
   "pi_full_name": "Dawson R Engler",
   "pi_email_addr": "engler@csl.stanford.edu",
   "nsf_id": "000485661",
   "pi_start_date": "2019-08-20",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "David",
   "pi_last_name": "Mazi\u00e8res",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "David Mazi\u00e8res",
   "pi_email_addr": "dm-list-sup-nsf14@scs.stanford.edu",
   "nsf_id": "000100121",
   "pi_start_date": "2019-08-20",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Stanford University",
  "inst_street_address": "450 JANE STANFORD WAY",
  "inst_street_address_2": "",
  "inst_city_name": "STANFORD",
  "inst_state_code": "CA",
  "inst_state_name": "California",
  "inst_phone_num": "6507232300",
  "inst_zip_code": "943052004",
  "inst_country_name": "United States",
  "cong_dist_code": "16",
  "st_cong_dist_code": "CA16",
  "org_lgl_bus_name": "THE LELAND STANFORD JUNIOR UNIVERSITY",
  "org_prnt_uei_num": "",
  "org_uei_num": "HJD6G4D6TJY5"
 },
 "perf_inst": {
  "perf_inst_name": "Stanford University",
  "perf_str_addr": "353 Serra Mall, Gates Bldg",
  "perf_city_name": "Palo Alto",
  "perf_st_code": "CA",
  "perf_st_name": "California",
  "perf_zip_code": "943059025",
  "perf_ctry_code": "US",
  "perf_cong_dist": "16",
  "perf_st_cong_dist": "CA16",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "791800",
   "pgm_ele_name": "CPS-Cyber-Physical Systems"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "016Z",
   "pgm_ref_txt": "Cybermanufacturing Systems"
  },
  {
   "pgm_ref_code": "082E",
   "pgm_ref_txt": "MFG MACHINES & METROLOGY"
  },
  {
   "pgm_ref_code": "152E",
   "pgm_ref_txt": "Cyber-Physical Systems"
  },
  {
   "pgm_ref_code": "7924",
   "pgm_ref_txt": "MEDIUM PROJECT"
  },
  {
   "pgm_ref_code": "7943",
   "pgm_ref_txt": "PROGRAMMING LANGUAGES"
  },
  {
   "pgm_ref_code": "MANU",
   "pgm_ref_txt": "MANUFACTURING"
  }
 ],
 "app_fund": [
  {
   "app_code": "0119",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001920DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2019,
   "fund_oblg_amt": 1200000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Machining is software. \\gcode, a programming language for Computer Numerical Control (CNC) machines, was developed in the late 1950s, only a few years after FORTRAN.&nbsp; FORTRAN has been supplanted by LISP, C, Java, Python, SQL, and Rust.&nbsp; \\gcode, in contrast, remains the dominant CNC language today. This is true both for legacy systems as well as new ones, such as 3D printers. Machining pioneered<br />cyber-physical systems but, from an end-user perspective, remains half a century in the past.<br /><br />This project sought to advance machining software by applying modern&nbsp; computing techniques in programming, cryptography, and computer networking. It sought to do so through 3 key ideas:<br /><br />Discretization: rather than rely on implicit curves and geometric to define physical shapes, use an explicit, discretized representation defined by the machining precision (e.g., thousandths of an inch).<br /><br />Programmable safety: Machining has long depended on physical safety and security mechanisms such as<br />interlocks and fail-safe circuits. To address the new challenges introduced by quickly-changing software, physical processes are protected by high-assurance software.<br /><br />End-to-end integrity and auditing: Increasing automation requires increasing the assurance and<br />trustworthiness of machining systems, from verifying code will not pose a physical danger, to verifying machines are running that code to post-facto proving that the programs specified executed correctly.<br /><br />The COVID-19 pandemic began at the start of the project, and the shutdown of physical campus resources completely disrupted these initial research goals. To respond to this challenge, the project pivoted to focus on education and research which could be pursued without access to CNC machines. <br /><br />On the educational front, the PIs developed an complete new cyber-physical systems curriculum at Stanford, consisting of a series of 3 courses. These courses are small (40 students), as they involve <br />long, intense hands-on labs with instructors and require an application because interest is greater than availability. Students build up&nbsp; cyber-physical systems from the ground up, understanding low-level hardware and assembly programming, developing systems techniques for testing and debugging their systems to be extremely high assurance.<br /><br />On the research front, the PIs established two things. First, the Rust&nbsp; programming language allows developers to much more easily write high assurance software than C or assembly code. Second, this high assurance comes at a cost: Rust programs, when compiled, are often twice as large as their low assurance siblings written in other languages. For firmware in machining and other embedded systems, this size increase is a&nbsp; tremendous challenge, as these devices are often very limited in how much code can be installed on them. <br /><br />Based on this finding, the PIs developed a series of techniques that can reduce the size overhead of Rust from 100\\% to 48\\%, a 52\\% reduction. These advances allowed a team at Google to use Rust in the the hardware root-of-trust chip in Google Chromebooks, the tiny embedded processor that is the&nbsp; linchpin of all Chromebook security. This new, more secure, high assurance&nbsp; embedded firmware enabled by the project's research is now part of all standard Chromebook installations and runs on over<br />1 million Chromebooks. <br /><br />Students funded by this research have graduated and now work at Cruise, developing advanced, secure, high assurance firmware for autonomous vehicles.<br /><br /><br /></p><br>\n<p>\n Last Modified: 01/13/2024<br>\nModified by: Philip&nbsp;A&nbsp;Levis</p></div>\n<div class=\"porSideCol\"\n></div>\n</div>\n",
  "por_txt_cntn": "\n\nMachining is software. \\gcode, a programming language for Computer Numerical Control (CNC) machines, was developed in the late 1950s, only a few years after FORTRAN. FORTRAN has been supplanted by LISP, C, Java, Python, SQL, and Rust. \\gcode, in contrast, remains the dominant CNC language today. This is true both for legacy systems as well as new ones, such as 3D printers. Machining pioneered\ncyber-physical systems but, from an end-user perspective, remains half a century in the past.\n\nThis project sought to advance machining software by applying modern computing techniques in programming, cryptography, and computer networking. It sought to do so through 3 key ideas:\n\nDiscretization: rather than rely on implicit curves and geometric to define physical shapes, use an explicit, discretized representation defined by the machining precision (e.g., thousandths of an inch).\n\nProgrammable safety: Machining has long depended on physical safety and security mechanisms such as\ninterlocks and fail-safe circuits. To address the new challenges introduced by quickly-changing software, physical processes are protected by high-assurance software.\n\nEnd-to-end integrity and auditing: Increasing automation requires increasing the assurance and\ntrustworthiness of machining systems, from verifying code will not pose a physical danger, to verifying machines are running that code to post-facto proving that the programs specified executed correctly.\n\nThe COVID-19 pandemic began at the start of the project, and the shutdown of physical campus resources completely disrupted these initial research goals. To respond to this challenge, the project pivoted to focus on education and research which could be pursued without access to CNC machines. \n\nOn the educational front, the PIs developed an complete new cyber-physical systems curriculum at Stanford, consisting of a series of 3 courses. These courses are small (40 students), as they involve \nlong, intense hands-on labs with instructors and require an application because interest is greater than availability. Students build up cyber-physical systems from the ground up, understanding low-level hardware and assembly programming, developing systems techniques for testing and debugging their systems to be extremely high assurance.\n\nOn the research front, the PIs established two things. First, the Rust programming language allows developers to much more easily write high assurance software than C or assembly code. Second, this high assurance comes at a cost: Rust programs, when compiled, are often twice as large as their low assurance siblings written in other languages. For firmware in machining and other embedded systems, this size increase is a tremendous challenge, as these devices are often very limited in how much code can be installed on them. \n\nBased on this finding, the PIs developed a series of techniques that can reduce the size overhead of Rust from 100\\% to 48\\%, a 52\\% reduction. These advances allowed a team at Google to use Rust in the the hardware root-of-trust chip in Google Chromebooks, the tiny embedded processor that is the linchpin of all Chromebook security. This new, more secure, high assurance embedded firmware enabled by the project's research is now part of all standard Chromebook installations and runs on over\n1 million Chromebooks. \n\nStudents funded by this research have graduated and now work at Cruise, developing advanced, secure, high assurance firmware for autonomous vehicles.\n\n\n\t\t\t\t\tLast Modified: 01/13/2024\n\n\t\t\t\t\tSubmitted by: PhilipALevis\n"
 }
}