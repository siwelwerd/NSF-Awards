{
 "awd_id": "1846350",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "CAREER: Gradual Verification: From Scripting to Proving",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927885",
 "po_email": "abanerje@nsf.gov",
 "po_sign_block_name": "Anindya Banerjee",
 "awd_eff_date": "2019-02-01",
 "awd_exp_date": "2024-01-31",
 "tot_intn_awd_amt": 573376.0,
 "awd_amount": 573376.0,
 "awd_min_amd_letter_date": "2019-02-01",
 "awd_max_amd_letter_date": "2023-08-25",
 "awd_abstract_narration": "This project contributes theories, tools, and a pedagogical framework to close the gap between programming languages widely used in everyday programming tasks and the few verification-integrated languages that offer strong correctness guarantees. Inspired by two significant trends in programming language research, namely gradual types and theorem proving languages, this work synthesizes aspects of both to enable pathways to verified programming at every point along the spectrum from scripting languages to verification-integrated languages. The investigators develop a foundational theory of gradual verification, design and implement a general purpose language with integrated gradual verification, and devise pedagogical approaches to teaching verification to novice programmers. By making verification easier to use in a gradual way, developers will be more likely to make use of these techniques, bringing the known benefits of verification to more programmers. This project develops methods to teach gradual verification to beginner programmers and evaluates them in the new introductory programming sequence at University of Maryland.\r\n\r\nThis research supports software development practices that integrate verification at each step and removes impediments to fortified programming.  At the core of the technical approach is gradual verification, a technique that leverages run-time enforcement mechanisms and systematically turns these mechanisms in to static verification methods via abstract interpretation techniques. Moreover, due to the basis in run-time enforcement, verification becomes a spectrum rather than a binary, since properties that fail to statically validate can be enforced at run-time. This approach enables programs to evolve over time along a less- to more-verified gradient and opens up the possibility for a number of useful programming tools that are reinforcing, productive, and universal.\r\n\r\nThis award reflects NSF's statutory mission and has been deemed worthy of support through evaluation using the Foundation's intellectual merit and broader impacts review criteria.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "David",
   "pi_last_name": "Van Horn",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "David Van Horn",
   "pi_email_addr": "dvanhorn@cs.umd.edu",
   "nsf_id": "000572933",
   "pi_start_date": "2019-02-01",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Maryland, College Park",
  "inst_street_address": "3112 LEE BUILDING",
  "inst_street_address_2": "",
  "inst_city_name": "COLLEGE PARK",
  "inst_state_code": "MD",
  "inst_state_name": "Maryland",
  "inst_phone_num": "3014056269",
  "inst_zip_code": "207425100",
  "inst_country_name": "United States",
  "cong_dist_code": "04",
  "st_cong_dist_code": "MD04",
  "org_lgl_bus_name": "UNIVERSITY OF MARYLAND, COLLEGE PARK",
  "org_prnt_uei_num": "NPU8ULVAAS23",
  "org_uei_num": "NPU8ULVAAS23"
 },
 "perf_inst": {
  "perf_inst_name": "University of Maryland College Park",
  "perf_str_addr": "3112 Lee Bldg 7809 Regents Drive",
  "perf_city_name": "College Park",
  "perf_st_code": "MD",
  "perf_st_name": "Maryland",
  "perf_zip_code": "207423370",
  "perf_ctry_code": "US",
  "perf_cong_dist": "04",
  "perf_st_cong_dist": "MD04",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "1045",
   "pgm_ref_txt": "CAREER-Faculty Erly Career Dev"
  },
  {
   "pgm_ref_code": "8206",
   "pgm_ref_txt": "Formal Methods and Verification"
  }
 ],
 "app_fund": [
  {
   "app_code": "",
   "app_name": "",
   "app_symb_id": "",
   "fund_code": "01001920DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "",
   "app_name": "",
   "app_symb_id": "",
   "fund_code": "01002021DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "",
   "app_name": "",
   "app_symb_id": "",
   "fund_code": "01002122DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "",
   "app_name": "",
   "app_symb_id": "",
   "fund_code": "01002223DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "",
   "app_name": "",
   "app_symb_id": "",
   "fund_code": "01002324DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0120",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01002021DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2019,
   "fund_oblg_amt": 107907.0
  },
  {
   "fund_oblg_fiscal_yr": 2020,
   "fund_oblg_amt": 225739.0
  },
  {
   "fund_oblg_fiscal_yr": 2022,
   "fund_oblg_amt": 118057.0
  },
  {
   "fund_oblg_fiscal_yr": 2023,
   "fund_oblg_amt": 121673.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><div class=\"page\" title=\"Page 1\">\n<div class=\"layoutArea\">\n<div class=\"column\">\n<p><span>Today, programmers are using expressive, dynamically typed, higher-order functional and object-oriented programming languages for their everyday development tasks. Over the life of these programs, they are often fortified with static type checking by migrating programs using </span><span>gradual types</span><span>, a technique first developed in the research community, but now widely used by the largest industrial software development companies. Unfortunately, there are limits both to what properties gradual types can validate and the help they can provide programs as&nbsp;</span>they engage in the migration process. Researchers have developed sophisticated next generation programming languages with integrated verification features. These languages are able to validate much stronger claims about the correctness of software, but their industrial adoption has lagged far behind gradual typing. Consequently, verification is not being integrated in the everyday lives of programmers and the quality and reliability of software suffers because of it. This represents a tremendous missed opportunity considering the rapid advancement of automated verification techniques.</p>\n</div>\n</div>\n</div>\n<p>This project aimed to provide foundational theories, pragmatic tools, and a pedagogical framework for closing the expressivity gap between the everyday languages of programmers and these verification-integrated languages, enabling pathways to verified programming at every point along the spectrum scripting languages to theorem proving languages.</p>\n<p>The key outcomes of the work supported by the award are:</p>\n<ul>\n<li>the contribution of <em>gradual verification</em>&nbsp;as a way of incremental introducing program verification into programs using a combination of run-time checking mechanisms and abstract interpretation,</li>\n<li>a comprehensive development of the theory and pragmatics of gradual verification applied to behavioral software contracts,</li>\n<li>the introduction of termination checking as a run-time mechanism used for verifying the total correctness of gradually verified programs,</li>\n<li>novel approaches to software synthesis based on type-like program specifications,</li>\n<li>the development of memory-safe gradually typed variants of legacy programming languages such as C, and</li>\n<li>new approaches to automated gradual type migration based on type inference and the identification of important correctness criteria in the design of type migration tools.</li>\n</ul>\n<p>Collectively, these results advance an alternative vision for integrating verification into the practices of everyday programming.&nbsp; This approach enables programs to evolve over time from less- to more-verified gradient and opens up the possibility for a number of useful programming tools.</p><br>\n<p>\n Last Modified: 08/08/2024<br>\nModified by: David&nbsp;Van Horn</p></div>\n<div class=\"porSideCol\"\n></div>\n</div>\n",
  "por_txt_cntn": "\n\n\n\n\nToday, programmers are using expressive, dynamically typed, higher-order functional and object-oriented programming languages for their everyday development tasks. Over the life of these programs, they are often fortified with static type checking by migrating programs using gradual types, a technique first developed in the research community, but now widely used by the largest industrial software development companies. Unfortunately, there are limits both to what properties gradual types can validate and the help they can provide programs asthey engage in the migration process. Researchers have developed sophisticated next generation programming languages with integrated verification features. These languages are able to validate much stronger claims about the correctness of software, but their industrial adoption has lagged far behind gradual typing. Consequently, verification is not being integrated in the everyday lives of programmers and the quality and reliability of software suffers because of it. This represents a tremendous missed opportunity considering the rapid advancement of automated verification techniques.\n\n\n\n\n\nThis project aimed to provide foundational theories, pragmatic tools, and a pedagogical framework for closing the expressivity gap between the everyday languages of programmers and these verification-integrated languages, enabling pathways to verified programming at every point along the spectrum scripting languages to theorem proving languages.\n\n\nThe key outcomes of the work supported by the award are:\n\nthe contribution of gradual verificationas a way of incremental introducing program verification into programs using a combination of run-time checking mechanisms and abstract interpretation,\na comprehensive development of the theory and pragmatics of gradual verification applied to behavioral software contracts,\nthe introduction of termination checking as a run-time mechanism used for verifying the total correctness of gradually verified programs,\nnovel approaches to software synthesis based on type-like program specifications,\nthe development of memory-safe gradually typed variants of legacy programming languages such as C, and\nnew approaches to automated gradual type migration based on type inference and the identification of important correctness criteria in the design of type migration tools.\n\n\n\nCollectively, these results advance an alternative vision for integrating verification into the practices of everyday programming. This approach enables programs to evolve over time from less- to more-verified gradient and opens up the possibility for a number of useful programming tools.\t\t\t\t\tLast Modified: 08/08/2024\n\n\t\t\t\t\tSubmitted by: DavidVan Horn\n"
 }
}