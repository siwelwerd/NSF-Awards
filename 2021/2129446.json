{
 "awd_id": "2129446",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "Collaborative Research: SHF: Small: Feedback-Driven Mutation Testing for Any Language",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927841",
 "po_email": "sgreensp@nsf.gov",
 "po_sign_block_name": "Sol Greenspan",
 "awd_eff_date": "2021-09-01",
 "awd_exp_date": "2024-08-31",
 "tot_intn_awd_amt": 244487.0,
 "awd_amount": 244487.0,
 "awd_min_amd_letter_date": "2021-08-23",
 "awd_max_amd_letter_date": "2021-08-23",
 "awd_abstract_narration": "Testing, validation, and verification are all central activities in programming and software engineering. Unfortunately, existing techniques for testing remain inadequate for finding and eliminating key vulnerabilities before software deployment -- even the most critical modern software is rife with security vulnerabilities and defects that ultimately cost the economy billions of dollars annually in lost productivity and compromised data. A technique known as \"mutation testing\" has been researched since the 1970s; it aims to help software engineers improve their tests and their software at the same time, by automatically adding bugs to a program and checking whether the test suite can detect them. Although in theory this technique is extremely effective for improving software quality, there are several fundamental factors that prevent it from being widely used in practice: it is difficult and time-consuming to use, and the tools that exist for it cannot all handle the diversity of program languages that are deployed in modern software systems. This project will tackle these challenges and allow this important technique to be used to improve quality of real-world software by developing efficient tools that can apply mutation testing to programs written in any language; prioritize the output of the tools to reduce the amount of time and effort needed to make maximal use of them; and incorporate user feedback into the technique to maximize testing efficiency. The project will be evaluated on real-world open source software like the Linux kernel, and build on the researchers' previous collaborations to substantially improve program and test effort quality on critical real-world software.\r\n\r\nThe core problem this project aims to address is making program mutants practical in nonresearch settings, in a way that meets the needs of developers and test engineers, by making it possible for someone creating or enhancing a test suite, or developing code and test suite in tandem, to (1) use \"just enough\" mutation testing for their needs, maximizing benefit gained in exchange for work performed, and (2) to work in any programming language without worrying about the quality of tool support provided for mutation testing, and without sacrificing the ease of understanding of source-based mutants, while easily adding custom mutation operators that target their specific software development task. This project aims to adapt the Furthest-Point-First metric previously used in fuzzer bug triaging to the problem of maximizing the novelty of mutants examined by a user, in order to make it possible to quickly discover unkilled mutants that expose serious defects in a testing or verification effort. However, novelty alone is not sufficient: feedback-driven mutation testing must also help users avoid inconsequential, equivalent mutants, kill mutants high in the dominance hierarchy, and (most importantly) incorporate user feedback.  If a user marks a mutant as inconsequential, or equivalent, or (especially) high impact, then that information must be used to inform the ranking of future mutants as well. In order to make such an approach maximally valuable, this project also proposes to improve the state-of-the-art in source-level multilingual mutant generation, allowing users to easily generate mutants for new programming languages, or even for custom DSLs that are part of a specific project.\r\n\r\nThis award reflects NSF's statutory mission and has been deemed worthy of support through evaluation using the Foundation's intellectual merit and broader impacts review criteria.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Alex",
   "pi_last_name": "Groce",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Alex Groce",
   "pi_email_addr": "alex.groce@nau.edu",
   "nsf_id": "000733966",
   "pi_start_date": "2021-08-23",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Northern Arizona University",
  "inst_street_address": "601 S KNOLES DR RM 220",
  "inst_street_address_2": "",
  "inst_city_name": "FLAGSTAFF",
  "inst_state_code": "AZ",
  "inst_state_name": "Arizona",
  "inst_phone_num": "9285230886",
  "inst_zip_code": "86011",
  "inst_country_name": "United States",
  "cong_dist_code": "02",
  "st_cong_dist_code": "AZ02",
  "org_lgl_bus_name": "NORTHERN ARIZONA UNIVERSITY",
  "org_prnt_uei_num": "",
  "org_uei_num": "MXHAS3AKPRN1"
 },
 "perf_inst": {
  "perf_inst_name": "Northern Arizona University",
  "perf_str_addr": "1295 S Knoles Dr",
  "perf_city_name": "Flagstaff",
  "perf_st_code": "AZ",
  "perf_st_name": "Arizona",
  "perf_zip_code": "860110001",
  "perf_ctry_code": "US",
  "perf_cong_dist": "02",
  "perf_st_cong_dist": "AZ02",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7942",
   "pgm_ref_txt": "HIGH-PERFORMANCE COMPUTING"
  },
  {
   "pgm_ref_code": "7944",
   "pgm_ref_txt": "SOFTWARE ENG & FORMAL METHODS"
  }
 ],
 "app_fund": [
  {
   "app_code": "0121",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01002122DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2021,
   "fund_oblg_amt": 244487.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Mutation testing is a method for determining if a software system's test are actually capable of effectively finding bugs in the system.&nbsp; Long a theoretically powerful but seldom used tool, it has finally recently been adopted by leading software companies as a practical way to make tests more effective.&nbsp; Tests are the first and most important defense against software bugs that can impose increasingly large costs on the public or individuals, as software grows in importance in every facet of everyday life.&nbsp; Mutants address the problem of determining whether tests can detect bugs in the most direct way:&nbsp; mutants are synthetic bugs, and tests that cannot find \"fake\" bugs are unlikely to work well for real bugs.</p>\r\n<p><br />This project focused on making mutation testing practical outside the most well-resourced companies, and advanced the state-of-the-art in multiple ways.&nbsp; First, we used parser-parser combinators and \"universal language\" techniques to make mutation testing available in an open source tool for any programming language.&nbsp; Second, we showed how to use modern machine learning to rapidly predict which mutants a test will detect, making it much more practical to apply.</p>\r\n<p><br />We also contributed to the fundamental science of how to interpret mutation testing results, and how to combine them with other measures of test effectiveness to most intelligently allocate testing resources.</p>\r\n<p><br />Finally, while mutation testing is most frequently used to evaluate and improve existing tests (by showing what they are missing) we demonstrated that the same techniques can improve test generation, directly using mutants without human intervention to find subtle bugs.&nbsp; In particular, one application of this idea, embodied in an open source tool (like the mutant generation approach described above) makes it possible to find very subtle bugs in compilers, which are arguably the most sophisticated part of the ecosystem of modern programming environments.</p><br>\n<p>\n Last Modified: 12/18/2024<br>\nModified by: Alex&nbsp;Groce</p></div>\n<div class=\"porSideCol\"\n></div>\n</div>\n",
  "por_txt_cntn": "\n\nMutation testing is a method for determining if a software system's test are actually capable of effectively finding bugs in the system. Long a theoretically powerful but seldom used tool, it has finally recently been adopted by leading software companies as a practical way to make tests more effective. Tests are the first and most important defense against software bugs that can impose increasingly large costs on the public or individuals, as software grows in importance in every facet of everyday life. Mutants address the problem of determining whether tests can detect bugs in the most direct way: mutants are synthetic bugs, and tests that cannot find \"fake\" bugs are unlikely to work well for real bugs.\r\n\n\n\nThis project focused on making mutation testing practical outside the most well-resourced companies, and advanced the state-of-the-art in multiple ways. First, we used parser-parser combinators and \"universal language\" techniques to make mutation testing available in an open source tool for any programming language. Second, we showed how to use modern machine learning to rapidly predict which mutants a test will detect, making it much more practical to apply.\r\n\n\n\nWe also contributed to the fundamental science of how to interpret mutation testing results, and how to combine them with other measures of test effectiveness to most intelligently allocate testing resources.\r\n\n\n\nFinally, while mutation testing is most frequently used to evaluate and improve existing tests (by showing what they are missing) we demonstrated that the same techniques can improve test generation, directly using mutants without human intervention to find subtle bugs. In particular, one application of this idea, embodied in an open source tool (like the mutant generation approach described above) makes it possible to find very subtle bugs in compilers, which are arguably the most sophisticated part of the ecosystem of modern programming environments.\t\t\t\t\tLast Modified: 12/18/2024\n\n\t\t\t\t\tSubmitted by: AlexGroce\n"
 }
}