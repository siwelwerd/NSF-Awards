{
 "awd_id": "2115865",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "CAREER: Program Analysis and Transformations for Asynchrony",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927841",
 "po_email": "sgreensp@nsf.gov",
 "po_sign_block_name": "Sol Greenspan",
 "awd_eff_date": "2020-10-01",
 "awd_exp_date": "2022-03-31",
 "tot_intn_awd_amt": 520796.0,
 "awd_amount": 128884.0,
 "awd_min_amd_letter_date": "2021-01-28",
 "awd_max_amd_letter_date": "2021-01-28",
 "awd_abstract_narration": "Asynchronous programming is in demand today because responsiveness is\r\nimportant on all modern devices: desktop, mobile, or web. Asynchronous\r\nprogramming is especially important in mobile and wearable apps, which\r\nare expected by 2016 to reach 300 billion downloads annually. One\r\ncontemporary development task is refactoring long-running, blocking\r\nsynchronous code (e.g., accessing the web, database, or file system)\r\ninto non-blocking asynchronous code. While major programming languages\r\nmake asynchrony possible, they do not make it easy.\r\n\r\nThis proposal aims to significantly enrich educational resources and\r\nprogrammers? toolset for adding, modernizing, tuning, and suggesting\r\nasynchrony. The PI plans to pursue research activities in four areas:\r\n(1) Mining and recommending refactorings; (2) Automated refactorings for\r\nadding asynchrony into mobile apps, for modernizing legacy asynchronous\r\ncode, and for converting between async variants; (3) Detecting and\r\nfixing async errors; (4) Extending async refactorings to other domains,\r\nwith the intent of discovering theories and reusable principles.\r\nThis project has the potential to revolutionize how mobile app\r\nprogrammers use asynchrony, to educate them about successful usage of\r\nasynchrony, and to significantly reduce the cost and increase the\r\nquality of their code.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Daniel",
   "pi_last_name": "Dig",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Daniel Dig",
   "pi_email_addr": "danny.dig@colorado.edu",
   "nsf_id": "000581803",
   "pi_start_date": "2021-01-28",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Colorado at Boulder",
  "inst_street_address": "3100 MARINE ST",
  "inst_street_address_2": "STE 481 572 UCB",
  "inst_city_name": "Boulder",
  "inst_state_code": "CO",
  "inst_state_name": "Colorado",
  "inst_phone_num": "3034926221",
  "inst_zip_code": "803090001",
  "inst_country_name": "United States",
  "cong_dist_code": "02",
  "st_cong_dist_code": "CO02",
  "org_lgl_bus_name": "THE REGENTS OF THE UNIVERSITY OF COLORADO",
  "org_prnt_uei_num": "",
  "org_uei_num": "SPVKK1RC2MZ3"
 },
 "perf_inst": {
  "perf_inst_name": "University of Colorado at Boulder",
  "perf_str_addr": "",
  "perf_city_name": "",
  "perf_st_code": "CO",
  "perf_st_name": "Colorado",
  "perf_zip_code": "803031058",
  "perf_ctry_code": "US",
  "perf_cong_dist": "02",
  "perf_st_cong_dist": "CO02",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "1045",
   "pgm_ref_txt": "CAREER-Faculty Erly Career Dev"
  },
  {
   "pgm_ref_code": "7944",
   "pgm_ref_txt": "SOFTWARE ENG & FORMAL METHODS"
  }
 ],
 "app_fund": [
  {
   "app_code": "0119",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001920DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0120",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01002021DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2019,
   "fund_oblg_amt": 17808.0
  },
  {
   "fund_oblg_fiscal_yr": 2020,
   "fund_oblg_amt": 111076.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Software constantly changes. Most programmers work on projects that they did not start. Most companies spend more on maintaining old systems than on building new ones. It is widely known that at least two-thirds of software costs are due to evolution, with some industrial surveys claiming 90%. This is good, because it is a sign that we build software that is worth keeping. But it means that the traditional view of software development is wrong. Software development is not about the conversion of user requirements into&nbsp;<em>new software&nbsp;</em>as much as it is about responding to user needs by changing&nbsp;<em>existing software</em>. Change is the heart of software development.&nbsp;</p>\n<p>An important kind of change during software development is refactoring. Refactoring is a program transformation that improves the internal code quality.&nbsp;&nbsp;One example of contemporary development task is refactoring long-running, blocking synchronous code (e.g., accessing the web, database, or file system) into non-blocking asynchronous code so that the application remains responsive.</p>\n<p>Although change is the heart of software development, programmers have difficulty managing change. Change is too ad-hoc and tools for change are too low-level, making programming expensive and error-prone. Change needs to move to a higher level of abstraction. Doing so could make programmers more productive and software more reliable.&nbsp;</p>\n<p>To turn our vision into reality, this project developed a rich toolset and theories that addressed four key challenges related to refactoring:&nbsp;</p>\n<p>(1) Mining and recommending refactorings. We posed and tested hypotheses related to where and how developers are refactoring by applying data mining to a large corpus of code repositories. We distilled this knowledge into usable recommendations about locations where programmers should refactor.&nbsp;</p>\n<p>(2) Automated refactorings. Grounded on empirical studies of open-source projects, we automated several sophisticated program analyses and transformations for refactoring. We designed, implemented, and evaluated several program analyses that are the pillars of refactoring.&nbsp;</p>\n<p>(3) Detecting and fixing erroneous usage of programming constructs. We designed, implemented, and evaluated several static analyses for detecting misused programming constructs that cause semantic errors or hurt performance.&nbsp;</p>\n<p>(4) Extending refactorings to other domains. We investigated how analyses and transformations for refactoring from one domain (e.g., enterprise software) are useful in new domains such as ML-based software. By studying several domain-specific refactorings, we discovered theories and reusable principles.&nbsp;</p>\n<p>&nbsp;The grant partially supported 19 top-conference and journal papers (of which 5 papers received awards), the public release of more than a dozen refactoring tools and datasets (available from the PI?s webpage), and training for more than 8 graduate students (some joining industry, others joining the faculty at leading universities like CMU), and five undergrad students. Two of the lead student researchers working on this project have won the first and second prize, respectively, at the top ACM Student Research Competition, in the grad section.</p>\n<p>To increase the broader impacts, using our&nbsp;tools developed as part of this research, we found and reported hundreds of performance bugs in real world open-source projects. Our refactoring contributions improved&nbsp;performance of previously highly-tuned, best in class software for big data processing (e.g., Apache Cassandra), that are used by every Fortune-100 company.&nbsp;</p>\n<p>Moreover, our collaboration with Google researchers led to a novel process for applying refactorings in ultra-large software codebases such as the ones at Google, where conventional refactoring automation techniques do not work.&nbsp;</p>\n<p>Our rich&nbsp;educational resources such as https://mlcodepatterns.github.io&nbsp;provide tremendous education on best practices for evolving and refactoring ML code-bases. We have been working with industry partners to promote such best practices from open-source repositories into the company's proprietary code.&nbsp;</p>\n<p>In addition to developing university classes based on this material, the PI taught hundreds of professional programmers at summer schools, conference tutorials, and technical courses at large companies. The PI and the student researchers disseminated the results by presentations at academic and industry conferences, keynotes, the ACM SIGSOFT monthly webinar, internships and full-time employment in industry.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 05/31/2022<br>\n\t\t\t\t\tModified by: Daniel&nbsp;Dig</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nSoftware constantly changes. Most programmers work on projects that they did not start. Most companies spend more on maintaining old systems than on building new ones. It is widely known that at least two-thirds of software costs are due to evolution, with some industrial surveys claiming 90%. This is good, because it is a sign that we build software that is worth keeping. But it means that the traditional view of software development is wrong. Software development is not about the conversion of user requirements into new software as much as it is about responding to user needs by changing existing software. Change is the heart of software development. \n\nAn important kind of change during software development is refactoring. Refactoring is a program transformation that improves the internal code quality.  One example of contemporary development task is refactoring long-running, blocking synchronous code (e.g., accessing the web, database, or file system) into non-blocking asynchronous code so that the application remains responsive.\n\nAlthough change is the heart of software development, programmers have difficulty managing change. Change is too ad-hoc and tools for change are too low-level, making programming expensive and error-prone. Change needs to move to a higher level of abstraction. Doing so could make programmers more productive and software more reliable. \n\nTo turn our vision into reality, this project developed a rich toolset and theories that addressed four key challenges related to refactoring: \n\n(1) Mining and recommending refactorings. We posed and tested hypotheses related to where and how developers are refactoring by applying data mining to a large corpus of code repositories. We distilled this knowledge into usable recommendations about locations where programmers should refactor. \n\n(2) Automated refactorings. Grounded on empirical studies of open-source projects, we automated several sophisticated program analyses and transformations for refactoring. We designed, implemented, and evaluated several program analyses that are the pillars of refactoring. \n\n(3) Detecting and fixing erroneous usage of programming constructs. We designed, implemented, and evaluated several static analyses for detecting misused programming constructs that cause semantic errors or hurt performance. \n\n(4) Extending refactorings to other domains. We investigated how analyses and transformations for refactoring from one domain (e.g., enterprise software) are useful in new domains such as ML-based software. By studying several domain-specific refactorings, we discovered theories and reusable principles. \n\n The grant partially supported 19 top-conference and journal papers (of which 5 papers received awards), the public release of more than a dozen refactoring tools and datasets (available from the PI?s webpage), and training for more than 8 graduate students (some joining industry, others joining the faculty at leading universities like CMU), and five undergrad students. Two of the lead student researchers working on this project have won the first and second prize, respectively, at the top ACM Student Research Competition, in the grad section.\n\nTo increase the broader impacts, using our tools developed as part of this research, we found and reported hundreds of performance bugs in real world open-source projects. Our refactoring contributions improved performance of previously highly-tuned, best in class software for big data processing (e.g., Apache Cassandra), that are used by every Fortune-100 company. \n\nMoreover, our collaboration with Google researchers led to a novel process for applying refactorings in ultra-large software codebases such as the ones at Google, where conventional refactoring automation techniques do not work. \n\nOur rich educational resources such as https://mlcodepatterns.github.io provide tremendous education on best practices for evolving and refactoring ML code-bases. We have been working with industry partners to promote such best practices from open-source repositories into the company's proprietary code. \n\nIn addition to developing university classes based on this material, the PI taught hundreds of professional programmers at summer schools, conference tutorials, and technical courses at large companies. The PI and the student researchers disseminated the results by presentations at academic and industry conferences, keynotes, the ACM SIGSOFT monthly webinar, internships and full-time employment in industry.\n\n\t\t\t\t\tLast Modified: 05/31/2022\n\n\t\t\t\t\tSubmitted by: Daniel Dig"
 }
}