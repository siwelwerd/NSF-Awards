{
 "awd_id": "2106559",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "SHF: Medium: Formally Verified Compilation of Probabilistic Programs",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032922585",
 "po_email": "pprabhak@nsf.gov",
 "po_sign_block_name": "Pavithra Prabhakar",
 "awd_eff_date": "2021-05-01",
 "awd_exp_date": "2023-06-30",
 "tot_intn_awd_amt": 963189.0,
 "awd_amount": 192040.0,
 "awd_min_amd_letter_date": "2021-04-08",
 "awd_max_amd_letter_date": "2023-07-17",
 "awd_abstract_narration": "Artificial intelligence is becoming an integral part of society, and is poised to affect increasingly many aspects of life.  Like any other software, artificial-intelligence applications can have errors with potentially serious consequences. As a result, improving the quality of artificial-intelligence software is a critical challenge. One promising technology for addressing this challenge is the use of probabilistic programming languages, which let programmers implement artificial-intelligence applications in a simpler and safer way. The focus of this project is to develop techniques and tools to transform probabilistic programs into code executable on a computer. More specifically, the aim is to understand how to make such tools free of errors while being as efficient as possible.\r\n\r\nThis project develops a verified compiler and runtime for the Stan probabilistic programming language. The compiler is developed in the Coq proof assistant, and connects to CompCert, an existing verified compiler for C programs.  Programs written in Stan will be compiled to CompCert C through a succession of transformations, each of which handles a specific feature of Stan. These program transformations are specific to probabilistic programming languages, and include truncating distributions and re-parameterizing to support constraints on random variables.  The runtime implements a Markov Chain Monte Carlo algorithm that uses the compiled program to perform inference.  The formal proof defines the semantics of the Stan program as a probability measure and shows that the compiled program asymptotically generates samples from this measure.\r\n\r\nThis award reflects NSF's statutory mission and has been deemed worthy of support through evaluation using the Foundation's intellectual merit and broader impacts review criteria.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Jean-Baptiste",
   "pi_last_name": "Tristan",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Jean-Baptiste Tristan",
   "pi_email_addr": "tristanj@bc.edu",
   "nsf_id": "000834801",
   "pi_start_date": "2021-04-08",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Joseph",
   "pi_last_name": "Tassarotti",
   "pi_mid_init": "D",
   "pi_sufx_name": "",
   "pi_full_name": "Joseph D Tassarotti",
   "pi_email_addr": "jt4767@nyu.edu",
   "nsf_id": "000810613",
   "pi_start_date": "2021-04-08",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Boston College",
  "inst_street_address": "140 COMMONWEALTH AVE",
  "inst_street_address_2": "",
  "inst_city_name": "CHESTNUT HILL",
  "inst_state_code": "MA",
  "inst_state_name": "Massachusetts",
  "inst_phone_num": "6175528000",
  "inst_zip_code": "024673800",
  "inst_country_name": "United States",
  "cong_dist_code": "04",
  "st_cong_dist_code": "MA04",
  "org_lgl_bus_name": "TRUSTEES OF BOSTON COLLEGE",
  "org_prnt_uei_num": "",
  "org_uei_num": "MJ3JH8CRJBZ7"
 },
 "perf_inst": {
  "perf_inst_name": "Boston College",
  "perf_str_addr": "",
  "perf_city_name": "Chestnut Hill",
  "perf_st_code": "MA",
  "perf_st_name": "Massachusetts",
  "perf_zip_code": "021287000",
  "perf_ctry_code": "US",
  "perf_cong_dist": "07",
  "perf_st_cong_dist": "MA07",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7924",
   "pgm_ref_txt": "MEDIUM PROJECT"
  },
  {
   "pgm_ref_code": "7943",
   "pgm_ref_txt": "PROGRAMMING LANGUAGES"
  }
 ],
 "app_fund": [
  {
   "app_code": "",
   "app_name": "",
   "app_symb_id": "",
   "fund_code": "01002122DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "",
   "app_name": "",
   "app_symb_id": "",
   "fund_code": "01002324DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "",
   "app_name": "",
   "app_symb_id": "",
   "fund_code": "01002425DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2021,
   "fund_oblg_amt": 192039.0
  },
  {
   "fund_oblg_fiscal_yr": 2023,
   "fund_oblg_amt": 0.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Probabilistic programming languages are specialized programming languages that allow users to describe statistical models as computer programs. Such probabilistic programs are used in machine learning, data science, and statistics to perform statistical inference and obtain insights from data. To convert programs written in a programming language into a form that can be executed on a computer, programmers use software called compilers that carry out this conversion. In the case of probabilistic programming languages, a compiler converts a program into an executable that can be run to perform statistical inference.</p>\n<p><br />Like other kinds of software, compilers can have bugs. When bugs occur in a compiler, the executables that the compiler produces may run incorrectly and generate output that has errors. For probabilistic programming languages,&nbsp; this means that compiler bugs can lead to incorrect statistical analyses. To reduce or prevent bugs in software, researchers have developed a set of techniques called formal verification, in which one carries out a mathematical analysis to prove that a certain class of bugs is absent from a program.</p>\n<p><br />This project developed and then applied formal verification techniques to a compiler for a probabilistic programming language called Stan. Specifically, this project implemented a new compiler for a subset of Stan inside of Coq. Coq is a specialized software system called a proof assistant in which one can write programs and then state and prove properties of those programs. Using Coq, we also wrote down a semantics for Stan, that is, a description of how Stan programs should behave. This semantics captured that these programs describe a probability distribution that represents a statistical model. This formal semantics allows one to state what it means for the compiler to be correct. Namely, that it ought to preserve the semantics of programs, meaning that the output of the compiler should represent or compute the same probability distribution as the input.</p>\n<p><br />Using this semantics, we stated and proved the correctness of three critical stages (called \"passes\") in part of the compiler. These passes are part of what is called the density compiler, which converts the Stan program into code that can calculate probabilities associated with the statistical model that the program represents.</p>\n<p><br />We focused on these three passes because they involve transformations that are quite different from ones that a compiler for a non-probabilistic programming language does. Proving that they are correct requires accounting for the probabilistic semantics that the programs have. The project developed new techniques to be able to prove that these transformations were correct. In the course of carrying out these proofs, we found an error in the Stan language reference manual related to the behavior of one of the passes that we verified.</p>\n<p><br />The results of this project were described in a publication in Programming Language Design and Implementation, and the source code for the Coq development was published in an open source artifact.</p>\n<p>&nbsp;</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 10/16/2023<br>\n\t\t\t\t\tModified by: Joseph&nbsp;D&nbsp;Tassarotti</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nProbabilistic programming languages are specialized programming languages that allow users to describe statistical models as computer programs. Such probabilistic programs are used in machine learning, data science, and statistics to perform statistical inference and obtain insights from data. To convert programs written in a programming language into a form that can be executed on a computer, programmers use software called compilers that carry out this conversion. In the case of probabilistic programming languages, a compiler converts a program into an executable that can be run to perform statistical inference.\n\n\nLike other kinds of software, compilers can have bugs. When bugs occur in a compiler, the executables that the compiler produces may run incorrectly and generate output that has errors. For probabilistic programming languages,  this means that compiler bugs can lead to incorrect statistical analyses. To reduce or prevent bugs in software, researchers have developed a set of techniques called formal verification, in which one carries out a mathematical analysis to prove that a certain class of bugs is absent from a program.\n\n\nThis project developed and then applied formal verification techniques to a compiler for a probabilistic programming language called Stan. Specifically, this project implemented a new compiler for a subset of Stan inside of Coq. Coq is a specialized software system called a proof assistant in which one can write programs and then state and prove properties of those programs. Using Coq, we also wrote down a semantics for Stan, that is, a description of how Stan programs should behave. This semantics captured that these programs describe a probability distribution that represents a statistical model. This formal semantics allows one to state what it means for the compiler to be correct. Namely, that it ought to preserve the semantics of programs, meaning that the output of the compiler should represent or compute the same probability distribution as the input.\n\n\nUsing this semantics, we stated and proved the correctness of three critical stages (called \"passes\") in part of the compiler. These passes are part of what is called the density compiler, which converts the Stan program into code that can calculate probabilities associated with the statistical model that the program represents.\n\n\nWe focused on these three passes because they involve transformations that are quite different from ones that a compiler for a non-probabilistic programming language does. Proving that they are correct requires accounting for the probabilistic semantics that the programs have. The project developed new techniques to be able to prove that these transformations were correct. In the course of carrying out these proofs, we found an error in the Stan language reference manual related to the behavior of one of the passes that we verified.\n\n\nThe results of this project were described in a publication in Programming Language Design and Implementation, and the source code for the Coq development was published in an open source artifact.\n\n \n\n\t\t\t\t\tLast Modified: 10/16/2023\n\n\t\t\t\t\tSubmitted by: Joseph D Tassarotti"
 }
}