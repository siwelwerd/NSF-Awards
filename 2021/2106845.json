{
 "awd_id": "2106845",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "Collaborative Resaerch: SHF: Medium: Ensuring Safety and Liveness of Modern Systems through Dynamic Temporal Analysiss",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927885",
 "po_email": "abanerje@nsf.gov",
 "po_sign_block_name": "Anindya Banerjee",
 "awd_eff_date": "2021-07-15",
 "awd_exp_date": "2024-06-30",
 "tot_intn_awd_amt": 399997.0,
 "awd_amount": 399997.0,
 "awd_min_amd_letter_date": "2021-07-08",
 "awd_max_amd_letter_date": "2023-07-05",
 "awd_abstract_narration": "Reactive/interactive systems such as web applications and servers, real-time video streaming software, and IoT platforms are deeply embedded into all aspects of the modern world. Many program-analysis techniques and tools have been created to analyze important temporal properties of these systems that span both safety (\"nothing bad will happen\") and liveness (\"something good eventually happens\"). Unfortunately, modern static analyses are still limited in handling complex program semantics that often appear in many real-world applications: they support only simple properties, produce false positives, or do not scale to large programs. Recent dynamic or \"data-driven\" approaches address several shortcomings of static analyses to analyze more complex program properties more efficiently, yet sometimes yield incorrect results. The project's novelties are the theoretical and practical integration of static and dynamic approaches to analyze, localize, and repair temporal aspects of reactive/interactive systems. The project's impacts are the development of new theories and algorithms, giving rise to advanced methods for ensuring the safety/liveness of today's reactive/interactive software.\r\n\r\nToday's software involves complex non-linear behavior, heap manipulations, and higher-order features. The project's use of dynamic analysis enables inference of expressive properties of these programs, while the use of static verification allows for validation of those inferred properties. Furthermore, static verification and dynamic learning mutually inform and bolster the power of each other, allowing for safety/liveness analyses, and even for the localization of faults and synthesis of repairs for temporal defects. The methods being developed are embodied in a growing collection of automated tools to be released publicly. The results of the research are used to develop new courses, senior design projects, and an interactive Jupyter book in programming languages and software engineering. The project broadens participation through several initiatives, aimed at middle/high school students and undergraduate students from underrepresented groups in the investigators' local communities.\r\n\r\nThis award reflects NSF's statutory mission and has been deemed worthy of support through evaluation using the Foundation's intellectual merit and broader impacts review criteria.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Timoleon",
   "pi_last_name": "Antonopoulos",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Timoleon Antonopoulos",
   "pi_email_addr": "timos.antonopoulos@yale.edu",
   "nsf_id": "000841910",
   "pi_start_date": "2021-07-08",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Yale University",
  "inst_street_address": "150 MUNSON ST",
  "inst_street_address_2": "",
  "inst_city_name": "NEW HAVEN",
  "inst_state_code": "CT",
  "inst_state_name": "Connecticut",
  "inst_phone_num": "2037854689",
  "inst_zip_code": "065113572",
  "inst_country_name": "United States",
  "cong_dist_code": "03",
  "st_cong_dist_code": "CT03",
  "org_lgl_bus_name": "YALE UNIV",
  "org_prnt_uei_num": "FL6GV84CKN57",
  "org_uei_num": "FL6GV84CKN57"
 },
 "perf_inst": {
  "perf_inst_name": "Yale University",
  "perf_str_addr": "51 Prospect Street",
  "perf_city_name": "New Haven",
  "perf_st_code": "CT",
  "perf_st_name": "Connecticut",
  "perf_zip_code": "065118937",
  "perf_ctry_code": "US",
  "perf_cong_dist": "03",
  "perf_st_cong_dist": "CT03",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7924",
   "pgm_ref_txt": "MEDIUM PROJECT"
  },
  {
   "pgm_ref_code": "7943",
   "pgm_ref_txt": "PROGRAMMING LANGUAGES"
  }
 ],
 "app_fund": [
  {
   "app_code": "",
   "app_name": "",
   "app_symb_id": "",
   "fund_code": "01002122DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "",
   "app_name": "",
   "app_symb_id": "",
   "fund_code": "01002324DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2021,
   "fund_oblg_amt": 262793.0
  },
  {
   "fund_oblg_fiscal_yr": 2023,
   "fund_oblg_amt": 137204.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Software is now pervasive and impacts many crucial aspects of modern life, ranging from human implant devices to autonomous vehicles to air traffic control systems. In these contexts it is essential that software operate reliably and researchers have thus sought methods for mathematically proving the correctness of computer code. Despite decades of progress, these techniques are still limited in applicability and impact. One reason is that existing techniques have focused on only what can be learned through analysis of the program (so-called \"static analysis\"), and have not incorporated what can be learned from example executions of the program (\"dynamic\" analysis).</p>\r\n<p><br />This project studied how static and dynamic analyses can complement and inform each other to create novel algorithms for program analysis. By combining the strengths of the two approaches, the research improved verification and reliability of software systems in domains such as termination, temporal properties of programs, heap-manipulating programs, higher-order constructs, fault localization, and automated program repair. The project has also advanced the use of dynamic learning for inferring complex program properties, including numerical invariants and recurrent relations for reasoning program complexity. These techniques and results have been applied to diverse domains, including verifying safety properties in neural networks, optimizing cryptographic protocols, and improving automated program repair.</p>\r\n<p><br />The project has produced publicly available open-source tools, benchmark suites and conference publications describing the research results. The project also impacted educational and outreach activities. Interactive learning materials were developed to encourage students to explore formal methods. Research results and materials were integrated into a summer program to encourage underrepresented students to pursue STEM studies. Finally, female and underrepresented minority students at both undergraduate and graduate levels were mentored and contributed to the project.</p><br>\n<p>\n Last Modified: 12/11/2024<br>\nModified by: Timoleon&nbsp;Antonopoulos</p></div>\n<div class=\"porSideCol\"\n></div>\n</div>\n",
  "por_txt_cntn": "\n\nSoftware is now pervasive and impacts many crucial aspects of modern life, ranging from human implant devices to autonomous vehicles to air traffic control systems. In these contexts it is essential that software operate reliably and researchers have thus sought methods for mathematically proving the correctness of computer code. Despite decades of progress, these techniques are still limited in applicability and impact. One reason is that existing techniques have focused on only what can be learned through analysis of the program (so-called \"static analysis\"), and have not incorporated what can be learned from example executions of the program (\"dynamic\" analysis).\r\n\n\n\nThis project studied how static and dynamic analyses can complement and inform each other to create novel algorithms for program analysis. By combining the strengths of the two approaches, the research improved verification and reliability of software systems in domains such as termination, temporal properties of programs, heap-manipulating programs, higher-order constructs, fault localization, and automated program repair. The project has also advanced the use of dynamic learning for inferring complex program properties, including numerical invariants and recurrent relations for reasoning program complexity. These techniques and results have been applied to diverse domains, including verifying safety properties in neural networks, optimizing cryptographic protocols, and improving automated program repair.\r\n\n\n\nThe project has produced publicly available open-source tools, benchmark suites and conference publications describing the research results. The project also impacted educational and outreach activities. Interactive learning materials were developed to encourage students to explore formal methods. Research results and materials were integrated into a summer program to encourage underrepresented students to pursue STEM studies. Finally, female and underrepresented minority students at both undergraduate and graduate levels were mentored and contributed to the project.\t\t\t\t\tLast Modified: 12/11/2024\n\n\t\t\t\t\tSubmitted by: TimoleonAntonopoulos\n"
 }
}