{
 "awd_id": "1512611",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Medium: Fiat: Correct-by-Construction and Mostly Automated Derivation of Programs with an Interactive Theorem Prover",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927885",
 "po_email": "abanerje@nsf.gov",
 "po_sign_block_name": "Anindya Banerjee",
 "awd_eff_date": "2015-09-01",
 "awd_exp_date": "2020-08-31",
 "tot_intn_awd_amt": 800000.0,
 "awd_amount": 816016.0,
 "awd_min_amd_letter_date": "2015-06-11",
 "awd_max_amd_letter_date": "2016-07-05",
 "awd_abstract_narration": "Title: SHF: Medium: Fiat: Correct-by-Construction and Mostly Automated Derivation of Programs with an Interactive Theorem Prover\r\n\r\nTo scale to ambitious software-development tasks, programming languages must provide features for abstraction and modularity. Large advances in programming productivity have often come via new features of that kind. This project investigates new program-structuring ideas based fundamentally on machine-checked mathematical proofs. More specifically, through the design of a prototype system Fiat within the Coq proof assistant, the project studies how to derive efficient programs automatically from logical specifications. Programmers may package new notations and associated styles of automation as libraries, and a single program may mix notations, automatically benefiting from the combination of all of their associated automation for deriving efficient programs. In this way, Fiat makes it possible to split a program into parts for functionality and performance, with strong guarantees that bugs in the performance parts can never violate the requirements in the functionality parts. The intellectual merits are widely applicable new ideas in modular program structuring, with strong formal guarantees of correctness. The project's broader significance and importance are based on the potential to improve programmer productivity dramatically, for software projects in a wide variety of contexts; and the project also studies how the idea of mostly automated refinement from specifications can be integrated into introductory programming and discrete-math classes, to drive home the value of logical notation in programming.\r\n\r\nThe primary case-study domain in the project is practical Internet servers, such as for domain-name lookup or delivery of electronic mail. The goal is to develop Fiat versions of these key services, deriving efficient executable code automatically. Past work on deriving data layers from specifications in the style of SQL is being extended, in addition to exploration of other domains for specification and automated derivation, such as synthesis of parsers from grammars, to use for the protocols that servers speak, the configuration files that they read, etc. Beyond studying how such new libraries may be constructed and composed, the project also investigates how to push the synthesis process to lower abstraction levels than in our prototype implementation, which generates functional programs. The improved Fiat system will derive assembly programs, enabling choice of more effective optimizations thanks to more direct control of machine resources, integrating with the Bedrock Coq library for verified multilanguage programming.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Adam",
   "pi_last_name": "Chlipala",
   "pi_mid_init": "J",
   "pi_sufx_name": "",
   "pi_full_name": "Adam J Chlipala",
   "pi_email_addr": "adamc@csail.mit.edu",
   "nsf_id": "000610723",
   "pi_start_date": "2015-06-11",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Massachusetts Institute of Technology",
  "inst_street_address": "77 MASSACHUSETTS AVE",
  "inst_street_address_2": "",
  "inst_city_name": "CAMBRIDGE",
  "inst_state_code": "MA",
  "inst_state_name": "Massachusetts",
  "inst_phone_num": "6172531000",
  "inst_zip_code": "021394301",
  "inst_country_name": "United States",
  "cong_dist_code": "07",
  "st_cong_dist_code": "MA07",
  "org_lgl_bus_name": "MASSACHUSETTS INSTITUTE OF TECHNOLOGY",
  "org_prnt_uei_num": "E2NYLCDML6V1",
  "org_uei_num": "E2NYLCDML6V1"
 },
 "perf_inst": {
  "perf_inst_name": "Massachusetts Institute of Technology",
  "perf_str_addr": "77 Massachusetts Avenue",
  "perf_city_name": "Cambridge",
  "perf_st_code": "MA",
  "perf_st_name": "Massachusetts",
  "perf_zip_code": "021394307",
  "perf_ctry_code": "US",
  "perf_cong_dist": "07",
  "perf_st_cong_dist": "MA07",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7924",
   "pgm_ref_txt": "MEDIUM PROJECT"
  },
  {
   "pgm_ref_code": "7943",
   "pgm_ref_txt": "PROGRAMMING LANGUAGES"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  }
 ],
 "app_fund": [
  {
   "app_code": "0115",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001516DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0116",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001617DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2015,
   "fund_oblg_amt": 800000.0
  },
  {
   "fund_oblg_fiscal_yr": 2016,
   "fund_oblg_amt": 16016.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>This project studied how to use computer-theorem-proving tools to write software automatically from mathematical specifications, also automatically producing proof that the software behaves correctly.&nbsp; One of the first programming domains we studied was relational querying and updating, in the style of SQL, a popular database language.&nbsp; In the course of this grant, we upgraded our support within that domain, with automatic selection of data structures by analysis of access patterns in specifications.&nbsp; We also added Narcissus, a domain for parsing and generation of binary network-packet formats, starting from nondeterministic generators of bitstrings from high-level representations, as specifications.&nbsp; A further domain was network-firewall rules, where efficient specialized software can be constructed from naive specifications that analyze complete histories of packets so far.<br />We also studied a cross-cutting feature: generating efficient imperative code (e.g., not relying on garbage collection) automatically from purely functional code.&nbsp; Our solution is extensible, in the form of a compiler that can be taught new tricks for generating imperative code along with its proof of correctness.&nbsp; Each new trick must come with a proof (or a proof generator) of correctness.&nbsp; Combining these pieces (also using the Bedrock framework for program verification and verified compilation), we produced the first pipeline to go automatically from relational specifications to efficient assembly code with proof of correctness.<br />One offshoot of the project, which was combined with our DeepSpec Expedition effort, is Fiat Cryptography, which generates high-performance cryptography routines automatically with proof.&nbsp; Specifically, we targeted finite-field arithmetic for elliptic-curve cryptography, where the previous state of practice was to rewrite code manually in C or assembly for each different elliptic curve and each family of hardware architectures (principally 32-bit vs. 64-bit).&nbsp; We showed that these algorithms could be generalized into high-level templates that can be proved once-and-for-all, then specialized to parameters and compiled to lean code by a verified compiler.&nbsp; The result is a domain-specific compiler that can be invoked as easily as standard tools like GCC.&nbsp; It has been adopted in a number of high-profile open-source projects, including parts of TLS code for both Chrome and Firefox, so that today a majority of secure web connections made by browsers run TLS code generated by our formally verified Fiat Cryptography compiler.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 12/30/2020<br>\n\t\t\t\t\tModified by: Adam&nbsp;J&nbsp;Chlipala</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nThis project studied how to use computer-theorem-proving tools to write software automatically from mathematical specifications, also automatically producing proof that the software behaves correctly.  One of the first programming domains we studied was relational querying and updating, in the style of SQL, a popular database language.  In the course of this grant, we upgraded our support within that domain, with automatic selection of data structures by analysis of access patterns in specifications.  We also added Narcissus, a domain for parsing and generation of binary network-packet formats, starting from nondeterministic generators of bitstrings from high-level representations, as specifications.  A further domain was network-firewall rules, where efficient specialized software can be constructed from naive specifications that analyze complete histories of packets so far.\nWe also studied a cross-cutting feature: generating efficient imperative code (e.g., not relying on garbage collection) automatically from purely functional code.  Our solution is extensible, in the form of a compiler that can be taught new tricks for generating imperative code along with its proof of correctness.  Each new trick must come with a proof (or a proof generator) of correctness.  Combining these pieces (also using the Bedrock framework for program verification and verified compilation), we produced the first pipeline to go automatically from relational specifications to efficient assembly code with proof of correctness.\nOne offshoot of the project, which was combined with our DeepSpec Expedition effort, is Fiat Cryptography, which generates high-performance cryptography routines automatically with proof.  Specifically, we targeted finite-field arithmetic for elliptic-curve cryptography, where the previous state of practice was to rewrite code manually in C or assembly for each different elliptic curve and each family of hardware architectures (principally 32-bit vs. 64-bit).  We showed that these algorithms could be generalized into high-level templates that can be proved once-and-for-all, then specialized to parameters and compiled to lean code by a verified compiler.  The result is a domain-specific compiler that can be invoked as easily as standard tools like GCC.  It has been adopted in a number of high-profile open-source projects, including parts of TLS code for both Chrome and Firefox, so that today a majority of secure web connections made by browsers run TLS code generated by our formally verified Fiat Cryptography compiler.\n\n\t\t\t\t\tLast Modified: 12/30/2020\n\n\t\t\t\t\tSubmitted by: Adam J Chlipala"
 }
}