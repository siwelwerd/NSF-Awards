{
 "awd_id": "1533912",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "XPS: FULL: FP:  Collaborative Research:Advancing autovectorization",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927885",
 "po_email": "abanerje@nsf.gov",
 "po_sign_block_name": "Anindya Banerjee",
 "awd_eff_date": "2015-08-01",
 "awd_exp_date": "2021-07-31",
 "tot_intn_awd_amt": 506994.0,
 "awd_amount": 506994.0,
 "awd_min_amd_letter_date": "2015-07-20",
 "awd_max_amd_letter_date": "2015-07-20",
 "awd_abstract_narration": "Title: XPS:FULL:FP:Collaborative Research:Advancing autovectorization\r\n\r\nThe goal of this project is to advance the state of the art in autovectorization. This is a technique applied by compilers to automatically transform computer programs so that they can take advantage of the vector devices found in most processors. Today, most compilers have autovectorization capabilities, but their effectiveness is limited. The intellectual merit of this project lies in its potential to advance an important and beautiful core area of computer science, compiler technology, by creating new techniques and extending our understanding of programming patterns, program analysis, and transformation techniques. Beyond computer science, the project's broader significance and importance is that its results aim at increasing the fraction of code segments that, without human intervention, make use of vector devices. The effect of this increase is the acceleration of computer programs and the reduction of the energy that they consume.  Faster programs are of great importance in all application areas, but are particularly important in science and engineering where computing speed is an enabler of discoveries and better designs.  \r\n\r\nThe research strategy is to develop and evaluate a prototype autovectorizer based on the exploration of the space of equivalent versions of a program guided by an intelligent search engine. The space of equivalent versions is obtained with a source-to-source restructurer. A repository of codelets is planned in order to train the search engine so that it becomes capable of guiding the selection in the space of possibilities in order to identify a highly efficient version of the code.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "David",
   "pi_last_name": "Padua",
   "pi_mid_init": "A",
   "pi_sufx_name": "",
   "pi_full_name": "David A Padua",
   "pi_email_addr": "padua@uiuc.edu",
   "nsf_id": "000317715",
   "pi_start_date": "2015-07-20",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Gerald",
   "pi_last_name": "DeJong",
   "pi_mid_init": "F",
   "pi_sufx_name": "",
   "pi_full_name": "Gerald F DeJong",
   "pi_email_addr": "mrebl@uiuc.edu",
   "nsf_id": "000390888",
   "pi_start_date": "2015-07-20",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Maria",
   "pi_last_name": "Garzaran",
   "pi_mid_init": "J",
   "pi_sufx_name": "",
   "pi_full_name": "Maria J Garzaran",
   "pi_email_addr": "garzaran@cs.uiuc.edu",
   "nsf_id": "000297030",
   "pi_start_date": "2015-07-20",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Illinois at Urbana-Champaign",
  "inst_street_address": "506 S WRIGHT ST",
  "inst_street_address_2": "",
  "inst_city_name": "URBANA",
  "inst_state_code": "IL",
  "inst_state_name": "Illinois",
  "inst_phone_num": "2173332187",
  "inst_zip_code": "618013620",
  "inst_country_name": "United States",
  "cong_dist_code": "13",
  "st_cong_dist_code": "IL13",
  "org_lgl_bus_name": "UNIVERSITY OF ILLINOIS",
  "org_prnt_uei_num": "V2PHZ2CSCH63",
  "org_uei_num": "Y8CWNJRCNN91"
 },
 "perf_inst": {
  "perf_inst_name": "University of Illinois at Urbana-Champaign",
  "perf_str_addr": "",
  "perf_city_name": "",
  "perf_st_code": "IL",
  "perf_st_name": "Illinois",
  "perf_zip_code": "618207473",
  "perf_ctry_code": "US",
  "perf_cong_dist": "13",
  "perf_st_cong_dist": "IL13",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "828300",
   "pgm_ele_name": "Exploiting Parallel&Scalabilty"
  }
 ],
 "pgm_ref": null,
 "app_fund": [
  {
   "app_code": "0115",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001516DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2015,
   "fund_oblg_amt": 506994.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>\n<div class=\"gmail_signature\" dir=\"ltr\">This project &nbsp;endeavored to pinpoint and solve the problems that hindered automatic&nbsp;<em>vectorization</em>&nbsp;for the last 40+ years. Vectorization is a very efficient technique for parallel execution of certain types of programs and is &nbsp;performed by a compiler.&nbsp;Prior work has&nbsp;shown that, in practice, vectorization yielded only modest performance improvements because only &nbsp;about 30% of a program was being vectorized, on average. It was also not possible to determine how much more vectorization might be achievable.&nbsp;</div>\n<div class=\"gmail_signature\" dir=\"ltr\">This is a very important problem, because significantly&nbsp;improved vectorization yields not only a much faster execution of programs but significant energy savings as well. The latter is another critical problem in computer design. Performance &nbsp;and energy constraints are critical bottlenecks in many important applications&nbsp;- from weather prediction to development of new drugs and materials, climate change, and advances in every scientific and engineering field, They also limit consumer products such as cell phones, TV's, etc. in what they can do - just think of artificial intelligence tasks that we want run directly on our devices.<br /><br />In this project we were able to establish that relative failure to vectorize well is due not to the lack of parallelization/vectorization techniques (which are plentiful following 50+ years of prior research), but rather because of the inability of existing tools to predict well which part of the code can be parallelized/vectorized and which precise program &nbsp;transformations (out of the myriad available) would result in the most significant performance/efficiency increase.&nbsp;We then&nbsp;determined the transformations that are most useful in vectorizing real applications and established a large open-source, extensible, repository of program kernels - &nbsp;annotated with thorough data on their performance, the transformations applied to best vectorize them, and speedups achieved on a modern computer system. This was then&nbsp;used to develop machine learning techniques (ML) that can predict with high accuracy what transformations may be usefully applied to a given code to optimize its performance.&nbsp; In addition, this repository can&nbsp;serve as a valuable resource for future generations of researchers as well as a baseline to benchmark any future work in the area against. Based on this foundation, we then developed a meta-compiler, that draws on the best available state-of-the-art vectorizing and parallelizing compilers, to produce code that is guaranteed to be as good as that produced by the&nbsp;best tools available at a given time, and in practice usually produces code superior (more efficient in speed and/or energy consumption) than any of the state-of-the-art&nbsp;compilers&nbsp;available at this time, with significant&nbsp;speedups obtained on full programs ranging upwards of 28 times as fast (!) when compared with the&nbsp;best compiler available.&nbsp;</div>\n</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 09/24/2021<br>\n\t\t\t\t\tModified by: David&nbsp;A&nbsp;Padua</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\n\nThis project  endeavored to pinpoint and solve the problems that hindered automatic vectorization for the last 40+ years. Vectorization is a very efficient technique for parallel execution of certain types of programs and is  performed by a compiler. Prior work has shown that, in practice, vectorization yielded only modest performance improvements because only  about 30% of a program was being vectorized, on average. It was also not possible to determine how much more vectorization might be achievable. \nThis is a very important problem, because significantly improved vectorization yields not only a much faster execution of programs but significant energy savings as well. The latter is another critical problem in computer design. Performance  and energy constraints are critical bottlenecks in many important applications - from weather prediction to development of new drugs and materials, climate change, and advances in every scientific and engineering field, They also limit consumer products such as cell phones, TV's, etc. in what they can do - just think of artificial intelligence tasks that we want run directly on our devices.\n\nIn this project we were able to establish that relative failure to vectorize well is due not to the lack of parallelization/vectorization techniques (which are plentiful following 50+ years of prior research), but rather because of the inability of existing tools to predict well which part of the code can be parallelized/vectorized and which precise program  transformations (out of the myriad available) would result in the most significant performance/efficiency increase. We then determined the transformations that are most useful in vectorizing real applications and established a large open-source, extensible, repository of program kernels -  annotated with thorough data on their performance, the transformations applied to best vectorize them, and speedups achieved on a modern computer system. This was then used to develop machine learning techniques (ML) that can predict with high accuracy what transformations may be usefully applied to a given code to optimize its performance.  In addition, this repository can serve as a valuable resource for future generations of researchers as well as a baseline to benchmark any future work in the area against. Based on this foundation, we then developed a meta-compiler, that draws on the best available state-of-the-art vectorizing and parallelizing compilers, to produce code that is guaranteed to be as good as that produced by the best tools available at a given time, and in practice usually produces code superior (more efficient in speed and/or energy consumption) than any of the state-of-the-art compilers available at this time, with significant speedups obtained on full programs ranging upwards of 28 times as fast (!) when compared with the best compiler available. \n\n\n\t\t\t\t\tLast Modified: 09/24/2021\n\n\t\t\t\t\tSubmitted by: David A Padua"
 }
}