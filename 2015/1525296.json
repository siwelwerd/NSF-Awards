{
 "awd_id": "1525296",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: SMALL: LUCID: Low-overhead, Unobtrusive Cache Contention Detection and Repair",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927885",
 "po_email": "abanerje@nsf.gov",
 "po_sign_block_name": "Anindya Banerjee",
 "awd_eff_date": "2015-07-01",
 "awd_exp_date": "2020-06-30",
 "tot_intn_awd_amt": 482422.0,
 "awd_amount": 482422.0,
 "awd_min_amd_letter_date": "2015-06-16",
 "awd_max_amd_letter_date": "2015-06-16",
 "awd_abstract_narration": "Title: SHF: SMALL: LUCID: Low-overhead, Unobtrusive Cache Contention Detection and Repair\r\n\r\nThe last decade has overseen a historic shift in processor design towards multicore architectures. From servers to tablets, phones and watches, processor architects are using multiple cores to achieve performance and energy targets. Unfortunately, writing parallel code that performs well on these processors is far from easy. The intellectual merits of this project include developing new algorithms for finding and fixing performance bugs in parallel code by integrating support from across the computing stack including hardware, compilers and runtime systems. The project's broader significance and importance is to improve the performance and energy efficiency of parallel code, providing benefits for the users of all multicore computing devices. This project also seeks to encourage participation from underrepresented groups in the next generation of computer scientists.\r\n\r\nThis project leverages recent advances in hardware performance counters that allow for low-overhead, unobtrusive profiling of cache contention in real systems. This performance counter information drives new techniques for finding and automatically fixing cache contention without programmer intervention. The research explores integrating contention detection and repair with managed language runtimes. The researchers plan to openly distribute the systems built for this project to facilitate examination by other researchers and to integrate the research results into education.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Joseph",
   "pi_last_name": "Devietti",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Joseph Devietti",
   "pi_email_addr": "devietti@cis.upenn.edu",
   "nsf_id": "000642229",
   "pi_start_date": "2015-06-16",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Pennsylvania",
  "inst_street_address": "3451 WALNUT ST STE 440A",
  "inst_street_address_2": "",
  "inst_city_name": "PHILADELPHIA",
  "inst_state_code": "PA",
  "inst_state_name": "Pennsylvania",
  "inst_phone_num": "2158987293",
  "inst_zip_code": "191046205",
  "inst_country_name": "United States",
  "cong_dist_code": "03",
  "st_cong_dist_code": "PA03",
  "org_lgl_bus_name": "TRUSTEES OF THE UNIVERSITY OF PENNSYLVANIA, THE",
  "org_prnt_uei_num": "GM1XX56LEP58",
  "org_uei_num": "GM1XX56LEP58"
 },
 "perf_inst": {
  "perf_inst_name": "University of Pennsylvania",
  "perf_str_addr": "",
  "perf_city_name": "",
  "perf_st_code": "PA",
  "perf_st_name": "Pennsylvania",
  "perf_zip_code": "191046205",
  "perf_ctry_code": "US",
  "perf_cong_dist": "03",
  "perf_st_cong_dist": "PA03",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7943",
   "pgm_ref_txt": "PROGRAMMING LANGUAGES"
  }
 ],
 "app_fund": [
  {
   "app_code": "0115",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001516DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2015,
   "fund_oblg_amt": 482422.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Over the past 5 years, this project has deepened our understanding of how to use hardware performance counters to diagnose performance bugs, and how to perform online optimization to fix these bugs while the program remains running. Fixing the program at runtime does incur extra complexity to preserve program correctness, but allows the diagnosis and repair of detected issues to be precisely focused on just the program and hardware platform in use - unlike static compiler optimizations that must generalize across a range of programs and platforms. Online optimization also sidesteps the challenge of stale profiling information, as the profile is gathered directly from the current execution and is thus never stale.</p>\n<p>We have explored this ability for both false sharing in multicore processors, and for processor front-end issues like instruction-cache misses. We have explored online optimization for both programs in managed languages (like Java) and unmanaged languages (like C and C++).</p>\n<p>This project has directly contributed to 4 peer-reviewed conference papers, and spurred collaboration across three universities and also with researchers at Intel Labs. Additionally, two PhD and three Master's students have been involved in developing this results project, and two of these Master's students later went on to pursue PhDs in computer science.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 07/26/2020<br>\n\t\t\t\t\tModified by: Joseph&nbsp;Devietti</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nOver the past 5 years, this project has deepened our understanding of how to use hardware performance counters to diagnose performance bugs, and how to perform online optimization to fix these bugs while the program remains running. Fixing the program at runtime does incur extra complexity to preserve program correctness, but allows the diagnosis and repair of detected issues to be precisely focused on just the program and hardware platform in use - unlike static compiler optimizations that must generalize across a range of programs and platforms. Online optimization also sidesteps the challenge of stale profiling information, as the profile is gathered directly from the current execution and is thus never stale.\n\nWe have explored this ability for both false sharing in multicore processors, and for processor front-end issues like instruction-cache misses. We have explored online optimization for both programs in managed languages (like Java) and unmanaged languages (like C and C++).\n\nThis project has directly contributed to 4 peer-reviewed conference papers, and spurred collaboration across three universities and also with researchers at Intel Labs. Additionally, two PhD and three Master's students have been involved in developing this results project, and two of these Master's students later went on to pursue PhDs in computer science.\n\n\t\t\t\t\tLast Modified: 07/26/2020\n\n\t\t\t\t\tSubmitted by: Joseph Devietti"
 }
}