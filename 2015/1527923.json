{
 "awd_id": "1527923",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Small: Interacting to Specify Software",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927841",
 "po_email": "sgreensp@nsf.gov",
 "po_sign_block_name": "Sol Greenspan",
 "awd_eff_date": "2015-08-01",
 "awd_exp_date": "2020-07-31",
 "tot_intn_awd_amt": 499509.0,
 "awd_amount": 499509.0,
 "awd_min_amd_letter_date": "2015-06-30",
 "awd_max_amd_letter_date": "2015-06-30",
 "awd_abstract_narration": "All sectors of our society rely on the proper functioning of software. While many tools exist to help software developers ensure important functional, security, and performance properties of their software, these tools generally require developers to provide a specification of the desired properties.  Unfortunately writing specifications today is a tedious, error-prone, and costly proposition. Specifications are software artifacts in their own right, yet developers have almost no support in creating and evolving them. Therefore, developers tend to write highly simple or incomplete specifications, if they write specifications at all.  This project aims to address that problem by producing techniques and tools that aid and incentivize developers in creating and maintaining high-quality specifications.  The new techniques will lead to improved software quality and maintainability, and the associated tools will be made available for use by both other researchers as well as practitioners.\r\n\r\nThe research focuses on two kinds of specifications: logical specs which are traditional pre/post conditions, and structural specs which are essentially boilerplate code patterns. The same principles will be followed for both kinds of specifications: a language will be defined to make the specifications highly expressive, and analysis-driven interactions with the programmer will be used to elicit and refine the specifications. Techniques will be used from code synthesis and dynamic invariant detection. A novel query language will enable programmers to interrogate their specifications.  The approach will be fundamentally interactive, leveraging human judgment to guide the construction of high-quality specifications, where the user is iteratively asked specific questions targeted at improving the correctness and completeness of generated specifications.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Todd",
   "pi_last_name": "Millstein",
   "pi_mid_init": "D",
   "pi_sufx_name": "",
   "pi_full_name": "Todd D Millstein",
   "pi_email_addr": "todd@cs.ucla.edu",
   "nsf_id": "000229495",
   "pi_start_date": "2015-06-30",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Miryung",
   "pi_last_name": "Kim",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Miryung Kim",
   "pi_email_addr": "miryung@cs.ucla.edu",
   "nsf_id": "000676266",
   "pi_start_date": "2015-06-30",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of California-Los Angeles",
  "inst_street_address": "10889 WILSHIRE BLVD STE 700",
  "inst_street_address_2": "",
  "inst_city_name": "LOS ANGELES",
  "inst_state_code": "CA",
  "inst_state_name": "California",
  "inst_phone_num": "3107940102",
  "inst_zip_code": "900244200",
  "inst_country_name": "United States",
  "cong_dist_code": "36",
  "st_cong_dist_code": "CA36",
  "org_lgl_bus_name": "UNIVERSITY OF CALIFORNIA, LOS ANGELES",
  "org_prnt_uei_num": "",
  "org_uei_num": "RN64EPNH8JC6"
 },
 "perf_inst": {
  "perf_inst_name": "University of California-Los Angeles",
  "perf_str_addr": "Computer Science Department",
  "perf_city_name": "Los Angeles",
  "perf_st_code": "CA",
  "perf_st_name": "California",
  "perf_zip_code": "900951596",
  "perf_ctry_code": "US",
  "perf_cong_dist": "36",
  "perf_st_cong_dist": "CA36",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7944",
   "pgm_ref_txt": "SOFTWARE ENG & FORMAL METHODS"
  }
 ],
 "app_fund": [
  {
   "app_code": "0115",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001516DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2015,
   "fund_oblg_amt": 499509.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>&nbsp;</p>\n<ul style=\"margin-top: 0; margin-bottom: 0;\">\n</ul>\n<p><span style=\"font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: 400; font-style: normal; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\">Software is relied upon in all aspects of society today, so its correctness is of paramount importance.&nbsp; However, before a software system&rsquo;s correctness can be validated, we must have a </span><span style=\"font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: 400; font-style: italic; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\">specification</span><span style=\"font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: 400; font-style: normal; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"> of the system&rsquo;s desired behavior. Unfortunately writing specifications today is a tedious, error-prone, and costly proposition. Specifications are software artifacts in their own right, yet developers have almost no support in creating and evolving them. Therefore, developers tend to write highly simple or incomplete specifications, if they write specifications at all. This project aimed to address this problem by developing techniques and associated tools that aid developers in creating and maintaining high-quality specifications.</span></p>\n<p><span style=\"font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: 400; font-style: normal; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\">The project focused on support for two different types of specifications.&nbsp; First, we developed new approaches to inferring </span><span style=\"font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: 400; font-style: italic; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\">logical specifications</span><span style=\"font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: 400; font-style: normal; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"> about a software system, which represent desired behaviors as logical formulas.&nbsp; Specifically, we created the Precondition Inference Engine (PIE), which automatically infers the logical conditions under which a given piece of code behaves as intended.&nbsp; PIE is more </span><span style=\"font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: 400; font-style: italic; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\">expressive</span><span style=\"font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: 400; font-style: normal; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"> than prior approaches, able to infer more complex conditions than was previously possible.&nbsp; PIE also provides stronger guarantees than prior approaches.&nbsp; We then showed how to use PIE to build an automatic software </span><span style=\"font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: 400; font-style: italic; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\">verifier</span><span style=\"font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: 400; font-style: normal; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\">, called LoopInvGen, which automatically proves that a given piece of code meets its specification.&nbsp; These tools have won multiple competitions and been used by others to obtain strong guarantees about software in a variety of domains.</span></p>\n<p><span style=\"font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: 400; font-style: normal; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\">Second, we developed new approaches to inferring </span><span style=\"font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: 400; font-style: italic; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\">structural specifications</span><span style=\"font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: 400; font-style: normal; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"> about a software system in the form of</span><span style=\"font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: 400; font-style: italic; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"> code templates</span><span style=\"font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: 400; font-style: normal; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\">. These include three </span><span style=\"font-size: 10.5pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: 400; font-style: normal; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\">interactive and automated techniques to discover structural specifications from a large corpus of open source repositories.&nbsp; Specifically, we have designed (1) ExampleCheck that infers API usage patterns automatically from GitHub projects and subsequently detects API usage violations in StackOverflow posts. We also designed (2) ExampleStack that automatically creates code templates from examples and identifies &ldquo;hot spots&rdquo; where most changes happen. Finally, we d</span><span style=\"font-size: 10pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: 400; font-style: normal; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\">esigned (3) Examplore,&nbsp; a novel interactive visualization and navigation technique that gives a bird&rsquo;s-eye view of common and uncommon ways that developers use an API. These techniques have been made publicly available as both Chrome browser extensions and standalone tools.</span></p>\n<p><br /><br /></p><br>\n<p>\n\t\t\t\t      \tLast Modified: 10/16/2020<br>\n\t\t\t\t\tModified by: Todd&nbsp;D&nbsp;Millstein</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\n \n\n\n\nSoftware is relied upon in all aspects of society today, so its correctness is of paramount importance.  However, before a software system\u2019s correctness can be validated, we must have a specification of the system\u2019s desired behavior. Unfortunately writing specifications today is a tedious, error-prone, and costly proposition. Specifications are software artifacts in their own right, yet developers have almost no support in creating and evolving them. Therefore, developers tend to write highly simple or incomplete specifications, if they write specifications at all. This project aimed to address this problem by developing techniques and associated tools that aid developers in creating and maintaining high-quality specifications.\n\nThe project focused on support for two different types of specifications.  First, we developed new approaches to inferring logical specifications about a software system, which represent desired behaviors as logical formulas.  Specifically, we created the Precondition Inference Engine (PIE), which automatically infers the logical conditions under which a given piece of code behaves as intended.  PIE is more expressive than prior approaches, able to infer more complex conditions than was previously possible.  PIE also provides stronger guarantees than prior approaches.  We then showed how to use PIE to build an automatic software verifier, called LoopInvGen, which automatically proves that a given piece of code meets its specification.  These tools have won multiple competitions and been used by others to obtain strong guarantees about software in a variety of domains.\n\nSecond, we developed new approaches to inferring structural specifications about a software system in the form of code templates. These include three interactive and automated techniques to discover structural specifications from a large corpus of open source repositories.  Specifically, we have designed (1) ExampleCheck that infers API usage patterns automatically from GitHub projects and subsequently detects API usage violations in StackOverflow posts. We also designed (2) ExampleStack that automatically creates code templates from examples and identifies \"hot spots\" where most changes happen. Finally, we designed (3) Examplore,  a novel interactive visualization and navigation technique that gives a bird\u2019s-eye view of common and uncommon ways that developers use an API. These techniques have been made publicly available as both Chrome browser extensions and standalone tools.\n\n\n\n\n\n\t\t\t\t\tLast Modified: 10/16/2020\n\n\t\t\t\t\tSubmitted by: Todd D Millstein"
 }
}