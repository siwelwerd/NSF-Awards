{
 "awd_id": "1453796",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "CAREER: Verified Compilers for a Multi-Language World",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927885",
 "po_email": "abanerje@nsf.gov",
 "po_sign_block_name": "Anindya Banerjee",
 "awd_eff_date": "2015-05-01",
 "awd_exp_date": "2022-04-30",
 "tot_intn_awd_amt": 508092.0,
 "awd_amount": 540092.0,
 "awd_min_amd_letter_date": "2015-01-15",
 "awd_max_amd_letter_date": "2019-05-14",
 "awd_abstract_narration": "Title: CAREER: Verified Compilers for a Multi-Language World\r\n\r\nCompilers play a critical role in the production of software.  As such, they should be correct.  That is, they should preserve the behavior of all programs they compile. Despite remarkable progress on formally verified compilers in recent years, these compilers suffer from a serious limitation: they are proved correct under the assumption that they will only be used to compile whole programs. This is an entirely unrealistic assumption since most software systems today are comprised of components written in different languages compiled by different compilers to a common low-level target language.  The intellectual merit of this project is the development of a proof architecture for building verified compilers for today's world of multi-language software: such verified compilers guarantee correct compilation of components and support linking with arbitrary target code, no matter its source. The project's broader significance and importance are that verified compilation of components stands to benefit practically every software system, from safety-critical software to web browsers, because such systems use libraries or components that are written in a variety of languages. The project will achieve broad impact through the development of (i) a proof methodology that scales to realistic multi-pass compilers and multi-language sofware, (ii) a target language that extends LLVM---increasingly the target of choice for modern compilers---with support for compilation from type-safe source languages, and (iii) educational materials related to the proof techniques employed in the course of this project.\r\n\r\nThe project has two central themes, both of which stem from a view of compiler correctness as a language interoperability problem. First, specification of correctness of component compilation demands a formal semantics of interoperability between the source and target languages. More precisely: if a source component (say s) compiles to target component (say t), then t linked with some arbitrary target code (say t') should behave the same as s interoperating with t'. Second, enabling safe interoperability between components compiled from languages as different as Java, Rust, Python, and C, requires the design of a gradually type-safe target language based on LLVM that supports safe interoperability between more precisely typed, less precisely typed, and type-unsafe components.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Amal",
   "pi_last_name": "Ahmed",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Amal Ahmed",
   "pi_email_addr": "amal@ccs.neu.edu",
   "nsf_id": "000573498",
   "pi_start_date": "2015-01-15",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Northeastern University",
  "inst_street_address": "360 HUNTINGTON AVE",
  "inst_street_address_2": "",
  "inst_city_name": "BOSTON",
  "inst_state_code": "MA",
  "inst_state_name": "Massachusetts",
  "inst_phone_num": "6173735600",
  "inst_zip_code": "021155005",
  "inst_country_name": "United States",
  "cong_dist_code": "07",
  "st_cong_dist_code": "MA07",
  "org_lgl_bus_name": "NORTHEASTERN UNIVERSITY",
  "org_prnt_uei_num": "",
  "org_uei_num": "HLTMVS2JZBS6"
 },
 "perf_inst": {
  "perf_inst_name": "Northeastern University",
  "perf_str_addr": "360 Huntington Ave",
  "perf_city_name": "Boston",
  "perf_st_code": "MA",
  "perf_st_name": "Massachusetts",
  "perf_zip_code": "021155005",
  "perf_ctry_code": "US",
  "perf_cong_dist": "07",
  "perf_st_cong_dist": "MA07",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "1045",
   "pgm_ref_txt": "CAREER-Faculty Erly Career Dev"
  },
  {
   "pgm_ref_code": "7798",
   "pgm_ref_txt": "SOFTWARE & HARDWARE FOUNDATION"
  },
  {
   "pgm_ref_code": "7943",
   "pgm_ref_txt": "PROGRAMMING LANGUAGES"
  },
  {
   "pgm_ref_code": "9102",
   "pgm_ref_txt": "WOMEN, MINORITY, DISABLED, NEC"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  }
 ],
 "app_fund": [
  {
   "app_code": "0115",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001516DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0117",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001718DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0118",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001819DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0119",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001920DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2015,
   "fund_oblg_amt": 194552.0
  },
  {
   "fund_oblg_fiscal_yr": 2017,
   "fund_oblg_amt": 117258.0
  },
  {
   "fund_oblg_fiscal_yr": 2018,
   "fund_oblg_amt": 112692.0
  },
  {
   "fund_oblg_fiscal_yr": 2019,
   "fund_oblg_amt": 115590.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Compilers, which translate high-level source code written by programmers intothe low-level target code that runs on machines, play a critical role in theproduction of software. As such, they should be correct, i.e., they shouldpreserve the behavior of all programs they compile. Prior to this project, whilethere had been remarkable progress on formally verified compilers forincreasingly realistic languages, these verified compilers suffered from aserious limitation: they were proved correct under impractical assumptions aboutwhat the compiled code would be linked with, from no linking at all to linkingonly with code compiled from the same source language. These assumptions do notmatch reality as most software systems today are comprised of components writtenin different languages compiled by different compilers to a common target, aswell as low-level libraries that may be handwritten in the target language.<br />A central goal of this project was to investigate proof methods for buildingverified compositional compilers, which guarantee correct compilation ofcomponents, not just whole programs, and formally support linking with arbitrarytarget code. &nbsp;The long-term vision, extending beyond this project, is to haveverified compositional compilers from languages as different as C, OCaml, Rust,and Coq to a common low-level target language that supports safeinteroperability between more precisely typed, less precisely typed, andtype-unsafe components.&nbsp;<br />The first major result of this project was the development of a genericcompositional compiler correctness (CCC) theorem that we argue is the desiredtheorem when compiling components instead of whole programs. This resultaddresses a critical question: how do we even state the compiler correctnesstheorem in the presence of linking? While there have been a number of recentresults on compositional compiler correctness, they all state theircorrect-component-compilation theorems in remarkably different ways, yieldingpros and cons that aren't well understood. &nbsp;We showed that specificcompiler-verification efforts can use their choice of formalism ``under thehood'' and then prove that their theorems imply CCC.&nbsp;<br />The second major outcome of the project were compositional compiler correctnessresults for compilers that, unlike prior work, support linking withtarget-language features that are not present in the source language:specifically with control effects such as exceptions and call/cc. Linking withfeatures not present in the source is a critical feature since that often whyprogrammers implement components in different languages.&nbsp;<br />The third major result of the project was a multi-language that supports safemixing of a high-level typed functional language with low-level assembly code.This is nontrivial since assembly is not compositional: assembly languagecomponents may be comprised of different numbers of basic blocks so it isn'tclear how to identify component boundaries. To support safe mixing, we designeda compositional typed assembly language (TAL), showed how to designmulti-language semantics so TAL components can be safely embedded in ahigh-level functional language and vice versa.&nbsp;<br />The fourth major outcome of this project is a methodology for verifying thesoundness of foreign-function interfaces (FFIs). &nbsp;Every language implements anFFI for language interoperability, but existing FFIs are all ad hoc. Wedeveloped a semantic framework for proving soundness of &nbsp;FFIs as they are designed \"in the wild\", by which we mean that FFI developersimplement conversion between types of data from two different source languagesby implementing target-level conversion functions to mediate between datarepresentations coming from the two source languages. We applied thisframework to a series of case studies that demonstrate how this &nbsp;approach allows us to account for complex differences in language semantics andmake efficiency trade-offs based on specifics of compilers or targets.&nbsp;<br />The fifth major set of results pertain to compilation of languages with advancedtype systems, specifically dependent types. Dependently typed languages such asthat of the Coq proof assistant have rich types that enable verification of fullfunctional correctness during program development. &nbsp;This project showed how todevelop correct and *typed* compiler passes for the core language of the Coqproof assistant. These passes include typed CPS translation, which since 2002was conjectured to be impossible, typed closure conversion, and ANF. Theseresults are key to building a practical verified compiler for Coq which wouldensure that fully verified source code cannot be compromised via compiler bugsor unsafe linking.<br />The sixth major series of results from this project pertain to gradualtyping, i.e., the mixing of more precisely typed and less precisely typedcode. One of the goals of the project was to design a gradually type-safelow-level language that supports safe interoperability between components thatare statically type-safe (e.g., compiled from OCaml or Rust) and dynamicallytype-safe (e.g., compiled from Python or Scheme). This project produced a seriesof foundational results on design principles for gradually typed langauges.&nbsp;<br />Finally, for education and broader impacts: the project involved development ofsummer school lectures delivered in 4 separate years at the Oregon PL Summer School &nbsp;(OPLSS) on a variety of research results from this project. It also includedlectures and talks at ECOOP, the PL Mentoring Workshop, a keynote at theStrangeLoop conference, and courses at Northeastern that explain how ideas fromtype systems, runtime contract checking, gradual typing, multi-languagesemantics, and compiler correctness can be brought together to build verifiedcompilers for a multi-language world.&nbsp;<br /><br /></p><br>\n<p>\n\t\t\t\t      \tLast Modified: 07/28/2023<br>\n\t\t\t\t\tModified by: Amal&nbsp;Ahmed</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nCompilers, which translate high-level source code written by programmers intothe low-level target code that runs on machines, play a critical role in theproduction of software. As such, they should be correct, i.e., they shouldpreserve the behavior of all programs they compile. Prior to this project, whilethere had been remarkable progress on formally verified compilers forincreasingly realistic languages, these verified compilers suffered from aserious limitation: they were proved correct under impractical assumptions aboutwhat the compiled code would be linked with, from no linking at all to linkingonly with code compiled from the same source language. These assumptions do notmatch reality as most software systems today are comprised of components writtenin different languages compiled by different compilers to a common target, aswell as low-level libraries that may be handwritten in the target language.\nA central goal of this project was to investigate proof methods for buildingverified compositional compilers, which guarantee correct compilation ofcomponents, not just whole programs, and formally support linking with arbitrarytarget code.  The long-term vision, extending beyond this project, is to haveverified compositional compilers from languages as different as C, OCaml, Rust,and Coq to a common low-level target language that supports safeinteroperability between more precisely typed, less precisely typed, andtype-unsafe components. \nThe first major result of this project was the development of a genericcompositional compiler correctness (CCC) theorem that we argue is the desiredtheorem when compiling components instead of whole programs. This resultaddresses a critical question: how do we even state the compiler correctnesstheorem in the presence of linking? While there have been a number of recentresults on compositional compiler correctness, they all state theircorrect-component-compilation theorems in remarkably different ways, yieldingpros and cons that aren't well understood.  We showed that specificcompiler-verification efforts can use their choice of formalism ``under thehood'' and then prove that their theorems imply CCC. \nThe second major outcome of the project were compositional compiler correctnessresults for compilers that, unlike prior work, support linking withtarget-language features that are not present in the source language:specifically with control effects such as exceptions and call/cc. Linking withfeatures not present in the source is a critical feature since that often whyprogrammers implement components in different languages. \nThe third major result of the project was a multi-language that supports safemixing of a high-level typed functional language with low-level assembly code.This is nontrivial since assembly is not compositional: assembly languagecomponents may be comprised of different numbers of basic blocks so it isn'tclear how to identify component boundaries. To support safe mixing, we designeda compositional typed assembly language (TAL), showed how to designmulti-language semantics so TAL components can be safely embedded in ahigh-level functional language and vice versa. \nThe fourth major outcome of this project is a methodology for verifying thesoundness of foreign-function interfaces (FFIs).  Every language implements anFFI for language interoperability, but existing FFIs are all ad hoc. Wedeveloped a semantic framework for proving soundness of  FFIs as they are designed \"in the wild\", by which we mean that FFI developersimplement conversion between types of data from two different source languagesby implementing target-level conversion functions to mediate between datarepresentations coming from the two source languages. We applied thisframework to a series of case studies that demonstrate how this  approach allows us to account for complex differences in language semantics andmake efficiency trade-offs based on specifics of compilers or targets. \nThe fifth major set of results pertain to compilation of languages with advancedtype systems, specifically dependent types. Dependently typed languages such asthat of the Coq proof assistant have rich types that enable verification of fullfunctional correctness during program development.  This project showed how todevelop correct and *typed* compiler passes for the core language of the Coqproof assistant. These passes include typed CPS translation, which since 2002was conjectured to be impossible, typed closure conversion, and ANF. Theseresults are key to building a practical verified compiler for Coq which wouldensure that fully verified source code cannot be compromised via compiler bugsor unsafe linking.\nThe sixth major series of results from this project pertain to gradualtyping, i.e., the mixing of more precisely typed and less precisely typedcode. One of the goals of the project was to design a gradually type-safelow-level language that supports safe interoperability between components thatare statically type-safe (e.g., compiled from OCaml or Rust) and dynamicallytype-safe (e.g., compiled from Python or Scheme). This project produced a seriesof foundational results on design principles for gradually typed langauges. \nFinally, for education and broader impacts: the project involved development ofsummer school lectures delivered in 4 separate years at the Oregon PL Summer School  (OPLSS) on a variety of research results from this project. It also includedlectures and talks at ECOOP, the PL Mentoring Workshop, a keynote at theStrangeLoop conference, and courses at Northeastern that explain how ideas fromtype systems, runtime contract checking, gradual typing, multi-languagesemantics, and compiler correctness can be brought together to build verifiedcompilers for a multi-language world. \n\n\n\n\t\t\t\t\tLast Modified: 07/28/2023\n\n\t\t\t\t\tSubmitted by: Amal Ahmed"
 }
}