{
 "awd_id": "1525472",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "TWC: Small: Memory Analysis and Machine-Code Verification Techniques for Multiprocessor Systems",
 "cfda_num": "47.070",
 "org_code": "05050000",
 "po_phone": "7032927841",
 "po_email": "sgreensp@nsf.gov",
 "po_sign_block_name": "Sol Greenspan",
 "awd_eff_date": "2015-09-01",
 "awd_exp_date": "2020-08-31",
 "tot_intn_awd_amt": 499999.0,
 "awd_amount": 499999.0,
 "awd_min_amd_letter_date": "2015-08-14",
 "awd_max_amd_letter_date": "2015-08-14",
 "awd_abstract_narration": "Due to the ever-increasing complexity of both hardware and software, it is becoming harder to ensure the reliability of high-level programs.  The project will develop tools that permit programmers to mechanically verify software via machine-code analysis. The proposed research will similarly advance the science of software analysis, together with the development of rigorous tools capable of performing industrial software verification. The tools are actively being used by industry for hardware specification and analysis. The proposed research will similarly advance the science of software analysis, together with the development of rigorous tools capable of performing industrial software verification. The tools are important in particular for verifying security properties of systems such as medical, financial, and transportation systems. \r\n\r\nThe project extends existing specification and analysis efforts by using the specification of the x86 processor's instruction-set architecture (ISA) to mechanically verify user-level machine-code programs. The specification is extended to allow verification of multiprocessor/multi-threaded programs and operating system code.  The goal is a capability to ensure that programs hosted on multiprocessors are correct with respect to behavior, security, and resource requirements. The focus is on a single machine-code model, since that can be sufficient for analyzing all programs, irrespective of the source language, as long as they compile down to the supported processor platform.   This eliminates the need to build,  maintain,  and validate different verification frameworks targeting software from different sources.  Machine  code  executes  on  contemporary  computer  systems  with  complex  memory  hierarchies: memory semantics are complicated by caches, memory protection mechanisms, multiprocessor/multithread memory sharing, store buffers, transactional memory mechanisms, memory synchronization  mechanisms,  and  memory  update  delays. This complexity  leads  to  important memory-related research issues that will be addressed in order to reason about machine-code program execution.  Examples are the correctness of address translation (including access rights management) and the formalization of a realistic memory consistency model.  This goes well beyond capabilities provided by existing static-analysis tools in order to address these sorts of problems.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CNS",
 "org_div_long_name": "Division Of Computer and Network Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Warren",
   "pi_last_name": "Hunt, Jr.",
   "pi_mid_init": "A",
   "pi_sufx_name": "",
   "pi_full_name": "Warren A Hunt, Jr.",
   "pi_email_addr": "hunt@cs.utexas.edu",
   "nsf_id": "000369883",
   "pi_start_date": "2015-08-14",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Matt",
   "pi_last_name": "Kaufmann",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Matt Kaufmann",
   "pi_email_addr": "kaufmann@cs.utexas.edu",
   "nsf_id": "000502035",
   "pi_start_date": "2015-08-14",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Texas at Austin",
  "inst_street_address": "110 INNER CAMPUS DR",
  "inst_street_address_2": "",
  "inst_city_name": "AUSTIN",
  "inst_state_code": "TX",
  "inst_state_name": "Texas",
  "inst_phone_num": "5124716424",
  "inst_zip_code": "787121139",
  "inst_country_name": "United States",
  "cong_dist_code": "25",
  "st_cong_dist_code": "TX25",
  "org_lgl_bus_name": "UNIVERSITY OF TEXAS AT AUSTIN",
  "org_prnt_uei_num": "",
  "org_uei_num": "V6AFQPN18437"
 },
 "perf_inst": {
  "perf_inst_name": "University of Texas at Austin",
  "perf_str_addr": "101 E. 27th Street, Suite 5.300",
  "perf_city_name": "Austin",
  "perf_st_code": "TX",
  "perf_st_name": "Texas",
  "perf_zip_code": "787121532",
  "perf_ctry_code": "US",
  "perf_cong_dist": "25",
  "perf_st_cong_dist": "TX25",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "806000",
   "pgm_ele_name": "Secure &Trustworthy Cyberspace"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7434",
   "pgm_ref_txt": "CNCI"
  },
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  }
 ],
 "app_fund": [
  {
   "app_code": "0115",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001516DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2015,
   "fund_oblg_amt": 499999.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>As the computer age has advanced, major resources have been dedicated to eliminating bugs in designs of digital artifacts, from microprocessors to controllers in automobiles. &nbsp;Tools based on mathematical proof have been increasingly employed to this end, since testing is often woefully incomplete.<br />Our project uses such a tool, ACL2, which provides automated reasoning and a programming environment to assist its user in modeling digital systems, proving properties of them, and discovering bugs. &nbsp;This project applied ACL2 to three targets, discussed below in turn. &nbsp;All of our work has resulted in the development of libraries of relevant utilities and theorems that now appear in the ACL2 community books GitHub repository, and can applied to future related work.</p>\n<p><br />(1) Verification of x86 machine code<br />How can one ensure that a computer program does what it is intended to do? &nbsp;A conventional approach is to reason about programs written in high-level computer languages, but there are three drawbacks: the semantics may be ill-specified for such languages; there could be bugs when transforming such a program to the native language of the computer's instruction-set architecture (ISA); and there are numerous high-level programming languages to consider, in contrast to the relatively few native microprocessor languages.<br />Therefore, we have chosen to develop techniques for reasoning about computer programs written in the native language of the x86 family of microprocessors, which are ubiquitous in modern computers and other digital devices. &nbsp;To this end, we developed an ACL2 model of the x86 ISA to specify the effect of each x86 machine-code instruction, and we used this model to prove correctness of various x86 programs. &nbsp;In the process, we developed extensive infrastructure to make this work useful to future verification projects, including libraries of proved lemmas to provide automation for code proofs and a framework for validating our model. &nbsp;With that framework, we have performed extensive co-simulation -- testing that the model and an actual x86 microprocessor agree in their executions of specific x86 programs. &nbsp;The model is accompanied by extensive documentation.<br />A key contribution is the development of two \"modes\" for this model. &nbsp;One mode simplifies proofs for user-level programs by hiding the complexity of system-level features such as paging, while the other exposes the complexity of the x86 system. &nbsp;We developed proof techniques and applied them to validate properties of both user-level and system-level programs, using the appropriate mode for each.<br />The broader impact of this work is both better microprocessors and software that runs on them. &nbsp;Centaur Technology and Kestrel Technology both use and improve our x86 model. &nbsp;Centaur uses it as a partial specification for their x86-compatible microprocessors; and Kestrel uses the model as a platform for research, including the automated identification of malware in existing software.</p>\n<p><br />(2) An important extension to our x86 verification technology would be the ability to reason about multi-threaded programs. &nbsp;Our preliminary investigations included development of a much-simplified x86 ISA, based on a multiprocessor environment with a shared memory. &nbsp;The memory model was based on behavior of the most common type of x86 memory, so-called write-back (cacheable) memory. &nbsp;We used this model to prove program correctness for a few very simple multiprocessor code snippets. &nbsp;As multi-threaded programs are increasingly common, this preliminary work supports the goal of producing correct software.</p>\n<p><br />(3) Our third target was correctness of filesystems: computer programs that manage files on computers and other digital devices. &nbsp;We chose to model filesystems in ACL2, as it is sufficiently flexible for stating and proving desired properties.<br />Our focus was on the FAT32 filesystem, used by Microsoft Windows, Linux, MacOS, flash drives, and many embedded products. &nbsp;We built two ACL2 models of it: one that uses a tree representation, which allows straightforward specification and analysis, and one that uses a traditional linear representation. &nbsp;We used the tree-oriented model to prove properties, including: if you write a file and then read from it, you get back what was written. &nbsp;We used the second model to co-simulate: that is, to test correspondence with actual FAT32 filesystems. &nbsp;We have, with one remaining gap, proved equivalence of those two models, so that all results proved about the first model are known also to be true of the second. &nbsp;We have also begun to extend our investigations to address simultaneous read and write operations, using a simplified model.<br />The techniques developed are positioned to help uncover bugs in existing filesystem implementations through co-simulation testing. &nbsp;Our vision is for this work is improved file system reliability, as part of the broader impact of this project on improved computer system reliability.</p>\n<p>&nbsp;</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 10/02/2020<br>\n\t\t\t\t\tModified by: Warren&nbsp;A&nbsp;Hunt, Jr.</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nAs the computer age has advanced, major resources have been dedicated to eliminating bugs in designs of digital artifacts, from microprocessors to controllers in automobiles.  Tools based on mathematical proof have been increasingly employed to this end, since testing is often woefully incomplete.\nOur project uses such a tool, ACL2, which provides automated reasoning and a programming environment to assist its user in modeling digital systems, proving properties of them, and discovering bugs.  This project applied ACL2 to three targets, discussed below in turn.  All of our work has resulted in the development of libraries of relevant utilities and theorems that now appear in the ACL2 community books GitHub repository, and can applied to future related work.\n\n\n(1) Verification of x86 machine code\nHow can one ensure that a computer program does what it is intended to do?  A conventional approach is to reason about programs written in high-level computer languages, but there are three drawbacks: the semantics may be ill-specified for such languages; there could be bugs when transforming such a program to the native language of the computer's instruction-set architecture (ISA); and there are numerous high-level programming languages to consider, in contrast to the relatively few native microprocessor languages.\nTherefore, we have chosen to develop techniques for reasoning about computer programs written in the native language of the x86 family of microprocessors, which are ubiquitous in modern computers and other digital devices.  To this end, we developed an ACL2 model of the x86 ISA to specify the effect of each x86 machine-code instruction, and we used this model to prove correctness of various x86 programs.  In the process, we developed extensive infrastructure to make this work useful to future verification projects, including libraries of proved lemmas to provide automation for code proofs and a framework for validating our model.  With that framework, we have performed extensive co-simulation -- testing that the model and an actual x86 microprocessor agree in their executions of specific x86 programs.  The model is accompanied by extensive documentation.\nA key contribution is the development of two \"modes\" for this model.  One mode simplifies proofs for user-level programs by hiding the complexity of system-level features such as paging, while the other exposes the complexity of the x86 system.  We developed proof techniques and applied them to validate properties of both user-level and system-level programs, using the appropriate mode for each.\nThe broader impact of this work is both better microprocessors and software that runs on them.  Centaur Technology and Kestrel Technology both use and improve our x86 model.  Centaur uses it as a partial specification for their x86-compatible microprocessors; and Kestrel uses the model as a platform for research, including the automated identification of malware in existing software.\n\n\n(2) An important extension to our x86 verification technology would be the ability to reason about multi-threaded programs.  Our preliminary investigations included development of a much-simplified x86 ISA, based on a multiprocessor environment with a shared memory.  The memory model was based on behavior of the most common type of x86 memory, so-called write-back (cacheable) memory.  We used this model to prove program correctness for a few very simple multiprocessor code snippets.  As multi-threaded programs are increasingly common, this preliminary work supports the goal of producing correct software.\n\n\n(3) Our third target was correctness of filesystems: computer programs that manage files on computers and other digital devices.  We chose to model filesystems in ACL2, as it is sufficiently flexible for stating and proving desired properties.\nOur focus was on the FAT32 filesystem, used by Microsoft Windows, Linux, MacOS, flash drives, and many embedded products.  We built two ACL2 models of it: one that uses a tree representation, which allows straightforward specification and analysis, and one that uses a traditional linear representation.  We used the tree-oriented model to prove properties, including: if you write a file and then read from it, you get back what was written.  We used the second model to co-simulate: that is, to test correspondence with actual FAT32 filesystems.  We have, with one remaining gap, proved equivalence of those two models, so that all results proved about the first model are known also to be true of the second.  We have also begun to extend our investigations to address simultaneous read and write operations, using a simplified model.\nThe techniques developed are positioned to help uncover bugs in existing filesystem implementations through co-simulation testing.  Our vision is for this work is improved file system reliability, as part of the broader impact of this project on improved computer system reliability.\n\n \n\n\t\t\t\t\tLast Modified: 10/02/2020\n\n\t\t\t\t\tSubmitted by: Warren A Hunt, Jr."
 }
}