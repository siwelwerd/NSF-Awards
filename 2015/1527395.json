{
 "awd_id": "1527395",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Small: Automating Software Verification using Natural Proofs",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927991",
 "po_email": "namla@nsf.gov",
 "po_sign_block_name": "Nina Amla",
 "awd_eff_date": "2015-07-15",
 "awd_exp_date": "2019-06-30",
 "tot_intn_awd_amt": 500000.0,
 "awd_amount": 500000.0,
 "awd_min_amd_letter_date": "2015-06-30",
 "awd_max_amd_letter_date": "2015-06-30",
 "awd_abstract_narration": "The automated algorithmic verification of software, even when assisted by programmer annotations with invariants, is at an impasse today because the underlying technical problems are not solvable using computers (undecidable). Consequently, current tools perform very poorly for most non-shallow specifications of software, which do not admit decidable verification, and hence require manual help throughout the verification process. This has lead to limited adoption of these tools by the wider population of programmers untrained in formal methods. This project addresses this problem through a new radical approach called natural proofs. \r\n\r\nNatural proofs are a subclass of proofs that can be effectively and efficiently searched for, and embody common tactics that people use and that work for most programs.  Natural proofs hence yield automatic though incomplete techniques that work in most situations, side-stepping undecidability barriers. The project's goal is to build natural proof techniques for the verification of a variety of security properties, including privacy, integrity, and access control, that span across entire systems, and that help programmers verify their programs with very little annotation overhead. Applications include more automated verification of security properties of software, such as an Android platform, as well as scalable auto-grading of programming exercises in Massive Open Online Courses (MOOCs).",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Madhusudan",
   "pi_last_name": "Parthasarathy",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Madhusudan Parthasarathy",
   "pi_email_addr": "madhu@cs.uiuc.edu",
   "nsf_id": "000214557",
   "pi_start_date": "2015-06-30",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Illinois at Urbana-Champaign",
  "inst_street_address": "506 S WRIGHT ST",
  "inst_street_address_2": "",
  "inst_city_name": "URBANA",
  "inst_state_code": "IL",
  "inst_state_name": "Illinois",
  "inst_phone_num": "2173332187",
  "inst_zip_code": "618013620",
  "inst_country_name": "United States",
  "cong_dist_code": "13",
  "st_cong_dist_code": "IL13",
  "org_lgl_bus_name": "UNIVERSITY OF ILLINOIS",
  "org_prnt_uei_num": "V2PHZ2CSCH63",
  "org_uei_num": "Y8CWNJRCNN91"
 },
 "perf_inst": {
  "perf_inst_name": "University of Illinois at Urbana-Champaign",
  "perf_str_addr": "",
  "perf_city_name": "",
  "perf_st_code": "IL",
  "perf_st_name": "Illinois",
  "perf_zip_code": "618207473",
  "perf_ctry_code": "US",
  "perf_cong_dist": "13",
  "perf_st_cong_dist": "IL13",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "8206",
   "pgm_ref_txt": "Formal Methods and Verification"
  }
 ],
 "app_fund": [
  {
   "app_code": "0115",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001516DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2015,
   "fund_oblg_amt": 500000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p><span>Automated logic reasoning has been one of the primary advances that has spurred the area of verifying software for reliability and security. Automatic logical reasoning engines like SMT solvers based on decidable logics have been widely used in verification, testing, and debugging tools. However, the logics that are truly needed for reasoning in these domains go much beyond the capabilities of decidable logics.</span></p>\n<p><span>The goals of this project were to advance the field of automated reasoning for logics that involve both quantification and recursive definitions, which are crucial for reasoning with programs that manipulate data structures.</span></p>\n<p><span>The project's main outcomes are:</span></p>\n<p><span>(a) An investigation of a new class of techniques called natural proofs that mimic human proofs. These techniques use focused quantifier instantiation and unfolding of recursive definitions, and reduce reasoning to decidable logic engines, iteratively.</span></p>\n<p><span>(b) Automation techniques and tools based on natural proofs, including tools to realize them using SMT solvers.</span></p>\n<p><span>(c) Development of techniques based on natural proofs for verification of programs manipulating data structures. In particular, natural proof techniques were developed for dialects of separation logic translated to first-order logics with recursive definitions.</span></p>\n<p><span>(d) Development of verification tools for programs manipulating data structures, including integration of natural proofs into the VCC verification engine for C programs,</span></p>\n<p><span>(e) A foundational and fundamental understanding of when and why natural proof heuristics work. In particular, identification of logics where the natural proof heuristics form a complete method for reasoning.</span></p>\n<p><span>(f) Techniques for automatically&nbsp;synthesizing invariants for programs so that they facilitate their verification using natural proofs. These techniques were based on learning invariants using concrete models that provide evidence of failure to prove the program correct.</span></p>\n<p><span>The project has advanced the field of automated reasoning for logics that are highly undecidable by developing both theoretically sound and practically viable techniques called natural proofs, and shown the efficacy of natural proofs in applications to program verification.</span></p>\n<p>&nbsp;</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 07/09/2020<br>\n\t\t\t\t\tModified by: Madhusudan&nbsp;Parthasarathy</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nAutomated logic reasoning has been one of the primary advances that has spurred the area of verifying software for reliability and security. Automatic logical reasoning engines like SMT solvers based on decidable logics have been widely used in verification, testing, and debugging tools. However, the logics that are truly needed for reasoning in these domains go much beyond the capabilities of decidable logics.\n\nThe goals of this project were to advance the field of automated reasoning for logics that involve both quantification and recursive definitions, which are crucial for reasoning with programs that manipulate data structures.\n\nThe project's main outcomes are:\n\n(a) An investigation of a new class of techniques called natural proofs that mimic human proofs. These techniques use focused quantifier instantiation and unfolding of recursive definitions, and reduce reasoning to decidable logic engines, iteratively.\n\n(b) Automation techniques and tools based on natural proofs, including tools to realize them using SMT solvers.\n\n(c) Development of techniques based on natural proofs for verification of programs manipulating data structures. In particular, natural proof techniques were developed for dialects of separation logic translated to first-order logics with recursive definitions.\n\n(d) Development of verification tools for programs manipulating data structures, including integration of natural proofs into the VCC verification engine for C programs,\n\n(e) A foundational and fundamental understanding of when and why natural proof heuristics work. In particular, identification of logics where the natural proof heuristics form a complete method for reasoning.\n\n(f) Techniques for automatically synthesizing invariants for programs so that they facilitate their verification using natural proofs. These techniques were based on learning invariants using concrete models that provide evidence of failure to prove the program correct.\n\nThe project has advanced the field of automated reasoning for logics that are highly undecidable by developing both theoretically sound and practically viable techniques called natural proofs, and shown the efficacy of natural proofs in applications to program verification.\n\n \n\n\t\t\t\t\tLast Modified: 07/09/2020\n\n\t\t\t\t\tSubmitted by: Madhusudan Parthasarathy"
 }
}