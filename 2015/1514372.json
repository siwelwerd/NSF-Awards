{
 "awd_id": "1514372",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Medium: Automating robot programming through constraint solving and motion planning",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927991",
 "po_email": "namla@nsf.gov",
 "po_sign_block_name": "Nina Amla",
 "awd_eff_date": "2015-07-01",
 "awd_exp_date": "2021-06-30",
 "tot_intn_awd_amt": 799999.0,
 "awd_amount": 815999.0,
 "awd_min_amd_letter_date": "2015-06-17",
 "awd_max_amd_letter_date": "2020-06-02",
 "awd_abstract_narration": "The project aims to develop a high-level programming framework, called Robosynth, for personal robots. Here, rather than writing low-level code that defines how a robot must perform a task, the user of the robot writes a specification that defines what is to be accomplished. Given this specification and a model of the robot's environment, Robosynth automatically synthesizes a program that can be executed on the robot. So long as the environment behaves according to the assumed model, all executions of this program are guaranteed to satisfy the user-defined requirements.This approach and its derivatives can make robot programming accessible to a vast untapped body of inexperienced programmers.\r\n\r\nThe technical highlights of the project are the specification language using which users interact with Robosynth, and the algorithms that Robosynth uses for automatic code synthesis. These algorithms simultaneously reason about a logical task level that is concerned with the high-level goals of the robot, as well as a continuous motion level concerned with navigating and manipulating a physical space. At the task level, Robosynth leverages recent methods for analyzing complex systems of logical constraints, for example SMT-solving and symbolic solution of graph games. Motion-level reasoning is performed using sampling-based motion planning techniques.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Lydia",
   "pi_last_name": "Kavraki",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Lydia Kavraki",
   "pi_email_addr": "kavraki@cs.rice.edu",
   "nsf_id": "000489055",
   "pi_start_date": "2020-06-02",
   "pi_end_date": null
  },
  {
   "pi_role": "Former Principal Investigator",
   "pi_first_name": "Swarat",
   "pi_last_name": "Chaudhuri",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Swarat Chaudhuri",
   "pi_email_addr": "swarat@cs.utexas.edu",
   "nsf_id": "000504208",
   "pi_start_date": "2015-06-17",
   "pi_end_date": "2020-06-02"
  },
  {
   "pi_role": "Former Co-Principal Investigator",
   "pi_first_name": "Lydia",
   "pi_last_name": "Kavraki",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Lydia Kavraki",
   "pi_email_addr": "kavraki@cs.rice.edu",
   "nsf_id": "000489055",
   "pi_start_date": "2015-06-17",
   "pi_end_date": "2020-06-02"
  }
 ],
 "inst": {
  "inst_name": "William Marsh Rice University",
  "inst_street_address": "6100 MAIN ST",
  "inst_street_address_2": "",
  "inst_city_name": "Houston",
  "inst_state_code": "TX",
  "inst_state_name": "Texas",
  "inst_phone_num": "7133484820",
  "inst_zip_code": "770051827",
  "inst_country_name": "United States",
  "cong_dist_code": "09",
  "st_cong_dist_code": "TX09",
  "org_lgl_bus_name": "WILLIAM MARSH RICE UNIVERSITY",
  "org_prnt_uei_num": "",
  "org_uei_num": "K51LECU1G8N3"
 },
 "perf_inst": {
  "perf_inst_name": "William Marsh Rice University",
  "perf_str_addr": "6100 Main St",
  "perf_city_name": "Houston",
  "perf_st_code": "TX",
  "perf_st_name": "Texas",
  "perf_zip_code": "770051827",
  "perf_ctry_code": "US",
  "perf_cong_dist": "09",
  "perf_st_cong_dist": "TX09",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  },
  {
   "pgm_ref_code": "7924",
   "pgm_ref_txt": "MEDIUM PROJECT"
  },
  {
   "pgm_ref_code": "8206",
   "pgm_ref_txt": "Formal Methods and Verification"
  }
 ],
 "app_fund": [
  {
   "app_code": "0117",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001718DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0115",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001516DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2015,
   "fund_oblg_amt": 799999.0
  },
  {
   "fund_oblg_fiscal_yr": 2017,
   "fund_oblg_amt": 16000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>We are entering an era of ubiquitous robots, in which robots will no longer be expensive fixtures of laboratories and factory floors, but they will become part of our everyday lives. In the future, robots will serve as our domestic servants, will clean our kitchens, and drive our cars. Two crucial requirements for this coming era of robotics are programmability and reliability. Increasingly, we will have robots that are not hardwired to do certain tasks, but are, instead, general-purpose machines that can execute a wide range of programs on command from people without deep technical skills. This requires that robot programming be as productive as possible. At the same time, as autonomous agents that may interact with humans, robots need to be reliable. Our project developed tools for computer-aided programming of robots that make it easier to meet these goals.</p>\n<p>The primary technical challenge in the project to simultaneously deal with two distinct levels of abstraction: the \"task level\" and the \"motion level.? The task level is discrete and concerned with the high-level goals of the robot, while the motion level is concerned with navigating and manipulating a continuous physical space. We first studied the problem of integrated task and motion planning, where the robot is given a high-level objective and needs to find the motions that will achieve this objective, in the special case when the robot's environment is static. We developed an algorithm for the problem that used a Satisfiability Modulo Theories (SMT) solver for task-level reasoning. By exploiting the incremental solution capabilities of SMT solvers, we managed to dynamically incorporate motion feasibility at the task level, which we leveraged to improve scalability and guarantee the probabilistic completeness of the overall approach.</p>\n<p>We also considered changing environments with uncontrollable agents, where the robot needs a policy to respond correctly over the infinite-horizon interaction with the environment. Our approach again combines actions over discrete states with continuous, collision-free paths. We synthesize a task and motion policy by iteratively generating a candidate policy and verifying its correctness. For efficient policy generation, we use grammars for potential policies to limit the search space. For efficient policy verification, we construct compact, symbolic constraints for valid policies and employ a SMT solver to check the validity of these constraints.</p>\n<p>We then turned our attention to planning robot executions under uncertainty, a fundamental challenge for building autonomous robots. Partially Observable Markov Decision Processes (POMDPs) provide a standard framework for modeling uncertainty in many applications. We studied POMDPs with boolean objectives focusing on safe-reachability objectives, which require that with a probability above some threshold, a goal state is eventually reached while keeping the probability of visiting unsafe states below some threshold. POMDPs with safe-reachability objectives can provide a better guarantee of both safety and reachability than traditional POMDPs with optimality objectives. A key algorithmic problem for POMDPs is policy synthesis, which requires reasoning over a vast space of beliefs (probability distributions). To address this challenge, we introduced the notion of a goal-constrained belief space, which only contains beliefs reachable from the initial belief under desired executions that can achieve the given safe reachability objective. Our method compactly represents this space over a bounded horizon using symbolic constraints, and it employs an incremental SMT solver to efficiently search for a valid policy over it. The solutions to POMDPs are policies or conditional plans that specify the action to take contingent on every possible event. A full policy or conditional plan that covers all possible events generally proved expensive to compute. To improve efficiency, we introduced the notion of partial conditional plans that only cover a sampled subset of all possible events. Our approach constructed a partial conditional plan parameterized by a replanning probability. We proved that the probability of the constructed partial conditional plan failing is bounded by the replanning probability. Our approach allows users to specify an appropriate bound on the replanning probability to balance efficiency and correctness. We lastly presented a practical policy synthesis approach for POMDPs with boolean and quantitative objectives by combining policy iteration and policy synthesis for POMDPs with only boolean objectives. To improve efficiency, our approach produces approximate policies by performing the point-based backup on a small set of representative beliefs. Despite being approximate, our approach maintains validity (satisfying boolean objectives) and guarantees improved policies at each iteration before termination. Moreover, the error due to approximation is bounded. All approaches developed in this project were validated in complex scenarios using a mobile manipulator.</p>\n<p>This project trained two PhD students and two postdocs. Four undergraduates were involved in performing research experiments. Our work has been broadly disseminated with an Open Source license. We presented our research at conferences and invited lectures, and the PIs incorporated part of their findings in their classes either through lectures or project assignments.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 08/30/2021<br>\n\t\t\t\t\tModified by: Lydia&nbsp;Kavraki</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nWe are entering an era of ubiquitous robots, in which robots will no longer be expensive fixtures of laboratories and factory floors, but they will become part of our everyday lives. In the future, robots will serve as our domestic servants, will clean our kitchens, and drive our cars. Two crucial requirements for this coming era of robotics are programmability and reliability. Increasingly, we will have robots that are not hardwired to do certain tasks, but are, instead, general-purpose machines that can execute a wide range of programs on command from people without deep technical skills. This requires that robot programming be as productive as possible. At the same time, as autonomous agents that may interact with humans, robots need to be reliable. Our project developed tools for computer-aided programming of robots that make it easier to meet these goals.\n\nThe primary technical challenge in the project to simultaneously deal with two distinct levels of abstraction: the \"task level\" and the \"motion level.? The task level is discrete and concerned with the high-level goals of the robot, while the motion level is concerned with navigating and manipulating a continuous physical space. We first studied the problem of integrated task and motion planning, where the robot is given a high-level objective and needs to find the motions that will achieve this objective, in the special case when the robot's environment is static. We developed an algorithm for the problem that used a Satisfiability Modulo Theories (SMT) solver for task-level reasoning. By exploiting the incremental solution capabilities of SMT solvers, we managed to dynamically incorporate motion feasibility at the task level, which we leveraged to improve scalability and guarantee the probabilistic completeness of the overall approach.\n\nWe also considered changing environments with uncontrollable agents, where the robot needs a policy to respond correctly over the infinite-horizon interaction with the environment. Our approach again combines actions over discrete states with continuous, collision-free paths. We synthesize a task and motion policy by iteratively generating a candidate policy and verifying its correctness. For efficient policy generation, we use grammars for potential policies to limit the search space. For efficient policy verification, we construct compact, symbolic constraints for valid policies and employ a SMT solver to check the validity of these constraints.\n\nWe then turned our attention to planning robot executions under uncertainty, a fundamental challenge for building autonomous robots. Partially Observable Markov Decision Processes (POMDPs) provide a standard framework for modeling uncertainty in many applications. We studied POMDPs with boolean objectives focusing on safe-reachability objectives, which require that with a probability above some threshold, a goal state is eventually reached while keeping the probability of visiting unsafe states below some threshold. POMDPs with safe-reachability objectives can provide a better guarantee of both safety and reachability than traditional POMDPs with optimality objectives. A key algorithmic problem for POMDPs is policy synthesis, which requires reasoning over a vast space of beliefs (probability distributions). To address this challenge, we introduced the notion of a goal-constrained belief space, which only contains beliefs reachable from the initial belief under desired executions that can achieve the given safe reachability objective. Our method compactly represents this space over a bounded horizon using symbolic constraints, and it employs an incremental SMT solver to efficiently search for a valid policy over it. The solutions to POMDPs are policies or conditional plans that specify the action to take contingent on every possible event. A full policy or conditional plan that covers all possible events generally proved expensive to compute. To improve efficiency, we introduced the notion of partial conditional plans that only cover a sampled subset of all possible events. Our approach constructed a partial conditional plan parameterized by a replanning probability. We proved that the probability of the constructed partial conditional plan failing is bounded by the replanning probability. Our approach allows users to specify an appropriate bound on the replanning probability to balance efficiency and correctness. We lastly presented a practical policy synthesis approach for POMDPs with boolean and quantitative objectives by combining policy iteration and policy synthesis for POMDPs with only boolean objectives. To improve efficiency, our approach produces approximate policies by performing the point-based backup on a small set of representative beliefs. Despite being approximate, our approach maintains validity (satisfying boolean objectives) and guarantees improved policies at each iteration before termination. Moreover, the error due to approximation is bounded. All approaches developed in this project were validated in complex scenarios using a mobile manipulator.\n\nThis project trained two PhD students and two postdocs. Four undergraduates were involved in performing research experiments. Our work has been broadly disseminated with an Open Source license. We presented our research at conferences and invited lectures, and the PIs incorporated part of their findings in their classes either through lectures or project assignments.\n\n\t\t\t\t\tLast Modified: 08/30/2021\n\n\t\t\t\t\tSubmitted by: Lydia Kavraki"
 }
}