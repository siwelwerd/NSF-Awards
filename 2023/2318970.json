{
 "awd_id": "2318970",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "Collaborative Research: FMitF: Track I: Game Theoretic Updates for Network and Cloud Functions",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032922585",
 "po_email": "pprabhak@nsf.gov",
 "po_sign_block_name": "Pavithra Prabhakar",
 "awd_eff_date": "2023-01-15",
 "awd_exp_date": "2024-12-31",
 "tot_intn_awd_amt": 355000.0,
 "awd_amount": 283855.0,
 "awd_min_amd_letter_date": "2023-03-21",
 "awd_max_amd_letter_date": "2023-03-21",
 "awd_abstract_narration": "Updates are common in cloud-computing networks, and they occur for many reasons. Some network updates are planned while others are unplanned and automated. Since network updates can take seconds or minutes to complete, and cloud-computing networks must be \"always on\", updates must be efficient and transparent. Researchers have proposed various abstractions for network updating that leverage advances in formal methods to synthesize update plans and protocols, ensuring that the system remains well-behaved during an ongoing update. However, despite several high-profile cases of network updates gone wrong, operators continue to use relatively naive approaches. We investigate key shortcomings of prior work on update abstractions that limit their utility and widespread use in practice, and develop a new abstraction that addresses the heterogeneity, scale, and dynamic nature of real-world updates. The project's novelties are (1) a new game-theoretic foundation for network updates, (2) algorithms for synthesizing update controllers that are robust to failures and changing conditions during the update, (3) algorithms for explaining update failures, (4) a language design that allows synthesized controllers to be safely modified, and (5) implementations and evaluations of these mechanisms for virtual network functions and serverless-computing platforms. The project provides network operators with tools that make updates to networked systems easier, safer, and more reliable, and develops a framework that makes datacenter computing more reliable and secure.\r\n\r\nSome specific key shortcomings of previous work on network updates are the following. (1) They assume that the network behaves predictably during the update. However, at scale, network demands and concurrent updates can cause unpredictable or even adversarial behavior in response to the update. (2) They have limited explanatory power when an update plan cannot be found or cannot be completed. (3) They make it hard for operators to choose between alternative update plans. This project consists of a comprehensive research plan to address these shortcomings. The key technical innovation is a formulation of updates as the search for a winning strategy in a two-player game, between the operator (or control plane) and the network. This formulation allows a uniform modeling of key elements, including hardware and software failures, variations in demand, and the addition and removal of network elements. To produce updates that are robust to changing conditions and failures, this work uses program-synthesis techniques to automatically generate an update controller that corresponds to a winning strategy in the game. To help operators when fatal errors occur, the project develops algorithms that exploit this game-theoretic formulation to explain the root cause of update failures and present alternatives. Finally, to give operators more control over updates, the investigators develop approaches for synthesizing update controllers that are interpretable and modifiable. The game-theoretic formulation is applicable to several kinds of networked systems, and the project will instantiate and evaluate our tools for platforms that implement virtual network functions and serverless functions.\r\n\r\nThis award reflects NSF's statutory mission and has been deemed worthy of support through evaluation using the Foundation's intellectual merit and broader impacts review criteria.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Jedidiah",
   "pi_last_name": "McClurg",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Jedidiah McClurg",
   "pi_email_addr": "mcclurg@colostate.edu",
   "nsf_id": "000780303",
   "pi_start_date": "2023-03-21",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Colorado State University",
  "inst_street_address": "601 S HOWES ST",
  "inst_street_address_2": "",
  "inst_city_name": "FORT COLLINS",
  "inst_state_code": "CO",
  "inst_state_name": "Colorado",
  "inst_phone_num": "9704916355",
  "inst_zip_code": "805212807",
  "inst_country_name": "United States",
  "cong_dist_code": "02",
  "st_cong_dist_code": "CO02",
  "org_lgl_bus_name": "COLORADO STATE UNIVERSITY",
  "org_prnt_uei_num": "",
  "org_uei_num": "LT9CXX8L19G1"
 },
 "perf_inst": {
  "perf_inst_name": "Colorado State University",
  "perf_str_addr": "601 S HOWES ST",
  "perf_city_name": "FORT COLLINS",
  "perf_st_code": "CO",
  "perf_st_name": "Colorado",
  "perf_zip_code": "805212807",
  "perf_ctry_code": "US",
  "perf_cong_dist": "02",
  "perf_st_cong_dist": "CO02",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "094Y00",
   "pgm_ele_name": "FMitF: Formal Methods in the F"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "071Z",
   "pgm_ref_txt": "FMitF-Formal Methods in the Field"
  },
  {
   "pgm_ref_code": "8206",
   "pgm_ref_txt": "Formal Methods and Verification"
  }
 ],
 "app_fund": [
  {
   "app_code": "",
   "app_name": "",
   "app_symb_id": "",
   "fund_code": "01002021DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2020,
   "fund_oblg_amt": 283855.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>This project had the following outcomes.</p>\r\n<p>The first outcome of this project was TacTok, an approach to automate proof-writing using large language models. Interactive theorem provers, such as the Coq Proof Assistant, have been used for several years to build sophisticated verified systems. However, even with automation, it takes significant human effort to write proofs for theorem provers. This project developed TacTok, one of the first methods of automatically completing proofs for Coq that leveraged large language models (LLMs). The work appeared in 2020 and has since spurred several follow-up works on automating proof writing for Coq.</p>\r\n<p>The second outcome of this project was rewrite-guided synthesis (ReGiS). Prior work on program synthesis fails to fully exploit the fact that in many domains, a synthesizer can reason both syntactically and semantically. ReGiS is a new form of program synthesis that uses both syntactic (rewrite-rule-based) and semantic (equality-checking-based) domain knowledge to improve synthesizer efficiency.</p>\r\n<p>The third outcome of this project was MultiPL-E, the first massively-multilingual programming benchmark for large language models (LLMs). The MultiPL-E benchmark supports 20+ programming languages and was the first benchmark to quantify how LLMs capabilities vary by programming languages. MultiPL-E has become the de facto standard benchmark for assessing LLMs on non-Python programming languages. It is cited and used to evaluate most recent LLMs trained on code, including Meta Llama 3, IBM Granite Code Models, BigCode StarCoder 2, Mistral Large 2, and others.</p>\r\n<p>The fourth outcome of this project was synthesis of application-specific error correction codes.&nbsp;<span>Forward error correction (FEC) is a key component of modern high-bandwidth networks. Typically implemented at the physical layer, FEC attaches error-correcting codes to blocks of transmitted data, allowing some corrupted blocks to be repaired without retransmission. This project developed a synthesis-based approach for automatic exploration of the FEC-code design space, focusing on Hamming codes. The project formally verified the correctness of a Hamming (128, 120) code used for FEC in the recent 802.3df Ethernet standard, and provided preliminary evidence that the prototype synthesizer can leverage user-provided formal properties to generate FEC codes that are highly robust, efficiently implementable, and tuned to support specific data formats such as IEEE floating points.</span></p><br>\n<p>\n Last Modified: 03/17/2025<br>\nModified by: Jedidiah&nbsp;McClurg</p></div>\n<div class=\"porSideCol\"\n></div>\n</div>\n",
  "por_txt_cntn": "\n\nThis project had the following outcomes.\r\n\n\nThe first outcome of this project was TacTok, an approach to automate proof-writing using large language models. Interactive theorem provers, such as the Coq Proof Assistant, have been used for several years to build sophisticated verified systems. However, even with automation, it takes significant human effort to write proofs for theorem provers. This project developed TacTok, one of the first methods of automatically completing proofs for Coq that leveraged large language models (LLMs). The work appeared in 2020 and has since spurred several follow-up works on automating proof writing for Coq.\r\n\n\nThe second outcome of this project was rewrite-guided synthesis (ReGiS). Prior work on program synthesis fails to fully exploit the fact that in many domains, a synthesizer can reason both syntactically and semantically. ReGiS is a new form of program synthesis that uses both syntactic (rewrite-rule-based) and semantic (equality-checking-based) domain knowledge to improve synthesizer efficiency.\r\n\n\nThe third outcome of this project was MultiPL-E, the first massively-multilingual programming benchmark for large language models (LLMs). The MultiPL-E benchmark supports 20+ programming languages and was the first benchmark to quantify how LLMs capabilities vary by programming languages. MultiPL-E has become the de facto standard benchmark for assessing LLMs on non-Python programming languages. It is cited and used to evaluate most recent LLMs trained on code, including Meta Llama 3, IBM Granite Code Models, BigCode StarCoder 2, Mistral Large 2, and others.\r\n\n\nThe fourth outcome of this project was synthesis of application-specific error correction codes.Forward error correction (FEC) is a key component of modern high-bandwidth networks. Typically implemented at the physical layer, FEC attaches error-correcting codes to blocks of transmitted data, allowing some corrupted blocks to be repaired without retransmission. This project developed a synthesis-based approach for automatic exploration of the FEC-code design space, focusing on Hamming codes. The project formally verified the correctness of a Hamming (128, 120) code used for FEC in the recent 802.3df Ethernet standard, and provided preliminary evidence that the prototype synthesizer can leverage user-provided formal properties to generate FEC codes that are highly robust, efficiently implementable, and tuned to support specific data formats such as IEEE floating points.\t\t\t\t\tLast Modified: 03/17/2025\n\n\t\t\t\t\tSubmitted by: JedidiahMcClurg\n"
 }
}