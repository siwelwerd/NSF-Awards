{
 "awd_id": "1745748",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: SMALL: Collaborative Research: Improving Reliability of In-Memory Storage",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927498",
 "po_email": "achtchel@nsf.gov",
 "po_sign_block_name": "Almadena Chtchelkanova",
 "awd_eff_date": "2017-06-26",
 "awd_exp_date": "2022-07-31",
 "tot_intn_awd_amt": 176876.0,
 "awd_amount": 200636.0,
 "awd_min_amd_letter_date": "2017-07-14",
 "awd_max_amd_letter_date": "2021-05-27",
 "awd_abstract_narration": "Emerging nonvolatile memory (NVM) technologies, such as PCM, STT-RAM, and memristors, provide not only byte-addressability, low-latency reads and writes comparable to DRAM, but also persistent writes and potentially large storage capacity like an SSD. These advantages make NVM likely to be next-generation fast persistent storage for massive data, referred to as in-memory storage. Yet, NVM-based storage has two challenges: (1) Memory cells have limited write endurance (i.e., the total number of program/erase cycles per cell); (2) NVM has to remain in a consistent state in the event of a system crash or power loss. The goal of this project is to develop an efficient in-memory storage framework that addresses these two challenges. This project involves undergraduate and graduate students. All software artifacts and tools will be made available to the wider research community. The work has broader industrial and economic impact since it will help improve the reliability of data storage systems for data centers and HPC applications. \r\n\r\nThis project will take a holistic approach, spanning from low-level architecture design to high-level OS management, to optimize the reliability, performance, and manageability of in-memory storage. The technical approach will involve understanding the implication and impact of the write endurance issue when cutting-edge NVM is adopted into storage systems. The improved understanding will motivate and aid the design of cost-effective methods to improve the life-time of in-memory storage and to achieve efficient and reliable consistence maintenance.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Jianhui",
   "pi_last_name": "Yue",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Jianhui Yue",
   "pi_email_addr": "jyue@mtu.edu",
   "nsf_id": "000709774",
   "pi_start_date": "2017-07-14",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Michigan Technological University",
  "inst_street_address": "1400 TOWNSEND DR",
  "inst_street_address_2": "",
  "inst_city_name": "HOUGHTON",
  "inst_state_code": "MI",
  "inst_state_name": "Michigan",
  "inst_phone_num": "9064871885",
  "inst_zip_code": "499311200",
  "inst_country_name": "United States",
  "cong_dist_code": "01",
  "st_cong_dist_code": "MI01",
  "org_lgl_bus_name": "MICHIGAN TECHNOLOGICAL UNIVERSITY",
  "org_prnt_uei_num": "GKMSN3DA6P91",
  "org_uei_num": "GKMSN3DA6P91"
 },
 "perf_inst": {
  "perf_inst_name": "Michigan Technological University",
  "perf_str_addr": "1400 Townsend Drive",
  "perf_city_name": "Houghton",
  "perf_st_code": "MI",
  "perf_st_name": "Michigan",
  "perf_zip_code": "499311295",
  "perf_ctry_code": "US",
  "perf_cong_dist": "01",
  "perf_st_cong_dist": "MI01",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "287800",
   "pgm_ele_name": "Special Projects - CCF"
  },
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7941",
   "pgm_ref_txt": "COMPUTER ARCHITECTURE"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  }
 ],
 "app_fund": [
  {
   "app_code": "0116",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001617DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0119",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001920DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0120",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01002021DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2016,
   "fund_oblg_amt": 176876.0
  },
  {
   "fund_oblg_fiscal_yr": 2019,
   "fund_oblg_amt": 15840.0
  },
  {
   "fund_oblg_fiscal_yr": 2020,
   "fund_oblg_amt": 7920.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p><span>This Project Outcomes Report for the General Public is displayed verbatim as submitted by the Principal Investigator (PI) for this award. Any opinions, findings, and conclusions or recommendations expressed in this Report are those of the PI and do not necessarily reflect the views of the National Science Foundation; NSF has not approved or endorsed its content.</span></p>\n<p><span><span>Persistent memory (PM) successfully bridges the gap between memory and storage.&nbsp; However, one important challenge in adopting PM into real systems is the efficiency of crash consistency, which is to guarantee the atomicity of transaction updates in the event of system crash or power loss.&nbsp;</span></span></p>\n<p><span>We discover two common factors that contribute to the inefficiency of logging: (1) load imbalance among memory banks, and (2) constraints of intra-record ordering. Overloaded memory banks may significantly prolong the waiting time of log requests targeting these banks. To address this issue, we propose a novel log entry allocation scheme (LALEA) that reshapes the traffic distribution over PM banks. In addition, the intra-record ordering between a header and its log entries decreases the degree of parallelism in log operations. We design a log metadata buffering scheme (BLOM) that eliminates the intra-record ordering constraints.</span></p>\n<p>Shadow paging can guarantee crash consistency for PM. However, shadow paging requires the use of an address mapping table to track shadow pages, and frequent accesses to this table introduce significant performance overhead. In addition, maintaining crash consistency at the granularity level of a page causes a large amount of unnecessary write traffic. We propose a novel hardware-assisted fine-grained out-place-update scheme at the granularity level of a cacheline to efficiently support crash consistency for PM. Our design fully leverages the Address Indirection Table (AIT) available in commodity PM to implement remapping. To ensure the atomicity and durability of AIT updates, we propose two policies: eager persisting and lazy persisting. We also employ overflow log to handle the eviction of speculative AIT cache entries upon an overflow in the AIT cache.</p>\n<p><span>Recently, LAD was proposed to remove log operations for some transactions by using Asynchronous DRAM Refresh (ADR) buffer, without affecting crash consistency. However, LAD introduces uncessary logging opertions&nbsp; on multicore.<span>&nbsp;</span></span>To remove these unnecessary log operations, we design a new transaction execution scheme, called two-stage transaction execution that allows the write requests of a transaction to be in both the ADR buffer and the staging SRAM buffer.</p>\n<p>Maintaining both crash consistency and security for PM is challenging not only for the system design but also for programmers. To address this issue, we propose a hardware-assisted data persistent and secure PM system using counter mode memory encryption, requiring minimal programming efforts. The&nbsp;write amplification caused by logging and encryption metadata not only deteriorates the slow PM writing issue but also reduces the lifespan of PM. To mitigate the aforementioned write amplification issue, we propose to apply counter-based and CFB encryption methods for data and log entries respectively. In addition, the conventional memory encryption scheme fails to hide memory encryption latency for a memory write operation and this encryption latency is on the critical path for log entry write operations, which is required for crash consistency, degrading system performance. We propose a novel Log-Aware Memory Encryption (LAME) scheme to reduce encryption/decryption operations, without compromising data security.&nbsp;&nbsp;Specifically, LAME encrypts the updated data block with its security metadata and stores the ciphertext in the log entry, avoiding encryption/decryption operations of log data blocks in the process of in-place updating log entries. Furthermore, to mitigate the persistent overhead of encryption metadata in log records, we design a novel compact log record layout for logging encryption metadata efficiently.</p>\n<p>Due to the large storage capacity, high bandwidth and low latency, 3D DRAM is proposed to be the last level cache, referred to as DRAM cache.&nbsp;The hit rate and hit latency are two conflicting optimization goals for DRAM cache. To address this issue, we have designed a novel DRAM cache organization to simultaneously achieve a good hit rate and shorter latency.</p>\n<p>Graph random walk is widely used in the graph processing as it is a fundamental component in graph analysis.&nbsp;Different from traditional graph processing workload, random walk features massive processing parallelisms and poor graph data reuse, being limited by low I/O efficiency.&nbsp;To address this issue, we propose FlashWalker, an in-storage accelerator for random walk that moves walk updating close to graph data stored in flash memory, by exploiting significant parallelisms inside SSD. By exploiting significant parallelisms inside SSD. Featuring a heterogeneous and parallel processing system, FlashWalker includes a board-level accelerator, channel-level accelerators, and chip-level accelerators. To address challenges posed by the tight resource constraints for processing large-scale graphs, we propose novel designs: storing a few popular subgraphs in accelerators, the pre-walking for dense walks, two optimizations to search the subgraph mapping table, and a subgraph scheduling algorithm.</p>\n<p><span><span><br /></span></span></p><br>\n<p>\n\t\t\t\t      \tLast Modified: 11/30/2022<br>\n\t\t\t\t\tModified by: Jianhui&nbsp;Yue</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nThis Project Outcomes Report for the General Public is displayed verbatim as submitted by the Principal Investigator (PI) for this award. Any opinions, findings, and conclusions or recommendations expressed in this Report are those of the PI and do not necessarily reflect the views of the National Science Foundation; NSF has not approved or endorsed its content.\n\nPersistent memory (PM) successfully bridges the gap between memory and storage.  However, one important challenge in adopting PM into real systems is the efficiency of crash consistency, which is to guarantee the atomicity of transaction updates in the event of system crash or power loss. \n\nWe discover two common factors that contribute to the inefficiency of logging: (1) load imbalance among memory banks, and (2) constraints of intra-record ordering. Overloaded memory banks may significantly prolong the waiting time of log requests targeting these banks. To address this issue, we propose a novel log entry allocation scheme (LALEA) that reshapes the traffic distribution over PM banks. In addition, the intra-record ordering between a header and its log entries decreases the degree of parallelism in log operations. We design a log metadata buffering scheme (BLOM) that eliminates the intra-record ordering constraints.\n\nShadow paging can guarantee crash consistency for PM. However, shadow paging requires the use of an address mapping table to track shadow pages, and frequent accesses to this table introduce significant performance overhead. In addition, maintaining crash consistency at the granularity level of a page causes a large amount of unnecessary write traffic. We propose a novel hardware-assisted fine-grained out-place-update scheme at the granularity level of a cacheline to efficiently support crash consistency for PM. Our design fully leverages the Address Indirection Table (AIT) available in commodity PM to implement remapping. To ensure the atomicity and durability of AIT updates, we propose two policies: eager persisting and lazy persisting. We also employ overflow log to handle the eviction of speculative AIT cache entries upon an overflow in the AIT cache.\n\nRecently, LAD was proposed to remove log operations for some transactions by using Asynchronous DRAM Refresh (ADR) buffer, without affecting crash consistency. However, LAD introduces uncessary logging opertions  on multicore. To remove these unnecessary log operations, we design a new transaction execution scheme, called two-stage transaction execution that allows the write requests of a transaction to be in both the ADR buffer and the staging SRAM buffer.\n\nMaintaining both crash consistency and security for PM is challenging not only for the system design but also for programmers. To address this issue, we propose a hardware-assisted data persistent and secure PM system using counter mode memory encryption, requiring minimal programming efforts. The write amplification caused by logging and encryption metadata not only deteriorates the slow PM writing issue but also reduces the lifespan of PM. To mitigate the aforementioned write amplification issue, we propose to apply counter-based and CFB encryption methods for data and log entries respectively. In addition, the conventional memory encryption scheme fails to hide memory encryption latency for a memory write operation and this encryption latency is on the critical path for log entry write operations, which is required for crash consistency, degrading system performance. We propose a novel Log-Aware Memory Encryption (LAME) scheme to reduce encryption/decryption operations, without compromising data security.  Specifically, LAME encrypts the updated data block with its security metadata and stores the ciphertext in the log entry, avoiding encryption/decryption operations of log data blocks in the process of in-place updating log entries. Furthermore, to mitigate the persistent overhead of encryption metadata in log records, we design a novel compact log record layout for logging encryption metadata efficiently.\n\nDue to the large storage capacity, high bandwidth and low latency, 3D DRAM is proposed to be the last level cache, referred to as DRAM cache. The hit rate and hit latency are two conflicting optimization goals for DRAM cache. To address this issue, we have designed a novel DRAM cache organization to simultaneously achieve a good hit rate and shorter latency.\n\nGraph random walk is widely used in the graph processing as it is a fundamental component in graph analysis. Different from traditional graph processing workload, random walk features massive processing parallelisms and poor graph data reuse, being limited by low I/O efficiency. To address this issue, we propose FlashWalker, an in-storage accelerator for random walk that moves walk updating close to graph data stored in flash memory, by exploiting significant parallelisms inside SSD. By exploiting significant parallelisms inside SSD. Featuring a heterogeneous and parallel processing system, FlashWalker includes a board-level accelerator, channel-level accelerators, and chip-level accelerators. To address challenges posed by the tight resource constraints for processing large-scale graphs, we propose novel designs: storing a few popular subgraphs in accelerators, the pre-walking for dense walks, two optimizations to search the subgraph mapping table, and a subgraph scheduling algorithm.\n\n\n\n\n\t\t\t\t\tLast Modified: 11/30/2022\n\n\t\t\t\t\tSubmitted by: Jianhui Yue"
 }
}