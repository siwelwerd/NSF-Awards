{
 "awd_id": "1707371",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "RI: Small: Automated Optimization of Programs and Processing Tools in Answer Set Programming",
 "cfda_num": "47.070",
 "org_code": "05020000",
 "po_phone": null,
 "po_email": "",
 "po_sign_block_name": "Roger Mailler",
 "awd_eff_date": "2017-09-01",
 "awd_exp_date": "2022-08-31",
 "tot_intn_awd_amt": 499544.0,
 "awd_amount": 553496.0,
 "awd_min_amd_letter_date": "2017-07-28",
 "awd_max_amd_letter_date": "2019-03-14",
 "awd_abstract_narration": "Answer Set Programming (ASP) is a form of knowledge representation and declarative constraint programming used to represent and solve constraint satisfaction problems.  ASP has its roots in the need to support fast design of robust and reliable software solutions for complex knowledge-intensive applications. It provides a high-level programming paradigm for modeling an application domain as a theory in a language of logic, and leaves all computational concerns to automated reasoning. ASP has been used in a variety of scientific and industrial applications, including product configuration, decision support systems, and repairing large-scale biological networks.\r\n \r\nThis project aims to improve both the specific encoding of the ASP problems, and the performance of the underlying automated reasoner or solver. The project focuses on three related research thrusts, each of which leverages the high-level problem description of ASP.  1) Research in program rewriting will generate alternative encodings for a given problem; 2) the development of solver portfolios will improve overall reasoning performance and provide robustness through availability of alternate solvers for the ASP domain encodings; and 3) parameter tuning will be investigated to improve the performance of individual solvers.  The project will establish an evaluation platform to systematically implement and validate each of these research activities. This evaluation platform will be comprised of both experiment encodings and a collection of benchmark problems from techniques in constraint satisfaction and logic programming as well as related solver competitions.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "IIS",
 "org_div_long_name": "Division of Information & Intelligent Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Yuliya",
   "pi_last_name": "Lierler",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Yuliya Lierler",
   "pi_email_addr": "ylierler@unomaha.edu",
   "nsf_id": "000624828",
   "pi_start_date": "2017-07-28",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Miroslaw",
   "pi_last_name": "Truszczynski",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Miroslaw Truszczynski",
   "pi_email_addr": "mirek@cs.uky.edu",
   "nsf_id": "000342726",
   "pi_start_date": "2017-07-28",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Nebraska at Omaha",
  "inst_street_address": "6001 DODGE ST EAB 209",
  "inst_street_address_2": "",
  "inst_city_name": "OMAHA",
  "inst_state_code": "NE",
  "inst_state_name": "Nebraska",
  "inst_phone_num": "4025542286",
  "inst_zip_code": "681820001",
  "inst_country_name": "United States",
  "cong_dist_code": "02",
  "st_cong_dist_code": "NE02",
  "org_lgl_bus_name": "UNIVERSITY OF NEBRASKA",
  "org_prnt_uei_num": "FZRNFQTKADH1",
  "org_uei_num": "FZRNFQTKADH1"
 },
 "perf_inst": {
  "perf_inst_name": "University of Nebraska at Omaha",
  "perf_str_addr": "",
  "perf_city_name": "Omaha",
  "perf_st_code": "NE",
  "perf_st_name": "Nebraska",
  "perf_zip_code": "681820210",
  "perf_ctry_code": "US",
  "perf_cong_dist": "02",
  "perf_st_cong_dist": "NE02",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "749500",
   "pgm_ele_name": "Robust Intelligence"
  },
  {
   "pgm_ele_code": "915000",
   "pgm_ele_name": "EPSCoR Co-Funding"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7495",
   "pgm_ref_txt": "ROBUST INTELLIGENCE"
  },
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "9150",
   "pgm_ref_txt": "EXP PROG TO STIM COMP RES"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  }
 ],
 "app_fund": [
  {
   "app_code": "0117",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001718DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0118",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001819DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0119",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001920DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2017,
   "fund_oblg_amt": 499544.0
  },
  {
   "fund_oblg_fiscal_yr": 2018,
   "fund_oblg_amt": 29952.0
  },
  {
   "fund_oblg_fiscal_yr": 2019,
   "fund_oblg_amt": 24000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Universities have to schedule lectures to be held at particular times and in particular classrooms. The times have to be acceptable to professors teaching them, and must not conflict with the times of other lectures students are required to take. The rooms must be large enough to accommodate expected enrollments. Problems like this one are known as constraint satisfaction problems. They arise in all areas of life. Often they also involve optimization - solutions we are most interested in should maximize (or minimize) a particular goal function. Typically, constraint satisfactioin and optimization problems are hard in that fast computational systems (often referred to as solvers) guaranteeing good results across wide classes of instances are unlikely to exist.</p>\n<p>Nevertheless, such problems are important and need to be solved. Therefore, researchers are studying algorithms to solve constraint satisfaction problems. One approach is to focus on a single problem and develop specialized algorithms to solve it (possibly with some relaxation of the required constraints) so that the problem could be solved in an acceptable time for some particular problems. Scheduling problems like the one we started with have been extensively studied and good solutions have been developed.</p>\n<p>Another approach consists of developing languages in which constraint satisfaction problems could be formally described, and methods designed to find solutions to problems expressed in those languages. Among those approaches are linear programming (very efficient algorithms for solving problems that can be formulated as linear programming problems are known) and integer programming (here uniformly fast tools are unlikely to exist). An approach based on logic consists of modeling constraint problems as theories in propositional logic. So modeled problems are then solved by the so called satisfiability solvers, which in the last two decades reached very high levels of performance on a broad class of practical problems.</p>\n<p>Answer set programming is similar to this approach in the solving methodology. That is, solvers to find solutions to answer set programs are closely related to those developed for propositional satisfiability. What distinguishes answer set programming from propositional satisfiability is its programming front end, an intuitive programming language that allows the users to capture constraints given in natural language as programs consisting of rules and constraints.</p>\n<p>Answer set programming proved its modeling efficiency in many domains of practical interest. The constraints of the scheduling problem mentioned earlier can be encoded as an answer set program.</p>\n<p>One of the challenges of this approach is that problems typically can be encoded by many similar but different in details answer set programs, some performing well and some performing poorly. It requires a certain level of expertise to write good answer set programs. But even experts cannot overcome another difficulty. Often the same program performs well on some instances and poorly on others. This means that an encoding to use should be selected on the per instance basis. And this is not something humans can do, given that instances are typically large and difficult to analyze.</p>\n<p>The main objective of this project was to address this problem. More specifically, the project aimed at (1) developing algorithms for generating alternative encodings of a problem, (2) using machine learning to build performance models for an encoding, that would estimate the time it would take if run on a particular instance, (3) implementing these algorithms into tools that would improve the performance of answer set solvers, by automating the task of selecting the right encoding to use with an instance. Additional related goals included developing methods to build data sets for experimentation, and further expanding our understanding of answer set programming as a problem solving tool.</p>\n<p>Responding to these objectives, the project resulted in several significant outcomes. First, the team developed several automated ways to rewrite a given encoding into one or more alternative equivalent ones. One approach stemmed from a well known experimental observation that encodings generating smaller programs in the first phase of processing, known as grounding, often perform much better in the second (typically, most time consuming) phase known as solving. Another was based on an observation that modeling certain numeric constraints by specialized aggregating expressions often improves the efficiency of solving.&nbsp; The correctness of the studied rewriting methods was verified.</p>\n<p>Second, we used machine learning to develop algorithms for building performance models for en encoding, assuming a fixed solver. These models estimate the time the solver will take for e given instance. Once a collection of encodings is available and for each of them its performance model was constructed, when a new instance arrives, the system processes it with that encoding which is estimated to take the least amount of time.</p>\n<p>Third, we subjected our developed systems to careful and extensive experimentation and demonstrated that for several problems using tools developed by the system improves the solving performance of answer set programming tools.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 11/17/2022<br>\n\t\t\t\t\tModified by: Yuliya&nbsp;Lierler</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nUniversities have to schedule lectures to be held at particular times and in particular classrooms. The times have to be acceptable to professors teaching them, and must not conflict with the times of other lectures students are required to take. The rooms must be large enough to accommodate expected enrollments. Problems like this one are known as constraint satisfaction problems. They arise in all areas of life. Often they also involve optimization - solutions we are most interested in should maximize (or minimize) a particular goal function. Typically, constraint satisfactioin and optimization problems are hard in that fast computational systems (often referred to as solvers) guaranteeing good results across wide classes of instances are unlikely to exist.\n\nNevertheless, such problems are important and need to be solved. Therefore, researchers are studying algorithms to solve constraint satisfaction problems. One approach is to focus on a single problem and develop specialized algorithms to solve it (possibly with some relaxation of the required constraints) so that the problem could be solved in an acceptable time for some particular problems. Scheduling problems like the one we started with have been extensively studied and good solutions have been developed.\n\nAnother approach consists of developing languages in which constraint satisfaction problems could be formally described, and methods designed to find solutions to problems expressed in those languages. Among those approaches are linear programming (very efficient algorithms for solving problems that can be formulated as linear programming problems are known) and integer programming (here uniformly fast tools are unlikely to exist). An approach based on logic consists of modeling constraint problems as theories in propositional logic. So modeled problems are then solved by the so called satisfiability solvers, which in the last two decades reached very high levels of performance on a broad class of practical problems.\n\nAnswer set programming is similar to this approach in the solving methodology. That is, solvers to find solutions to answer set programs are closely related to those developed for propositional satisfiability. What distinguishes answer set programming from propositional satisfiability is its programming front end, an intuitive programming language that allows the users to capture constraints given in natural language as programs consisting of rules and constraints.\n\nAnswer set programming proved its modeling efficiency in many domains of practical interest. The constraints of the scheduling problem mentioned earlier can be encoded as an answer set program.\n\nOne of the challenges of this approach is that problems typically can be encoded by many similar but different in details answer set programs, some performing well and some performing poorly. It requires a certain level of expertise to write good answer set programs. But even experts cannot overcome another difficulty. Often the same program performs well on some instances and poorly on others. This means that an encoding to use should be selected on the per instance basis. And this is not something humans can do, given that instances are typically large and difficult to analyze.\n\nThe main objective of this project was to address this problem. More specifically, the project aimed at (1) developing algorithms for generating alternative encodings of a problem, (2) using machine learning to build performance models for an encoding, that would estimate the time it would take if run on a particular instance, (3) implementing these algorithms into tools that would improve the performance of answer set solvers, by automating the task of selecting the right encoding to use with an instance. Additional related goals included developing methods to build data sets for experimentation, and further expanding our understanding of answer set programming as a problem solving tool.\n\nResponding to these objectives, the project resulted in several significant outcomes. First, the team developed several automated ways to rewrite a given encoding into one or more alternative equivalent ones. One approach stemmed from a well known experimental observation that encodings generating smaller programs in the first phase of processing, known as grounding, often perform much better in the second (typically, most time consuming) phase known as solving. Another was based on an observation that modeling certain numeric constraints by specialized aggregating expressions often improves the efficiency of solving.  The correctness of the studied rewriting methods was verified.\n\nSecond, we used machine learning to develop algorithms for building performance models for en encoding, assuming a fixed solver. These models estimate the time the solver will take for e given instance. Once a collection of encodings is available and for each of them its performance model was constructed, when a new instance arrives, the system processes it with that encoding which is estimated to take the least amount of time.\n\nThird, we subjected our developed systems to careful and extensive experimentation and demonstrated that for several problems using tools developed by the system improves the solving performance of answer set programming tools.\n\n\t\t\t\t\tLast Modified: 11/17/2022\n\n\t\t\t\t\tSubmitted by: Yuliya Lierler"
 }
}