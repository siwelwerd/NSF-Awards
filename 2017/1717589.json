{
 "awd_id": "1717589",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "CSR: Small: Software Transactional Memory for Real-Time Systems",
 "cfda_num": "47.070",
 "org_code": "05050000",
 "po_phone": "7032925197",
 "po_email": "mmcclure@nsf.gov",
 "po_sign_block_name": "Marilyn McClure",
 "awd_eff_date": "2017-10-01",
 "awd_exp_date": "2021-09-30",
 "tot_intn_awd_amt": 499999.0,
 "awd_amount": 499999.0,
 "awd_min_amd_letter_date": "2017-08-15",
 "awd_max_amd_letter_date": "2017-08-15",
 "awd_abstract_narration": "When someone driving a car presses the brake pedal, they expect the anti-lock brakes to react in time to avoid a problem.  A car actually contains many computers that run programs that control braking, steering, engine power, etc.  These programs must perform their control operations by specific deadlines, often measured in tiny fractions of a second, to ensure safe operation.  Systems like those in a car belong to a category of hardware and software designs called \"safety-critical real-time systems\" because they must complete their work by real deadline times that matter for safety.  Systems in this category require some form of certification that provides the necessary level of assurance that catastrophic consequences, such as loss of life, are avoided.  Most car buyers would likely never give certification a passing thought, but it is a critical part of the automotive design process.  This project is directed at developing infrastructure that can aid in the creation and certification of safety-critical real-time systems.  This infrastructure will be provided in the form of a concept called real-time software transactional memory (STM).  The purpose of real-time STM is to allow tricky program-certification issues, which arise in complex software systems in which programs share data, to be handled automatically with little programmer effort.\r\n\r\nThe proposed real-time STM framework will ease overall certification efforts and costs in the development of complex safety-critical real-time systems, which are increasingly becoming part of our society and daily lives.  In developing this framework, multicore processors will be a primary emphasis.  The advent of multicore technology has created serious certification issues in the avionics and automotive industries.  The real-time STM to be developed will be specifically disseminated to research collaborators in these industries to evaluate in their systems.  The software and data produced will also be made available for public download by other interested parties.  Instructions for doing so will be provided at http://jamesanderson.web.unc.edu/research/.  The results obtained in this project will be disseminated to the public through lectures at universities and international summer schools, presentations at conferences and workshops, and public demonstration events.   Computer science as a field is suffering from a serious shortage of women at all levels and in particular at the graduate level and above.  Several female graduate students will be directly involved in this project",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CNS",
 "org_div_long_name": "Division Of Computer and Network Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "James",
   "pi_last_name": "Anderson",
   "pi_mid_init": "H",
   "pi_sufx_name": "",
   "pi_full_name": "James H Anderson",
   "pi_email_addr": "anderson@cs.unc.edu",
   "nsf_id": "000481767",
   "pi_start_date": "2017-08-15",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of North Carolina at Chapel Hill",
  "inst_street_address": "104 AIRPORT DR STE 2200",
  "inst_street_address_2": "",
  "inst_city_name": "CHAPEL HILL",
  "inst_state_code": "NC",
  "inst_state_name": "North Carolina",
  "inst_phone_num": "9199663411",
  "inst_zip_code": "275995023",
  "inst_country_name": "United States",
  "cong_dist_code": "04",
  "st_cong_dist_code": "NC04",
  "org_lgl_bus_name": "UNIVERSITY OF NORTH CAROLINA AT CHAPEL HILL",
  "org_prnt_uei_num": "D3LHU66KBLD5",
  "org_uei_num": "D3LHU66KBLD5"
 },
 "perf_inst": {
  "perf_inst_name": "University of North Carolina at Chapel Hill",
  "perf_str_addr": "Department of Computer Science",
  "perf_city_name": "Chapel Hill",
  "perf_st_code": "NC",
  "perf_st_name": "North Carolina",
  "perf_zip_code": "275993175",
  "perf_ctry_code": "US",
  "perf_cong_dist": "04",
  "perf_st_cong_dist": "NC04",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "735400",
   "pgm_ele_name": "CSR-Computer Systems Research"
  },
  {
   "pgm_ele_code": "735900",
   "pgm_ele_name": "CCRI-CISE Cmnty Rsrch Infrstrc"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  }
 ],
 "app_fund": [
  {
   "app_code": "0117",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001718DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2017,
   "fund_oblg_amt": 499999.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p class=\"p1\"><span class=\"s1\">Embedded computing systems are computing systems that control the functioning of some device, instrument, or machine whose purpose is not ordinarily thought of as \"computational.\"<span>&nbsp; </span>A canonical example of<span>&nbsp;</span></span>an embedded system is a car---a typical car today contains many computers that implement various functions but a driver does not think of a car as a computational device.</p>\n<p class=\"p1\"><span class=\"s1\">The range of sophisticated features implemented in embedded systems is accelerating at a rapid pace today.<span>&nbsp; </span>These features are being fueled by the availability of high-performance multicore computers that</span>&nbsp;have multiple processing \"cores\" that can execute many programs at once in parallel.&nbsp; In recent years, the computational power of multicore computers has enabled a wealth of new capabilities across a wide range of application domains, from medical devices and robotic systems with enhanced intelligence, to automobiles, aircraft, and space vehicles that can function autonomously.&nbsp; In many of these domains, the systems of interest are safety-critical real-time systems that have timing constraints requiring certification.&nbsp; For example, when a car's brake pedal is depressed, the anti-lock braking system must react by a certain deadline.&nbsp; In such systems, \"performance\" is tied to formal analysis involving worst-case system behaviors&mdash;e.g., a car's braking system must be engaged by the prescribed deadline even if the computational programs that interact with that system execute for a worst-case amount of time.&nbsp; This focus on the worst case is unlike in conventional throughput-oriented systems, where being as fast as possible most of the time is the usual goal&mdash;in such systems, average-case performance becomes the typical focus and rigorous analysis is not pervasive.&nbsp; Designing a safety-critical real-time system requires facing many analysis-related certification issues, which become more complex due to parallel processing on a multicore platform.</p>\n<p class=\"p1\"><span class=\"s1\">Certification is partially based on mathematical proofs involving the scheduling and synchronization algorithms that determine when programs are allowed to ex</span>ecute and access resources such as shared data.&nbsp; Synchronization algorithms are used for the latter purpose, i.e., providing safe resource access.&nbsp; For example, two different programs that must access a shared data object may need to each \"lock\" that object for exclusive use.&nbsp; Synchronization requirements can complicate the certification of real-time systems.&nbsp; As evidence of this, a rather infamous synchronization-related certification bug some years ago nearly caused a complete system failure in NASA's Pathfinder Mars lander, an outcome that would have cost the US taxpayers almost $300 million.</p>\n<p class=\"p1\"><span class=\"s1\">In work on throughput-oriented computing, the need for simple yet efficient and correct synchronization has been the driving force behind considerable prior work on a concept called <em>software transactional</em></span><em>&nbsp;memory (STM)</em>.&nbsp; When an STM framework is employed, programmers must merely annotate code sections (called \"transactions\") that require synchronization.&nbsp; The STM framework itself determines how synchronization is actually achieved.&nbsp; The goal here is to enable programmers to more easily produce efficient code that is free of synchronization bugs.&nbsp; An especially strong case for STM can be made for safety-critical real-time systems where there is a need for efficient synchronization and real-time certification in code that may be developed by an application programmer who is not a multicore real-time synchronization expert.</p>\n<p class=\"p1\"><span class=\"s1\">Given this background, the specific focus of this project can be stated: this project was directed at producing an STM framework for real-time systems implemented on multicore computers.<span>&nbsp; </span>The majo</span>r thesis of this project was that real-time STM should be retry-free.&nbsp; In most prior work on STM for throughput-oriented systems, conflicting transactions (e.g., transactions attempting to access the same share data) can be aborted and retried.&nbsp; Transaction retries are problematic in real-time systems.&nbsp; This is because it can be difficult to determine reasonable bounds on the worst-case number of retries a transaction may experience.&nbsp; As noted above, when certifying deadline requirements is the ultimate goal, worst-case behaviors must be considered.&nbsp; Retry-free STM uses lock-based synchronization to properly support transactions. &nbsp;</p>\n<p class=\"p1\"><span class=\"s1\">The main intellectual contributions of this project were twofold.<span>&nbsp; </span>First, several new real-time multicore locking algorithms were devised that could be of use in an STM framework.<span>&nbsp; </span>Second, a real-time STM<span>&nbsp;</span></span>framework called <em>TORTIS (Try Once Real-TIme Stm) </em>was produced that is retry-free.&nbsp; TORTIS targets the Rust programming language.&nbsp; Its main components include compiler extensions, a runtime library of real-time locking-algorithm implementations, and a separate component for validating timing constraints.&nbsp; In experiments, TORTIS proved to be much better than retry-based STM in systems with such constraints.</p>\n<p class=\"p1\"><span class=\"s1\">In terms of broader impacts, talks were presented on this work at numerous institutions, conferences, workshops, etc.<span>&nbsp; </span>Additionally, the results of this project formed the basis of the Ph.D.<span>&nbsp;</span>dissertation</span>&nbsp;for one student and the M.S. thesis for another.&nbsp; One undergraduate student was also supported.&nbsp; This student co-authored published papers and produced an undergraduate honors theses related to this project.&nbsp; The four main contributing students in this project were all female.&nbsp; They include two Ph.D. students, one M.S. student, and one undergraduate student.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 12/23/2021<br>\n\t\t\t\t\tModified by: James&nbsp;H&nbsp;Anderson</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "Embedded computing systems are computing systems that control the functioning of some device, instrument, or machine whose purpose is not ordinarily thought of as \"computational.\"  A canonical example of an embedded system is a car---a typical car today contains many computers that implement various functions but a driver does not think of a car as a computational device.\nThe range of sophisticated features implemented in embedded systems is accelerating at a rapid pace today.  These features are being fueled by the availability of high-performance multicore computers that have multiple processing \"cores\" that can execute many programs at once in parallel.  In recent years, the computational power of multicore computers has enabled a wealth of new capabilities across a wide range of application domains, from medical devices and robotic systems with enhanced intelligence, to automobiles, aircraft, and space vehicles that can function autonomously.  In many of these domains, the systems of interest are safety-critical real-time systems that have timing constraints requiring certification.  For example, when a car's brake pedal is depressed, the anti-lock braking system must react by a certain deadline.  In such systems, \"performance\" is tied to formal analysis involving worst-case system behaviors&mdash;e.g., a car's braking system must be engaged by the prescribed deadline even if the computational programs that interact with that system execute for a worst-case amount of time.  This focus on the worst case is unlike in conventional throughput-oriented systems, where being as fast as possible most of the time is the usual goal&mdash;in such systems, average-case performance becomes the typical focus and rigorous analysis is not pervasive.  Designing a safety-critical real-time system requires facing many analysis-related certification issues, which become more complex due to parallel processing on a multicore platform.\nCertification is partially based on mathematical proofs involving the scheduling and synchronization algorithms that determine when programs are allowed to execute and access resources such as shared data.  Synchronization algorithms are used for the latter purpose, i.e., providing safe resource access.  For example, two different programs that must access a shared data object may need to each \"lock\" that object for exclusive use.  Synchronization requirements can complicate the certification of real-time systems.  As evidence of this, a rather infamous synchronization-related certification bug some years ago nearly caused a complete system failure in NASA's Pathfinder Mars lander, an outcome that would have cost the US taxpayers almost $300 million.\nIn work on throughput-oriented computing, the need for simple yet efficient and correct synchronization has been the driving force behind considerable prior work on a concept called software transactional memory (STM).  When an STM framework is employed, programmers must merely annotate code sections (called \"transactions\") that require synchronization.  The STM framework itself determines how synchronization is actually achieved.  The goal here is to enable programmers to more easily produce efficient code that is free of synchronization bugs.  An especially strong case for STM can be made for safety-critical real-time systems where there is a need for efficient synchronization and real-time certification in code that may be developed by an application programmer who is not a multicore real-time synchronization expert.\nGiven this background, the specific focus of this project can be stated: this project was directed at producing an STM framework for real-time systems implemented on multicore computers.  The major thesis of this project was that real-time STM should be retry-free.  In most prior work on STM for throughput-oriented systems, conflicting transactions (e.g., transactions attempting to access the same share data) can be aborted and retried.  Transaction retries are problematic in real-time systems.  This is because it can be difficult to determine reasonable bounds on the worst-case number of retries a transaction may experience.  As noted above, when certifying deadline requirements is the ultimate goal, worst-case behaviors must be considered.  Retry-free STM uses lock-based synchronization to properly support transactions.  \nThe main intellectual contributions of this project were twofold.  First, several new real-time multicore locking algorithms were devised that could be of use in an STM framework.  Second, a real-time STM framework called TORTIS (Try Once Real-TIme Stm) was produced that is retry-free.  TORTIS targets the Rust programming language.  Its main components include compiler extensions, a runtime library of real-time locking-algorithm implementations, and a separate component for validating timing constraints.  In experiments, TORTIS proved to be much better than retry-based STM in systems with such constraints.\nIn terms of broader impacts, talks were presented on this work at numerous institutions, conferences, workshops, etc.  Additionally, the results of this project formed the basis of the Ph.D. dissertation for one student and the M.S. thesis for another.  One undergraduate student was also supported.  This student co-authored published papers and produced an undergraduate honors theses related to this project.  The four main contributing students in this project were all female.  They include two Ph.D. students, one M.S. student, and one undergraduate student.\n\n\t\t\t\t\tLast Modified: 12/23/2021\n\n\t\t\t\t\tSubmitted by: James H Anderson"
 }
}