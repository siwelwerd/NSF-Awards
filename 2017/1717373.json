{
 "awd_id": "1717373",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF:Small:Cooperative Garbage Collection for Big Data and Server Applications",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927885",
 "po_email": "abanerje@nsf.gov",
 "po_sign_block_name": "Anindya Banerjee",
 "awd_eff_date": "2017-09-01",
 "awd_exp_date": "2021-08-31",
 "tot_intn_awd_amt": 447031.0,
 "awd_amount": 447031.0,
 "awd_min_amd_letter_date": "2017-07-07",
 "awd_max_amd_letter_date": "2017-07-07",
 "awd_abstract_narration": "Increasingly, critical parts of our computing infrastructure need to process huge quantities of data, and do so quickly and efficiently. These so-called \"big data\" applications range from familiar Internet search engines to industrial installations, such as factory and farm monitoring. Detailed environmental sensing for agriculture, for example, can generate many gigabytes of data per day for a single farm. The demands of these new applications differ substantially from the conventional programs that have shaped our existing computing systems. As a result, system support does not always serve these applications well, resulting in poor performance or increased resource requirements. The goal of this project is to study big data applications in detail and develop new system-level software to better support them. The project's broader significance and importance are that more data will be able to be processed more quickly and with less computing hardware, reducing costs and improving responsiveness for a wide array of applications.\r\n\r\nThe technical focus of this project is on improving support for big data applications in the Java virtual machine, specifically, in the garbage collector. The intellectual merits are derived from a three-part approach to the problem. The first involves using the project's GC tracing tool to study the memory patterns of big data and server applications in order to quantify and characterize them. The second part involves designing a set of configurable GC mechanisms, which allow applications to tailor memory management support to their specific needs. The third part is an industrial-strength implementation that is used to evaluate real workloads, and that is available to other researchers and to practitioners.\r\n\r\nThe project is releasing the developed tools as open source and is building a user community around the tools by ensuring that interested researchers are able to contribute to the codebase. This aspect is of special interest to the software cluster in NSF's Office of Advanced Cyberinfrastructure, which provides co-funding for this award.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Samuel",
   "pi_last_name": "Guyer",
   "pi_mid_init": "Z",
   "pi_sufx_name": "",
   "pi_full_name": "Samuel Z Guyer",
   "pi_email_addr": "sguyer@cs.tufts.edu",
   "nsf_id": "000091427",
   "pi_start_date": "2017-07-07",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Tufts University",
  "inst_street_address": "80 GEORGE ST",
  "inst_street_address_2": "",
  "inst_city_name": "MEDFORD",
  "inst_state_code": "MA",
  "inst_state_name": "Massachusetts",
  "inst_phone_num": "6176273696",
  "inst_zip_code": "021555519",
  "inst_country_name": "United States",
  "cong_dist_code": "05",
  "st_cong_dist_code": "MA05",
  "org_lgl_bus_name": "TRUSTEES OF TUFTS COLLEGE",
  "org_prnt_uei_num": "WL9FLBRVPJJ7",
  "org_uei_num": "WL9FLBRVPJJ7"
 },
 "perf_inst": {
  "perf_inst_name": "Tufts University",
  "perf_str_addr": "161 College Ave",
  "perf_city_name": "Medford",
  "perf_st_code": "MA",
  "perf_st_name": "Massachusetts",
  "perf_zip_code": "021555807",
  "perf_ctry_code": "US",
  "perf_cong_dist": "07",
  "perf_st_cong_dist": "MA07",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "689200",
   "pgm_ele_name": "CI REUSE"
  },
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7433",
   "pgm_ref_txt": "CyberInfra Frmwrk 21st (CIF21)"
  },
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7943",
   "pgm_ref_txt": "PROGRAMMING LANGUAGES"
  },
  {
   "pgm_ref_code": "8004",
   "pgm_ref_txt": "Software Institutes"
  }
 ],
 "app_fund": [
  {
   "app_code": "0117",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001718DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2017,
   "fund_oblg_amt": 447031.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p class=\"p1\"><span class=\"s1\">This project is concerned with one of the crucial subsystems, called a&nbsp;</span>memory manager, that supports programs running on almost every kind of computing platform, from smart watches to web servers to supercomputers. Working memory is a limited resource in computing systems and must be managed carefully to ensure that each software application has the space it needs to store its data and do its work. The job of the memory manager is to carve up memory into usable chunks for the program in the most efficient way, and to recycle chunks when the program is finished with them. Effective use and reuse of memory is critical, since running out typically causes programs to fail immediately.</p>\n<p class=\"p1\"><span class=\"s1\">Because<span> </span>so many<span> </span>systems<span> </span>rely on<span> </span>memory management, it is critical to&nbsp;</span>implement these subsystems so that they are both correct (that is, they do not make mistakes in the management of the memory space) and they perform well (that is, they do not slow down the programs they are serving). These two goals have proved extremely challenging, particularly for modern server applications, which use huge amounts of memory.</p>\n<p class=\"p2\">In this project we developed two new techniques to improve memory managers. One technique is focused on performance. In this work, we take advantage of particular patterns in the way applications use memory to make the process more efficient. We also invented a new way for programs to interact with the memory manager and trade off speed for space use. The second technique is focused on correctness. In this work, we invented a new way for programmers to specify how a memory manager is supposed to work, and then a separate subsystem that monitors the memory manager to make sure it is doing the right thing. We implemented these ideas in practical systems that can be used in research and in industry. Taken together, these contributions will help improve both the performance and reliability of systems we use every day.</p>\n<p>&nbsp;</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 03/21/2022<br>\n\t\t\t\t\tModified by: Samuel&nbsp;Z&nbsp;Guyer</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "This project is concerned with one of the crucial subsystems, called a memory manager, that supports programs running on almost every kind of computing platform, from smart watches to web servers to supercomputers. Working memory is a limited resource in computing systems and must be managed carefully to ensure that each software application has the space it needs to store its data and do its work. The job of the memory manager is to carve up memory into usable chunks for the program in the most efficient way, and to recycle chunks when the program is finished with them. Effective use and reuse of memory is critical, since running out typically causes programs to fail immediately.\nBecause so many systems rely on memory management, it is critical to implement these subsystems so that they are both correct (that is, they do not make mistakes in the management of the memory space) and they perform well (that is, they do not slow down the programs they are serving). These two goals have proved extremely challenging, particularly for modern server applications, which use huge amounts of memory.\nIn this project we developed two new techniques to improve memory managers. One technique is focused on performance. In this work, we take advantage of particular patterns in the way applications use memory to make the process more efficient. We also invented a new way for programs to interact with the memory manager and trade off speed for space use. The second technique is focused on correctness. In this work, we invented a new way for programmers to specify how a memory manager is supposed to work, and then a separate subsystem that monitors the memory manager to make sure it is doing the right thing. We implemented these ideas in practical systems that can be used in research and in industry. Taken together, these contributions will help improve both the performance and reliability of systems we use every day.\n\n \n\n\t\t\t\t\tLast Modified: 03/21/2022\n\n\t\t\t\t\tSubmitted by: Samuel Z Guyer"
 }
}