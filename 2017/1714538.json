{
 "awd_id": "1714538",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF:Small: Enabling Scalable and Expressive Program Analysis Notifications",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927841",
 "po_email": "sgreensp@nsf.gov",
 "po_sign_block_name": "Sol Greenspan",
 "awd_eff_date": "2017-08-15",
 "awd_exp_date": "2021-07-31",
 "tot_intn_awd_amt": 265853.0,
 "awd_amount": 265853.0,
 "awd_min_amd_letter_date": "2017-08-10",
 "awd_max_amd_letter_date": "2018-11-01",
 "awd_abstract_narration": "Program analysis tools are necessary for high quality software. The goal of this research is to understand how expressiveness and scalability can be increased within and across these tools, which is important to advancing knowledge by transforming how software development environments converse with the developers who use them. There will be three outcomes: a framework designed to enable toolsmiths to create program analysis tools that are expressive and scalable, three re-engineered program analysis tools that use the framework, and validation that program analysis tools built using our framework provide positive results. It will have significant benefits to society by enabling developers to fully reap the benefits of program analysis tools more correct, more reliable, and more on-time software systems.\r\n\r\nProgram analysis tools such as static analysis tools, restructuring tools, and code coverage tools communicate with the software developer through notifications, but these notifications must balance two competing priorities. First, they must be expressive enough that software developers can understand what the notification is trying to convey. Second, they must be scalable enough that as understanding a notification becomes increasingly cognitively demanding, the developer does not abandon the tool in favor of an error-prone process of manual diagnosis. The project designs a new interactive development environment (IDE) framework for notifications.  Many program analysis notifications have a common structure, which can be leveraged to enable expressiveness and scalability for IDE notifications.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Former Principal Investigator",
   "pi_first_name": "Emerson",
   "pi_last_name": "Murphy-Hill",
   "pi_mid_init": "R",
   "pi_sufx_name": "",
   "pi_full_name": "Emerson R Murphy-Hill",
   "pi_email_addr": "emerson@csc.ncsu.edu",
   "nsf_id": "000578912",
   "pi_start_date": "2017-08-10",
   "pi_end_date": "2018-11-01"
  },
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Sarah",
   "pi_last_name": "Heckman",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Sarah Heckman",
   "pi_email_addr": "Sarah_Heckman@ncsu.edu",
   "nsf_id": "000605432",
   "pi_start_date": "2018-11-01",
   "pi_end_date": null
  },
  {
   "pi_role": "Former Co-Principal Investigator",
   "pi_first_name": "Sarah",
   "pi_last_name": "Heckman",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Sarah Heckman",
   "pi_email_addr": "Sarah_Heckman@ncsu.edu",
   "nsf_id": "000605432",
   "pi_start_date": "2017-08-10",
   "pi_end_date": "2018-11-01"
  }
 ],
 "inst": {
  "inst_name": "North Carolina State University",
  "inst_street_address": "2601 WOLF VILLAGE WAY",
  "inst_street_address_2": "",
  "inst_city_name": "RALEIGH",
  "inst_state_code": "NC",
  "inst_state_name": "North Carolina",
  "inst_phone_num": "9195152444",
  "inst_zip_code": "276950001",
  "inst_country_name": "United States",
  "cong_dist_code": "02",
  "st_cong_dist_code": "NC02",
  "org_lgl_bus_name": "NORTH CAROLINA STATE UNIVERSITY",
  "org_prnt_uei_num": "U3NVH931QJJ3",
  "org_uei_num": "U3NVH931QJJ3"
 },
 "perf_inst": {
  "perf_inst_name": "North Carolina State University",
  "perf_str_addr": "Campus Box 8206",
  "perf_city_name": "Raleigh",
  "perf_st_code": "NC",
  "perf_st_name": "North Carolina",
  "perf_zip_code": "276958206",
  "perf_ctry_code": "US",
  "perf_cong_dist": "02",
  "perf_st_cong_dist": "NC02",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7944",
   "pgm_ref_txt": "SOFTWARE ENG & FORMAL METHODS"
  }
 ],
 "app_fund": [
  {
   "app_code": "0117",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001718DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2017,
   "fund_oblg_amt": 265853.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p><span id=\"docs-internal-guid-6d6d1003-7fff-0a19-ea63-3de8efd1f004\"> </span></p>\n<p dir=\"ltr\"><span>The goal of this project is to address challenges with expressiveness and scalability of notifications from program analysis tools.&nbsp; Notifications are expressive if they provide actionable information to the developer and scalable if the notification leads to a change in code or developer process.&nbsp; This project investigated the expressiveness and scalability of program analysis notifications from a variety of software development tools in open source projects and introductory software development courses.</span></p>\n<p dir=\"ltr\"><span>The main contribution of this project is the creation of the </span><span>developer recommendation choice architecture</span><span>, which is a framework to improve automated notifications from recommender bots.&nbsp; These notifications should themselves be expressive and scalable.&nbsp; The developer recommendation choice architecture suggests that notifications from recommendation bots incorporate actionability, feedback, and locality to support developer action on the notification.&nbsp; This in turn supports increased expressiveness and scalability of program analysis notifications.&nbsp;</span></p>\n<p dir=\"ltr\"><strong>Bots, Nudges, and Recommendations</strong></p>\n<p dir=\"ltr\"><span>One of the challenges with program analysis notifications is awareness of tools that support the development of high-quality software.&nbsp; Many developers may be unaware of static analysis tools, which can help identify bug patterns.&nbsp; We developed the tool-recommender-bot to recommend the static analysis tool Error Prone on open source projects on GitHub.&nbsp; The tool-recommender-bot utilizes nudge theory to increase awareness of static analysis tools by adding pull requests with recommendations on fixing Error Prone notifications.&nbsp; Utilizing a ?naive telemarketer? design, random Java-based projects were selected and analyzed for Error Prone notifications.&nbsp; If a notification was found, a pull request was automatically created with the fix and information about integrating Error Prone into the existing build process.&nbsp; Our results show that developers do not like automated pull request recommendations due to a lack of social context and interruptions to the developer workflow.&nbsp; A later study showed that using GitHub?s suggested changes did provide a mechanism to support recommendation notifications by incorporating the elements of actionability, feedback, and locality as described in the </span><span>developer recommendation choice architecture</span><span>.&nbsp;</span></p>\n<p dir=\"ltr\"><strong>Expressiveness and Scalability with Static Analysis for Security</strong></p>\n<p dir=\"ltr\"><span>A heuristic walkthrough of four popular static analysis tools for security investigated the quality of notifications for providing the information developers need to resolve security defects.&nbsp; We identified 194 issues that detract from the usability of these static analysis tools.&nbsp; For example, we found issues with how the tools expressed information about prioritizing defects and scalability issues with the tools? interfaces.&nbsp;</span></p>\n<p dir=\"ltr\"><strong>Notifications in Education</strong></p>\n<p dir=\"ltr\"><span>Novice developers can be overwhelmed by the program analysis notifications they receive while completing software development projects.&nbsp; Additionally, novices may struggle with understanding their current status for completing their work from these notifications.&nbsp; We utilized the developer recommendation choice architecture to create notifications for students in a CS1 course characterizing their progress in completing a programming assignment.&nbsp; These notifications served as daily nudges for students to complete their work and use software development skills.&nbsp; Students received higher scores on programming assignments with process notifications.&nbsp; Additionally, student productivity, as measured by start time and code modification in commits, increased.</span></p>\n<p dir=\"ltr\"><span>We investigated the questions about program analysis notifications that students asked on a course message board in a CS2 class.&nbsp; We found that over 35% of questions on the course message board were related to the notifications generated by program analysis tools run during automated grading.&nbsp; The number of notification questions that students asked on the course message board was positively correlated with course grades, suggesting that help-seeking around notifications supports student success in programming courses.&nbsp; To better understand if help-seeking is successful, we mined the development history of student projects for program analysis notifications.&nbsp; Future work will utilize this historical data set to determine if a help-seeking interaction led to a positive change in the student?s project through the resolution of notifications they had questions about. By identifying successful help-seeking interactions, we can analyze help-seeking interactions to support training for teaching assistants and the creation of better notifications to support novice developers.</span></p>\n<p dir=\"ltr\"><span>Finally, we started an investigation of progress indicators in our CS2 course.&nbsp; Progress indicators are a measure of the change in program analysis notifications across a build history on a project.&nbsp; For example, the change in test failures or statement coverage. We investigated the types of progress indicators that registered a positive change in student work during different phases of software development projects in a CS2 course.&nbsp; We found that students are making the expected progress during each phase of the software development project, but that the current set of progress indicators may be incomplete for our course context.&nbsp; Additionally, we observed that student process improved on later projects as students increased their understanding of project expectations, showing scalability of the program analysis notifications.</span></p>\n<p>&nbsp;</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 09/10/2021<br>\n\t\t\t\t\tModified by: Sarah&nbsp;Heckman</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\n \nThe goal of this project is to address challenges with expressiveness and scalability of notifications from program analysis tools.  Notifications are expressive if they provide actionable information to the developer and scalable if the notification leads to a change in code or developer process.  This project investigated the expressiveness and scalability of program analysis notifications from a variety of software development tools in open source projects and introductory software development courses.\nThe main contribution of this project is the creation of the developer recommendation choice architecture, which is a framework to improve automated notifications from recommender bots.  These notifications should themselves be expressive and scalable.  The developer recommendation choice architecture suggests that notifications from recommendation bots incorporate actionability, feedback, and locality to support developer action on the notification.  This in turn supports increased expressiveness and scalability of program analysis notifications. \nBots, Nudges, and Recommendations\nOne of the challenges with program analysis notifications is awareness of tools that support the development of high-quality software.  Many developers may be unaware of static analysis tools, which can help identify bug patterns.  We developed the tool-recommender-bot to recommend the static analysis tool Error Prone on open source projects on GitHub.  The tool-recommender-bot utilizes nudge theory to increase awareness of static analysis tools by adding pull requests with recommendations on fixing Error Prone notifications.  Utilizing a ?naive telemarketer? design, random Java-based projects were selected and analyzed for Error Prone notifications.  If a notification was found, a pull request was automatically created with the fix and information about integrating Error Prone into the existing build process.  Our results show that developers do not like automated pull request recommendations due to a lack of social context and interruptions to the developer workflow.  A later study showed that using GitHub?s suggested changes did provide a mechanism to support recommendation notifications by incorporating the elements of actionability, feedback, and locality as described in the developer recommendation choice architecture. \nExpressiveness and Scalability with Static Analysis for Security\nA heuristic walkthrough of four popular static analysis tools for security investigated the quality of notifications for providing the information developers need to resolve security defects.  We identified 194 issues that detract from the usability of these static analysis tools.  For example, we found issues with how the tools expressed information about prioritizing defects and scalability issues with the tools? interfaces. \nNotifications in Education\nNovice developers can be overwhelmed by the program analysis notifications they receive while completing software development projects.  Additionally, novices may struggle with understanding their current status for completing their work from these notifications.  We utilized the developer recommendation choice architecture to create notifications for students in a CS1 course characterizing their progress in completing a programming assignment.  These notifications served as daily nudges for students to complete their work and use software development skills.  Students received higher scores on programming assignments with process notifications.  Additionally, student productivity, as measured by start time and code modification in commits, increased.\nWe investigated the questions about program analysis notifications that students asked on a course message board in a CS2 class.  We found that over 35% of questions on the course message board were related to the notifications generated by program analysis tools run during automated grading.  The number of notification questions that students asked on the course message board was positively correlated with course grades, suggesting that help-seeking around notifications supports student success in programming courses.  To better understand if help-seeking is successful, we mined the development history of student projects for program analysis notifications.  Future work will utilize this historical data set to determine if a help-seeking interaction led to a positive change in the student?s project through the resolution of notifications they had questions about. By identifying successful help-seeking interactions, we can analyze help-seeking interactions to support training for teaching assistants and the creation of better notifications to support novice developers.\nFinally, we started an investigation of progress indicators in our CS2 course.  Progress indicators are a measure of the change in program analysis notifications across a build history on a project.  For example, the change in test failures or statement coverage. We investigated the types of progress indicators that registered a positive change in student work during different phases of software development projects in a CS2 course.  We found that students are making the expected progress during each phase of the software development project, but that the current set of progress indicators may be incomplete for our course context.  Additionally, we observed that student process improved on later projects as students increased their understanding of project expectations, showing scalability of the program analysis notifications.\n\n \n\n\t\t\t\t\tLast Modified: 09/10/2021\n\n\t\t\t\t\tSubmitted by: Sarah Heckman"
 }
}