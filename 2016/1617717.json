{
 "awd_id": "1617717",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Small: Semantics, Static Analysis, and Refencing of Concurrent Programs with Weak Memory Models",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927991",
 "po_email": "namla@nsf.gov",
 "po_sign_block_name": "Nina Amla",
 "awd_eff_date": "2016-09-01",
 "awd_exp_date": "2020-08-31",
 "tot_intn_awd_amt": 481399.0,
 "awd_amount": 481399.0,
 "awd_min_amd_letter_date": "2016-05-19",
 "awd_max_amd_letter_date": "2016-05-19",
 "awd_abstract_narration": "Modern computers have parallel multicore architectures sharing a\r\nhierarchy of caches and memories from fast and expensive ones to large\r\nand cheaper ones. The consequence is that not all cores running\r\nconcurrently see the shared memory in the same way: some see newly\r\nstored values while others see older ones. This is called weak\r\nconsistency models for shared memory on a single chip or memory\r\ndistributed on several chips or on networks. This modern design makes \r\nthe task of designing and programming parallel computers very complex. \r\nIn particular the same program may have very different behaviors when running \r\non different architectures whereas the same program had the same effect on all\r\nmachines of the previous generation. \r\n\r\nThis project define a generic formal semantics of parallel programs with weak \r\nconsistency models parameterized by a formal definition of the computer \r\narchitecture. Based on this parameterized semantics, the project investigates \r\ninvariance proof methods to be used by programmers and verification tools to \r\nprove properties of parallel programs with weak consistency models. The project \r\ncontributes to formal methods and tools for concurrent programming which, by \r\nthe foreseeable evolution of hardware design, will be inevitable in the future.\r\nThe publications and prototypes from this project are widely disseminated.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Patrick",
   "pi_last_name": "Cousot",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Patrick Cousot",
   "pi_email_addr": "pcousot@cs.nyu.edu",
   "nsf_id": "000504419",
   "pi_start_date": "2016-05-19",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "New York University",
  "inst_street_address": "70 WASHINGTON SQ S",
  "inst_street_address_2": "",
  "inst_city_name": "NEW YORK",
  "inst_state_code": "NY",
  "inst_state_name": "New York",
  "inst_phone_num": "2129982121",
  "inst_zip_code": "100121019",
  "inst_country_name": "United States",
  "cong_dist_code": "10",
  "st_cong_dist_code": "NY10",
  "org_lgl_bus_name": "NEW YORK UNIVERSITY",
  "org_prnt_uei_num": "",
  "org_uei_num": "NX9PXMKW5KW8"
 },
 "perf_inst": {
  "perf_inst_name": "New York University",
  "perf_str_addr": "251 Mercer Street",
  "perf_city_name": "New York",
  "perf_st_code": "NY",
  "perf_st_name": "New York",
  "perf_zip_code": "100121110",
  "perf_ctry_code": "US",
  "perf_cong_dist": "10",
  "perf_st_cong_dist": "NY10",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "8206",
   "pgm_ref_txt": "Formal Methods and Verification"
  }
 ],
 "app_fund": [
  {
   "app_code": "0116",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001617DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2016,
   "fund_oblg_amt": 481399.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p><span>Modern computers have parallel multicore architectures sharing a&nbsp;</span>hierarchy of caches and memories from fast and expensive ones to large and cheaper ones. The consequence is that not all cores running concurrently see the shared memory in the same way: some see newly stored values while others see older ones. This is called weak consistency models (for shared memory on a single chip or memory distributed on several chips or on networks).</p>\n<div><span>\n<p><span>The consequence of this modern design is a huge complexification of the&nbsp;</span>semantics of parallel programs, their compilation, verification, and static analysis.</p>\n<p><span>Using abstract interpretation, we have established foundations of dependency analysis, graphs analysis, the soundness of model checking and dataflow analysis, the formalization of dynamic analysis, and the application of static analysis to improve static analysis algorithms.</span></p>\n<div><span>The more widely applicable result is on dependency analysis. &nbsp;</span>Dependency is a prevalent notion in computer science. There have been numerous informal or formal attempts to define viable syntactic and semantic concepts of dependency in programming languages with subtle variations and limitations. We have developed a new value dependency analysis defined by abstract interpretation of a trace semantics. A sound approximate dependency algorithm is formally derived by calculational design. Further abstractions provide information flow, slicing, non- interference, dye, and taint analyses. The key idea is that a precise dependency must take values of data into account not only the operations on data. This is achieved via a reduced product of a dependency and a value analysis which interact to reach more precision&nbsp;<span>\n<div><span><br /></span></div>\n</span></div>\n<p>&nbsp;</p>\n<div><span><br /></span></div>\n<br /></span></div><br>\n<p>\n\t\t\t\t      \tLast Modified: 10/04/2020<br>\n\t\t\t\t\tModified by: Patrick&nbsp;Cousot</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nModern computers have parallel multicore architectures sharing a hierarchy of caches and memories from fast and expensive ones to large and cheaper ones. The consequence is that not all cores running concurrently see the shared memory in the same way: some see newly stored values while others see older ones. This is called weak consistency models (for shared memory on a single chip or memory distributed on several chips or on networks).\n\n\nThe consequence of this modern design is a huge complexification of the semantics of parallel programs, their compilation, verification, and static analysis.\n\nUsing abstract interpretation, we have established foundations of dependency analysis, graphs analysis, the soundness of model checking and dataflow analysis, the formalization of dynamic analysis, and the application of static analysis to improve static analysis algorithms.\nThe more widely applicable result is on dependency analysis.  Dependency is a prevalent notion in computer science. There have been numerous informal or formal attempts to define viable syntactic and semantic concepts of dependency in programming languages with subtle variations and limitations. We have developed a new value dependency analysis defined by abstract interpretation of a trace semantics. A sound approximate dependency algorithm is formally derived by calculational design. Further abstractions provide information flow, slicing, non- interference, dye, and taint analyses. The key idea is that a precise dependency must take values of data into account not only the operations on data. This is achieved via a reduced product of a dependency and a value analysis which interact to reach more precision \n\n\n\n\n \n\n\n\n\n\n\t\t\t\t\tLast Modified: 10/04/2020\n\n\t\t\t\t\tSubmitted by: Patrick Cousot"
 }
}