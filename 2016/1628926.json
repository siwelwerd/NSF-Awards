{
 "awd_id": "1628926",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "XPS: FULL: Hardware Software Abstractions: Addressing Specification and Verification Gaps in Accelerator-Oriented Parallelism",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927885",
 "po_email": "abanerje@nsf.gov",
 "po_sign_block_name": "Anindya Banerjee",
 "awd_eff_date": "2016-09-01",
 "awd_exp_date": "2022-08-31",
 "tot_intn_awd_amt": 875000.0,
 "awd_amount": 875000.0,
 "awd_min_amd_letter_date": "2016-06-28",
 "awd_max_amd_letter_date": "2019-10-24",
 "awd_abstract_narration": "Given slowdowns in semiconductor technology scaling, it has become increasingly challenging to maintain processor performance scaling at acceptable power constraints. In response, microprocessors increasingly use complex architectures with heterogeneous parallelism and specialized compute units known as accelerators.  Accelerators provide high compute performance at reduced power/energy by avoiding the overhead of instruction-programmability. The key challenge, however, is that unlike traditional microprocessor CPUs, accelerators have no durable, portable instruction set architecture (ISA), and instead are programmed via drivers or library APIs. These increase the effort of porting accelerator-oriented programs to other platforms with similar functionality but different implementations. The increased effort has serious consequences for software cost. Furthermore, the fact that accelerators have no formal, durable ISA causes increased verification complexity at a time when it is already the limiting factor in the design of future computing platforms. The intellectual merits of this work are that the research is developing Instruction-Level Abstractions (ILAs) that extend the ISA concept to accelerators in order to address these programming and verification challenges. ILAs offer a formal and high-level summary of the visible state updates that an accelerator will perform on each invocation.  The project?s broader significance and importance are the work?s ability to impact industry designs of future accelerator-based computing platforms and thereby help sustain the US computing industry.\r\n\r\nThere are two components to an ILA: specifying the state updates, and specifying the Memory Consistency Model, i.e., the permitted ordering of state updates relative to other parallel compute elements. The research develops ILA methodologies that are (i) uniform across accelerators, (ii) symmetric with the ISA of instruction-programmable processors and (iii) unified across both computation (state change) and memory (data/storage state update) abstractions. To show the value of ILAs, the research develops: (i) ILA specification mechanisms for a rich set of accelerators, (ii) synthesis techniques and tools for generating these ILAs automatically, (iii) verification techniques and tools that check these abstractions against implementations and (iv) further tools enabled by ILAs including full-system architectural simulation. Through these efforts, this work addresses fundamental software portability and verification gaps in the design and deployment of accelerator-oriented systems.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Sharad",
   "pi_last_name": "Malik",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Sharad Malik",
   "pi_email_addr": "sharad@princeton.edu",
   "nsf_id": "000462582",
   "pi_start_date": "2016-06-28",
   "pi_end_date": null
  },
  {
   "pi_role": "Former Co-Principal Investigator",
   "pi_first_name": "Margaret",
   "pi_last_name": "Martonosi",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Margaret Martonosi",
   "pi_email_addr": "martonosi@princeton.edu",
   "nsf_id": "000395997",
   "pi_start_date": "2016-06-28",
   "pi_end_date": "2019-10-24"
  }
 ],
 "inst": {
  "inst_name": "Princeton University",
  "inst_street_address": "1 NASSAU HALL",
  "inst_street_address_2": "",
  "inst_city_name": "PRINCETON",
  "inst_state_code": "NJ",
  "inst_state_name": "New Jersey",
  "inst_phone_num": "6092583090",
  "inst_zip_code": "085442001",
  "inst_country_name": "United States",
  "cong_dist_code": "12",
  "st_cong_dist_code": "NJ12",
  "org_lgl_bus_name": "THE TRUSTEES OF PRINCETON UNIVERSITY",
  "org_prnt_uei_num": "",
  "org_uei_num": "NJ1YPQXQG7U5"
 },
 "perf_inst": {
  "perf_inst_name": "Princeton University",
  "perf_str_addr": "87 Prospect Avenue, 2nd floor",
  "perf_city_name": "Princeton",
  "perf_st_code": "NJ",
  "perf_st_name": "New Jersey",
  "perf_zip_code": "085442020",
  "perf_ctry_code": "US",
  "perf_cong_dist": "12",
  "perf_st_cong_dist": "NJ12",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "828300",
   "pgm_ele_name": "Exploiting Parallel&Scalabilty"
  }
 ],
 "pgm_ref": null,
 "app_fund": [
  {
   "app_code": "0116",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001617DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2016,
   "fund_oblg_amt": 875000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>The work performed through the support of this grant resulted in development of tools and methodologies towards scalable verification of heterogeneous architectures that is the corner stone of today&rsquo;s hardware designs.</p>\n<p>In particular, the work resulted in the following outcomes:</p>\n<ul>\n<li><em>Universal (non-litmus-test based) proofs of correctness for axiomatic specifications of microprocessors:</em> This is a key step towards comprehensive hardware verification early enough in the design process to allow for interactive design refinements towards efficiency and correctness.</li>\n<li><em>An integrated reasoning framework that combines processor/accelerator functionality with MCMs:</em> This is critical for reasoning about system-wide properties that depend on functional state updates in accelerators and processors as well as ordering relations between them.</li>\n<li>In follow-up to the RISC-V ISA flaws identified by our TriCheck tool (described above), <em>a RISC-V memory model working group has formed to rework the memory consistency model specification</em>. Our research group participated in this working group in order to guide and influence the final memory model design. In addition, bugs we have found in other systems are also being addressed and corrected. </li>\n<li><em>Leakage containment models for microarchitectural leakage based security vulnerabilities:</em> This provides a rigorous way for evaluating and possibility mitigating such leakage.</li>\n<li><em>A modular formal specification of shared memory ordering rules and its verification</em>: This opens opportunities for scaling this verification.</li>\n<li><em>An integrated reasoning framework that combines processor/accelerator functionality with MCMs:</em> This is critical for reasoning about system-wide properties that depend on functional state updates in accelerators and processors as well as ordering relations between them.</li>\n<li><em>A methodology and tool for modular specification and modular automated formal verification of MCM properties for hardware designs:</em> The MCM specification of each component can be written independent of the others and then composed together to create the overall design specification. Verification of the rest of the processor can then use the interface specification rather than the component's detailed design specification. Formal specification of memory transistency models (MTMs) which define the superset of MCMs that additionally capture virtual memory-aware orderings: This developed a new formal MTM vocabulary that captures system- and hardware-level virtual memory operations and their interactions with user-facing program instructions. This vocabulary can be used to formally specify an ISA-level MTM and synthesis of enhanced litmus tests (ELTs).</li>\n<li><em>Formalization of the ILA model and its use as a specification for verifying accelerator implementations</em>: This formalism generalized the ISA to include both processors and accelerators. This generalization in turn enables the use of refinement checking techniques, originally developed for processor verification, for accelerator verification, which had been a major goal of this project. As part of this, the concept of a refinement map was extended from ISA based refinement checking to ILA based refinement checking.</li>\n<li><em>Development of open-source ILA tools</em>, A strong set of tools for ILA based modeling and verification (termed ILAng) have been open-sourced following an external conference artifact evaluation providing an external validation about its usability.</li>\n<li><em>Extending the ILA to general hardware modules</em>: While the ILA model had been developed for accelerators as an extension of the ISA, this could be further extended to general hardware modules by treating the commands at their interface as instructions. This led to the use of the ILA for specifying and verifying general hardware modules.</li>\n<li><em>Automating Extraction of ILA Models from Existing RTL Designs</em>: Techniques were developed for the&nbsp;ILA to be automatically extracted from legacy RTL as a sound abstraction for processors and accelerators to be used for reducing the state space of the design under verification. This included automatically determining the set of architectural state variables (the variables persistent across instructions) and to extract the per-instruction update function for these architecture state variables.</li>\n<li><em>Use of ILA in Compilation Flows</em>:&nbsp; The ILA hardware-software interface specification for compilation flows was used to map applications to accelerators (over and beyond its use in specification and verification of accelerators). The ILA specification has been used in operator selection, code generation and hardware-software co-simulation in this collaboration with compiler experts at the University of Washington, and accelerator design experts at Harvard.</li>\n</ul>\n<p>&nbsp;</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 12/28/2022<br>\n\t\t\t\t\tModified by: Sharad&nbsp;Malik</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nThe work performed through the support of this grant resulted in development of tools and methodologies towards scalable verification of heterogeneous architectures that is the corner stone of today\u2019s hardware designs.\n\nIn particular, the work resulted in the following outcomes:\n\nUniversal (non-litmus-test based) proofs of correctness for axiomatic specifications of microprocessors: This is a key step towards comprehensive hardware verification early enough in the design process to allow for interactive design refinements towards efficiency and correctness.\nAn integrated reasoning framework that combines processor/accelerator functionality with MCMs: This is critical for reasoning about system-wide properties that depend on functional state updates in accelerators and processors as well as ordering relations between them.\nIn follow-up to the RISC-V ISA flaws identified by our TriCheck tool (described above), a RISC-V memory model working group has formed to rework the memory consistency model specification. Our research group participated in this working group in order to guide and influence the final memory model design. In addition, bugs we have found in other systems are also being addressed and corrected. \nLeakage containment models for microarchitectural leakage based security vulnerabilities: This provides a rigorous way for evaluating and possibility mitigating such leakage.\nA modular formal specification of shared memory ordering rules and its verification: This opens opportunities for scaling this verification.\nAn integrated reasoning framework that combines processor/accelerator functionality with MCMs: This is critical for reasoning about system-wide properties that depend on functional state updates in accelerators and processors as well as ordering relations between them.\nA methodology and tool for modular specification and modular automated formal verification of MCM properties for hardware designs: The MCM specification of each component can be written independent of the others and then composed together to create the overall design specification. Verification of the rest of the processor can then use the interface specification rather than the component's detailed design specification. Formal specification of memory transistency models (MTMs) which define the superset of MCMs that additionally capture virtual memory-aware orderings: This developed a new formal MTM vocabulary that captures system- and hardware-level virtual memory operations and their interactions with user-facing program instructions. This vocabulary can be used to formally specify an ISA-level MTM and synthesis of enhanced litmus tests (ELTs).\nFormalization of the ILA model and its use as a specification for verifying accelerator implementations: This formalism generalized the ISA to include both processors and accelerators. This generalization in turn enables the use of refinement checking techniques, originally developed for processor verification, for accelerator verification, which had been a major goal of this project. As part of this, the concept of a refinement map was extended from ISA based refinement checking to ILA based refinement checking.\nDevelopment of open-source ILA tools, A strong set of tools for ILA based modeling and verification (termed ILAng) have been open-sourced following an external conference artifact evaluation providing an external validation about its usability.\nExtending the ILA to general hardware modules: While the ILA model had been developed for accelerators as an extension of the ISA, this could be further extended to general hardware modules by treating the commands at their interface as instructions. This led to the use of the ILA for specifying and verifying general hardware modules.\nAutomating Extraction of ILA Models from Existing RTL Designs: Techniques were developed for the ILA to be automatically extracted from legacy RTL as a sound abstraction for processors and accelerators to be used for reducing the state space of the design under verification. This included automatically determining the set of architectural state variables (the variables persistent across instructions) and to extract the per-instruction update function for these architecture state variables.\nUse of ILA in Compilation Flows:  The ILA hardware-software interface specification for compilation flows was used to map applications to accelerators (over and beyond its use in specification and verification of accelerators). The ILA specification has been used in operator selection, code generation and hardware-software co-simulation in this collaboration with compiler experts at the University of Washington, and accelerator design experts at Harvard.\n\n\n \n\n\t\t\t\t\tLast Modified: 12/28/2022\n\n\t\t\t\t\tSubmitted by: Sharad Malik"
 }
}