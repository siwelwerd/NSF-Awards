{
 "awd_id": "1617676",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "NSFSaTC-BSF: TWC: Small: Practical Succinct Proof Systems without Trusted Setup",
 "cfda_num": "47.070",
 "org_code": "05050000",
 "po_phone": "7032927991",
 "po_email": "namla@nsf.gov",
 "po_sign_block_name": "Nina Amla",
 "awd_eff_date": "2016-08-01",
 "awd_exp_date": "2021-07-31",
 "tot_intn_awd_amt": 499578.0,
 "awd_amount": 499578.0,
 "awd_min_amd_letter_date": "2016-07-25",
 "awd_max_amd_letter_date": "2018-12-17",
 "awd_abstract_narration": "Succinct non-interactive proofs are a powerful cryptographic building block with many promising applications in secure cloud outsourcing and in domains such as Internet of Things, medical, and financial applications where computation over privacy sensitive data is desired. Existing implementations of succinct proofs all rely on a trusted setup phase, commonly known as preprocessing. This preprocessing phase can be problematic since the system loses all security guarantees if the secret trapdoor generated during preprocessing is compromised. To make matters worse, the preprocessing is often not a one-time operation, and must be repeated for each application or, even worse, for different input sizes of the very same application.\r\n\r\nThe project investigates ways to circumvent this major drawback by exploring succinct proof systems without trusted setup. This project creates a programming framework and compiler toolchain called Lunaria which compiles general programs, written in high-level languages, into succinct zero-knowledge proofs without trusted setup. Lunaria aims to combine algebraic-, compiler-, and implementation-level improvements in non-trivial ways, and enable orders of magnitude speedup over a straightforward implementation of state-of-the-art theoretical results. Expected impacts include new, open-source frameworks for succinct proofs without trusted setup, thus giving research and industry access to the power of succinct proofs.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CNS",
 "org_div_long_name": "Division Of Computer and Network Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Elaine",
   "pi_last_name": "Shi",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Elaine Shi",
   "pi_email_addr": "runting@cs.cmu.edu",
   "nsf_id": "000624210",
   "pi_start_date": "2016-07-25",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Rafael",
   "pi_last_name": "Pass",
   "pi_mid_init": "N",
   "pi_sufx_name": "",
   "pi_full_name": "Rafael N Pass",
   "pi_email_addr": "rafael@cs.cornell.edu",
   "nsf_id": "000101933",
   "pi_start_date": "2018-12-17",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Cornell University",
  "inst_street_address": "341 PINE TREE RD",
  "inst_street_address_2": "",
  "inst_city_name": "ITHACA",
  "inst_state_code": "NY",
  "inst_state_name": "New York",
  "inst_phone_num": "6072555014",
  "inst_zip_code": "148502820",
  "inst_country_name": "United States",
  "cong_dist_code": "19",
  "st_cong_dist_code": "NY19",
  "org_lgl_bus_name": "CORNELL UNIVERSITY",
  "org_prnt_uei_num": "",
  "org_uei_num": "G56PUALJ3KT5"
 },
 "perf_inst": {
  "perf_inst_name": "Cornell University",
  "perf_str_addr": "107 Hoy Road",
  "perf_city_name": "Ithaca",
  "perf_st_code": "NY",
  "perf_st_name": "New York",
  "perf_zip_code": "148537501",
  "perf_ctry_code": "US",
  "perf_cong_dist": "19",
  "perf_st_cong_dist": "NY19",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "806000",
   "pgm_ele_name": "Secure &Trustworthy Cyberspace"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "014Z",
   "pgm_ref_txt": "NSF and US-Israel Binational Science Fou"
  },
  {
   "pgm_ref_code": "022Z",
   "pgm_ref_txt": "International Partnerships"
  },
  {
   "pgm_ref_code": "7434",
   "pgm_ref_txt": "CNCI"
  },
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "9102",
   "pgm_ref_txt": "WOMEN, MINORITY, DISABLED, NEC"
  }
 ],
 "app_fund": [
  {
   "app_code": "0116",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001617DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2016,
   "fund_oblg_amt": 499578.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>We designed and implemented a system called xjSNARK, which can compile programs written in a high-level imperative language to efficient circuit representations suitable for zero-knowlege proofs (ZKP). Our compiler can often generate circuits that are more succinct than hand-optimized ones. We evaluated our compiler using various applications that might be of interest in blockchain applications, e.g., privacy-preserving smart contracts. We have open sourced our implementation.&nbsp; Our postdoc collaborated with a group of researchers at Technion, and helped with the design, implementation, and improvement of zk-STARKs without trusted setup.&nbsp;</p>\n<p>&nbsp;</p>\n<p>Modern distributed systems involve interactions between principals with limited trust. In this setting, cryptographic protocols are used to protect confidentiality and integrity; unfortunately, most developers do not have the training to design, implement, or securely combine cryptographic protocols. We worked on a programming language and compiler that can automatically compile a user-supplied high-level specification with security annotations into a cryptographic protocol satisfying the security requirements. Our compiler can analyze the security annotations provided by the programmer, and search for the most efficient cryptographic implementation that can satisfy these security goals. We have implemented our design and the implementation is available through open source.&nbsp; Furthermore, we worked on formal verification techniques for cryptography. In particular, we have designed a new probabilistic reaction logic suitable for describing cryptographic protocols. We have implemented our mechanized proofs in Coq. Besides this, we also designed a mechanized proof system for lattice-based cryptography.&nbsp; &nbsp;</p>\n<p>The co-PI and his group designed the first provably secure SNARG for NP without any setup in the random oracle model.&nbsp;</p>\n<p>The PI participated in the steering committee of a ZKP standardization committee, and was in conversation with cryptocurrency projects regarding the applications of ZKP in blockchain and smart contact applications.</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 12/15/2021<br>\n\t\t\t\t\tModified by: Elaine&nbsp;Shi</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nWe designed and implemented a system called xjSNARK, which can compile programs written in a high-level imperative language to efficient circuit representations suitable for zero-knowlege proofs (ZKP). Our compiler can often generate circuits that are more succinct than hand-optimized ones. We evaluated our compiler using various applications that might be of interest in blockchain applications, e.g., privacy-preserving smart contracts. We have open sourced our implementation.  Our postdoc collaborated with a group of researchers at Technion, and helped with the design, implementation, and improvement of zk-STARKs without trusted setup. \n\n \n\nModern distributed systems involve interactions between principals with limited trust. In this setting, cryptographic protocols are used to protect confidentiality and integrity; unfortunately, most developers do not have the training to design, implement, or securely combine cryptographic protocols. We worked on a programming language and compiler that can automatically compile a user-supplied high-level specification with security annotations into a cryptographic protocol satisfying the security requirements. Our compiler can analyze the security annotations provided by the programmer, and search for the most efficient cryptographic implementation that can satisfy these security goals. We have implemented our design and the implementation is available through open source.  Furthermore, we worked on formal verification techniques for cryptography. In particular, we have designed a new probabilistic reaction logic suitable for describing cryptographic protocols. We have implemented our mechanized proofs in Coq. Besides this, we also designed a mechanized proof system for lattice-based cryptography.   \n\nThe co-PI and his group designed the first provably secure SNARG for NP without any setup in the random oracle model. \n\nThe PI participated in the steering committee of a ZKP standardization committee, and was in conversation with cryptocurrency projects regarding the applications of ZKP in blockchain and smart contact applications.\n\n \n\n \n\n\t\t\t\t\tLast Modified: 12/15/2021\n\n\t\t\t\t\tSubmitted by: Elaine Shi"
 }
}