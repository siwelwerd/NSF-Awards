{
 "awd_id": "1655073",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "EAGER:    Algorithms for Data Set Versioning: Store or Re-create?",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": null,
 "po_email": "",
 "po_sign_block_name": "Rahul Shah",
 "awd_eff_date": "2016-09-01",
 "awd_exp_date": "2017-08-31",
 "tot_intn_awd_amt": 75000.0,
 "awd_amount": 75000.0,
 "awd_min_amd_letter_date": "2016-09-06",
 "awd_max_amd_letter_date": "2016-09-06",
 "awd_abstract_narration": "Technologically facilitated access to large data sets is increasingly emerging as key to scientific research in areas ranging from medicine to climate change with teams of researchers simultaneously engaged in accessing, modifying and cleaning data sets. Not surprisingly, such collaborative data-use has engendered substantial challenges related to data management. Indeed, the continuous modification of large-scale data sets frequently results in the creation of thousands of versions of data sets over time, especially as multiple users? access and edit the data over time. Such proliferation raises some basic questions: Should all versions of a document be saved? While this is certainly convenient, the storage costs may be prohibitively high. Alternatively, should only a certain version be saved? In this case, while the storage costs are low, the cost of recreating a particular version can rise significantly due to the effort involved in making changes to an existing version. This project focuses on the fundamental challenges arising from balancing storage needs with efficient retrieval of information in the context of big data. Thus the primary research goal of this proposal is to design provably good algorithms that will not only result in a deeper understanding of the storage and re-creation tradeoff but will also contribute to the development of effective data storage systems that are based on a sound theoretical foundation.\r\n\r\nIn previous NSF-funded projects, the PI has collaborated extensively and successfully with women and high school students and this project will also involve similar collaborations. Over the course of the past five years, the PI has graduated three women PhDs and is currently advising another three. He has also worked with several women undergraduates who are now pursuing doctoral degrees. Additionally, the PI has played a key role establishing connections with the national Braid project, supporting the departmental chapter of the Association of Women in Computing and organizing events and activities focused on bringing in established women computer scientists as role models for current students.\r\n \r\nThis fundamental problem can be modeled within a graph theoretic framework, as a directed weighted graph.  Each node denotes a version. In the general form each edge (a,b) has two associated parameters - a weight denoting the storage cost to generate version b, given a copy of a and a cost denoting the cost  to actually perform the computation  of converting a to b. While both these are closely related, they could be different. In addition, the edge weights and costs can be wildly asymmetric. The primary reason for this is that when a new version is created by deleting data, we can simply specify that a significant portion of the data is deleted, however the reverse operation of insertion needs to actually specify the data to be inserted. In this framework, the goal is to compute a rooted tree and the structure and depth of the tree controls the storage and re-creation trade-off. While there exists a deep understanding of this problem for undirected graphs, none of those methods work effectively for directed graphs. This project will develop a deeper understanding of this basic problem.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Samir",
   "pi_last_name": "Khuller",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Samir Khuller",
   "pi_email_addr": "samir.khuller@northwestern.edu",
   "nsf_id": "000177377",
   "pi_start_date": "2016-09-06",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Maryland, College Park",
  "inst_street_address": "3112 LEE BUILDING",
  "inst_street_address_2": "",
  "inst_city_name": "COLLEGE PARK",
  "inst_state_code": "MD",
  "inst_state_name": "Maryland",
  "inst_phone_num": "3014056269",
  "inst_zip_code": "207425100",
  "inst_country_name": "United States",
  "cong_dist_code": "04",
  "st_cong_dist_code": "MD04",
  "org_lgl_bus_name": "UNIVERSITY OF MARYLAND, COLLEGE PARK",
  "org_prnt_uei_num": "NPU8ULVAAS23",
  "org_uei_num": "NPU8ULVAAS23"
 },
 "perf_inst": {
  "perf_inst_name": "University of Maryland College Park",
  "perf_str_addr": "",
  "perf_city_name": "",
  "perf_st_code": "MD",
  "perf_st_name": "Maryland",
  "perf_zip_code": "207425141",
  "perf_ctry_code": "US",
  "perf_cong_dist": "04",
  "perf_st_cong_dist": "MD04",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779600",
   "pgm_ele_name": "Algorithmic Foundations"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7916",
   "pgm_ref_txt": "EAGER"
  },
  {
   "pgm_ref_code": "7926",
   "pgm_ref_txt": "ALGORITHMS"
  }
 ],
 "app_fund": [
  {
   "app_code": "0116",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001617DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2016,
   "fund_oblg_amt": 75000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>In this project, we studied a fundamental problem of managing<br />and maintaining multiple dynamically changing version of<br />big data sets. This is a central problem in many applications<br />dealing with many diverse users editing a common data repository.<br />Every small change generates a new version,<br />some of which might be rarely accessed again - thus we cannot<br />afford to explicitly store each version and this leads to<br />a basic tradeoff about which versions to explictly store and<br />for which versions to simply record the changes and then re-apply<br />these if that version is needed. In this way we save on storage,<br />but the retrieval cost goes up.<br /><br />Such a basic problem can be modeled by a directed graph model;<br />and while we have an excellent understanding of how to work<br />with undirected graphs for such a tradeoff, the directed graph<br />problem turns out to be significantly more complex and we<br />can show that the kinds of results that are possible in an undriected<br />graph setting would not be obtainable in a directed graph setting.<br />This firmly establishes that unless we focus on special properties<br />of the graph, it will be difficult to prove results of the<br />type that have been shown in the undirected graph setting.<br /><br />This opens up some new avenues for research, and for example<br />if the graphs are sparse, or planar, we can hope to develop<br />some interesting algorithms.<br /><br /><br /></p><br>\n<p>\n\t\t\t\t      \tLast Modified: 02/27/2018<br>\n\t\t\t\t\tModified by: Samir&nbsp;Khuller</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nIn this project, we studied a fundamental problem of managing\nand maintaining multiple dynamically changing version of\nbig data sets. This is a central problem in many applications\ndealing with many diverse users editing a common data repository.\nEvery small change generates a new version,\nsome of which might be rarely accessed again - thus we cannot\nafford to explicitly store each version and this leads to\na basic tradeoff about which versions to explictly store and\nfor which versions to simply record the changes and then re-apply\nthese if that version is needed. In this way we save on storage,\nbut the retrieval cost goes up.\n\nSuch a basic problem can be modeled by a directed graph model;\nand while we have an excellent understanding of how to work\nwith undirected graphs for such a tradeoff, the directed graph\nproblem turns out to be significantly more complex and we\ncan show that the kinds of results that are possible in an undriected\ngraph setting would not be obtainable in a directed graph setting.\nThis firmly establishes that unless we focus on special properties\nof the graph, it will be difficult to prove results of the\ntype that have been shown in the undirected graph setting.\n\nThis opens up some new avenues for research, and for example\nif the graphs are sparse, or planar, we can hope to develop\nsome interesting algorithms.\n\n\n\n\n\t\t\t\t\tLast Modified: 02/27/2018\n\n\t\t\t\t\tSubmitted by: Samir Khuller"
 }
}