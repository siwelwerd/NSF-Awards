{
 "awd_id": "1553168",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "CAREER:  Synthesis in a Live Programming Environment",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032922585",
 "po_email": "pprabhak@nsf.gov",
 "po_sign_block_name": "Pavithra Prabhakar",
 "awd_eff_date": "2016-01-15",
 "awd_exp_date": "2021-09-30",
 "tot_intn_awd_amt": 463272.0,
 "awd_amount": 463272.0,
 "awd_min_amd_letter_date": "2016-01-15",
 "awd_max_amd_letter_date": "2020-02-11",
 "awd_abstract_narration": "A live programming environment allows a programmer to immediately see the effects of changes to a program on its outputs and effectively eliminates the edit-run-debug cycle that dominates programming work flows today. Live programming is an emerging paradigm that is promising a vast change in the techniques used to develop modern software. This project combines live programming and software synthesis. By generating representative examples to illustrate code behavior, the user can more easily understand the code. If the user notices examples that do not match the intended behavior, the user can either modify the source code, or change the examples to correctly convey the behavior. Invoking a programming by example synthesis algorithm on those updated examples will automatically generate code, which is then merged with the original source code. We call this concept cooperative programming.\r\n\r\nThe intellectual merits of this project include: devising novel real-time algorithms to synthesize code, investigating new fault localization techniques, and developing code repair that is intuitive and natural for the user. In addition, the project is focused on establishing a formal theoretical framework for synthesis in a feedback loop. These ideas will be evaluated in a modern, major programming language, thus making it readily accessible to programmers. In this way, the broader impact of cooperative programming is to increase programmer productivity while simultaneously lowering the barriers to entry for novice programmers, such as secondary school students.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Ruzica",
   "pi_last_name": "Piskac",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Ruzica Piskac",
   "pi_email_addr": "ruzica.piskac@yale.edu",
   "nsf_id": "000655841",
   "pi_start_date": "2016-01-15",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Yale University",
  "inst_street_address": "150 MUNSON ST",
  "inst_street_address_2": "",
  "inst_city_name": "NEW HAVEN",
  "inst_state_code": "CT",
  "inst_state_name": "Connecticut",
  "inst_phone_num": "2037854689",
  "inst_zip_code": "065113572",
  "inst_country_name": "United States",
  "cong_dist_code": "03",
  "st_cong_dist_code": "CT03",
  "org_lgl_bus_name": "YALE UNIV",
  "org_prnt_uei_num": "FL6GV84CKN57",
  "org_uei_num": "FL6GV84CKN57"
 },
 "perf_inst": {
  "perf_inst_name": "Yale University",
  "perf_str_addr": "AKWatson Hall",
  "perf_city_name": "New Haven",
  "perf_st_code": "CT",
  "perf_st_name": "Connecticut",
  "perf_zip_code": "065208285",
  "perf_ctry_code": "US",
  "perf_cong_dist": "03",
  "perf_st_cong_dist": "CT03",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "1045",
   "pgm_ref_txt": "CAREER-Faculty Erly Career Dev"
  },
  {
   "pgm_ref_code": "8206",
   "pgm_ref_txt": "Formal Methods and Verification"
  }
 ],
 "app_fund": [
  {
   "app_code": "0116",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001617DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0117",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001718DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0119",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001920DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0120",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01002021DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2016,
   "fund_oblg_amt": 179488.0
  },
  {
   "fund_oblg_fiscal_yr": 2017,
   "fund_oblg_amt": 95577.0
  },
  {
   "fund_oblg_fiscal_yr": 2019,
   "fund_oblg_amt": 92905.0
  },
  {
   "fund_oblg_fiscal_yr": 2020,
   "fund_oblg_amt": 95302.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Live programming is a novel approach for programming practice. Programmers are given real-time feedback when writing code, traditionally via a graphical user interface. Despite live programming&rsquo;s practical values, such as providing an easier overview of code and a better understanding of its structure, it is not yet widely used. This award was focused on extending live programming to general-purpose code editors, which allow for live programming to be used by programmers. It also provided new interfaces for understanding and changing the functionality of code. To achieve this we integrated programming by example (PBE) synthesis into our tool by allowing the user to change the shown output, and have the code update automatically. The live programming paradigm gives novice programmers a new way to interact and understand programming, as well as being a useful development tool for more advanced programmers.<br /><br />However, to be able to use the PBE paradigm, we needed to translate the program into mathematical formalism, so that we can apply and extend existing PBE algorithms which are working on the premise that the program is represented as a mathematical formula. For this purpose, we developed a symbolic execution engine for Haskell. Our methods are general and can be applied to other programming languages, but we used the Haskell programming language as the language to apply our concepts. Symbolic execution is commonly used for testing. It allows generating counterexamples that violate assertions or hit errors in a program. Our symbolic execution for Haskell, called G2, is the first symbolic execution tool for a non-strict language. Non-strictness is a language property that requires an evaluation to be performed only as needed, which allows, for example, non-strict languages to handle infinite data structures. However, the main obstacle for our symbolic execution (and every modular verifier) is when the program has actually a correct specification, but it also invokes callee functions that have an imprecise specification. In this case, the verification fails. We introduced the novel concept of abstract counterexamples to help programmers debug errors due to imprecise specifications.<br /><br />While abstract counterexamples are useful as feedback to a programmer struggling with a modular verifier, they still ultimately require the programmer to debug why verification is failing, and manually find sufficient function specifications. The process of verification works as follows. First, a programmer manually writes a specification corresponding to the code. If the modular verifier succeeds in verifying the specification, the programmer is done. Otherwise, they can examine concrete or abstract counterexamples, to understand the failure. Then, they must return to the first step and update the code or the specification based on the found counterexample. Even with counterexamples, this can be a tedious process. Our key insight was that the verification process<br />matches a well-known technique in the synthesis community: a counterexample-guided inductive synthesis (CEGIS) loop. In the verification loop, the only step that is not automated is the user writing specifications. Thus, we automated the process by using a counterexample-guided synthesizer; that is, a program that takes the counterexamples, and automatically produces specifications that block the counterexamples. This way we managed to automatically prove the correctness of large modular programs, invoking over 30 callee functions. The user only needed to provide a top-level specification and the specifications for all the callee functions are inferred automatically, resulting in a successful verification of the given program. <br /><br />We applied the developed techniques to general program verification, network verification and repair, and computer music synthesis.<br /><br />From a broad impact perspective, this award supported several PhD students. Mark Santolucito has now graduated and is an assistant professor at Barnard College. Bill Hallahan is about to graduate (his defense is scheduled for March 9th, 2022) and he is already interviewing for an assistant professor position at various university.&nbsp; As a part of this project, we have brought several undergraduate and high school students into research. As an example, we published a paper at a major AI conference with high school students as co-authors. Two undergraduate students who worked on this award, after publishing peer-reviewed papers, decided to go to graduate school and now are PhD students at UPenn and Columbia.&nbsp; Anton Xue, who published several papers at top-tier venues (including PLDI), has also won the prestigious 2019 NSF Graduate Research Fellowship. We wrote a paper about our experiences involving these students with research, entitled \"Formal Methods and Computing Identity-based Mentorship for Early Stage Researchers\". <br /><br />The work obtained on this award also received recognition from the industry: the PI has received the Amazon Research Award for this work in Spring 2021 and the Facebook Communications and Networking award in 2018.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 04/01/2022<br>\n\t\t\t\t\tModified by: Ruzica&nbsp;Piskac</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nLive programming is a novel approach for programming practice. Programmers are given real-time feedback when writing code, traditionally via a graphical user interface. Despite live programming\u2019s practical values, such as providing an easier overview of code and a better understanding of its structure, it is not yet widely used. This award was focused on extending live programming to general-purpose code editors, which allow for live programming to be used by programmers. It also provided new interfaces for understanding and changing the functionality of code. To achieve this we integrated programming by example (PBE) synthesis into our tool by allowing the user to change the shown output, and have the code update automatically. The live programming paradigm gives novice programmers a new way to interact and understand programming, as well as being a useful development tool for more advanced programmers.\n\nHowever, to be able to use the PBE paradigm, we needed to translate the program into mathematical formalism, so that we can apply and extend existing PBE algorithms which are working on the premise that the program is represented as a mathematical formula. For this purpose, we developed a symbolic execution engine for Haskell. Our methods are general and can be applied to other programming languages, but we used the Haskell programming language as the language to apply our concepts. Symbolic execution is commonly used for testing. It allows generating counterexamples that violate assertions or hit errors in a program. Our symbolic execution for Haskell, called G2, is the first symbolic execution tool for a non-strict language. Non-strictness is a language property that requires an evaluation to be performed only as needed, which allows, for example, non-strict languages to handle infinite data structures. However, the main obstacle for our symbolic execution (and every modular verifier) is when the program has actually a correct specification, but it also invokes callee functions that have an imprecise specification. In this case, the verification fails. We introduced the novel concept of abstract counterexamples to help programmers debug errors due to imprecise specifications.\n\nWhile abstract counterexamples are useful as feedback to a programmer struggling with a modular verifier, they still ultimately require the programmer to debug why verification is failing, and manually find sufficient function specifications. The process of verification works as follows. First, a programmer manually writes a specification corresponding to the code. If the modular verifier succeeds in verifying the specification, the programmer is done. Otherwise, they can examine concrete or abstract counterexamples, to understand the failure. Then, they must return to the first step and update the code or the specification based on the found counterexample. Even with counterexamples, this can be a tedious process. Our key insight was that the verification process\nmatches a well-known technique in the synthesis community: a counterexample-guided inductive synthesis (CEGIS) loop. In the verification loop, the only step that is not automated is the user writing specifications. Thus, we automated the process by using a counterexample-guided synthesizer; that is, a program that takes the counterexamples, and automatically produces specifications that block the counterexamples. This way we managed to automatically prove the correctness of large modular programs, invoking over 30 callee functions. The user only needed to provide a top-level specification and the specifications for all the callee functions are inferred automatically, resulting in a successful verification of the given program. \n\nWe applied the developed techniques to general program verification, network verification and repair, and computer music synthesis.\n\nFrom a broad impact perspective, this award supported several PhD students. Mark Santolucito has now graduated and is an assistant professor at Barnard College. Bill Hallahan is about to graduate (his defense is scheduled for March 9th, 2022) and he is already interviewing for an assistant professor position at various university.  As a part of this project, we have brought several undergraduate and high school students into research. As an example, we published a paper at a major AI conference with high school students as co-authors. Two undergraduate students who worked on this award, after publishing peer-reviewed papers, decided to go to graduate school and now are PhD students at UPenn and Columbia.  Anton Xue, who published several papers at top-tier venues (including PLDI), has also won the prestigious 2019 NSF Graduate Research Fellowship. We wrote a paper about our experiences involving these students with research, entitled \"Formal Methods and Computing Identity-based Mentorship for Early Stage Researchers\". \n\nThe work obtained on this award also received recognition from the industry: the PI has received the Amazon Research Award for this work in Spring 2021 and the Facebook Communications and Networking award in 2018.\n\n\t\t\t\t\tLast Modified: 04/01/2022\n\n\t\t\t\t\tSubmitted by: Ruzica Piskac"
 }
}