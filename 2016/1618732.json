{
 "awd_id": "1618732",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Small: Foundations of Just-in-Time Compilation",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927885",
 "po_email": "abanerje@nsf.gov",
 "po_sign_block_name": "Anindya Banerjee",
 "awd_eff_date": "2016-09-01",
 "awd_exp_date": "2021-08-31",
 "tot_intn_awd_amt": 449831.0,
 "awd_amount": 449831.0,
 "awd_min_amd_letter_date": "2016-07-05",
 "awd_max_amd_letter_date": "2016-07-05",
 "awd_abstract_narration": "Modern programming languages ranging from Java to Matlab rely on just-in-time compilation techniques to achieve performance competitive with computer languages such as C or C++. What sets just-in-time compilers apart from batch compilers is that they can observe the programs actions as it executes, and inspect its state. Knowledge of the program's state and past behavior, allows the compiler to perform speculative optimizations that improve performance. The intellectual merits of this research are to devise techniques for reasoning about the correctness of the transformations performed by just-in-time compilers. The project's broader significance and importance are its implications to industrial practice. The results of this research will be applicable to commercial just-in-time compilers for languages such as JavaScript and R.\r\n\r\nThis project develops a general model of just-in-time compilation that subsumes deployed systems and allows systematic exploration of the design space of dynamic compilation techniques. The research questions that will be tackled in this work lie along two dimensions: Experimental -- explore the design space of dynamic compilation  techniques and gain an understanding of trade-offs; Foundational -- formalize key ingredients of a dynamic compiler and develop techniques for reasoning about correctness in a modular fashion.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Jan",
   "pi_last_name": "Vitek",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Jan Vitek",
   "pi_email_addr": "j.vitek@neu.edu",
   "nsf_id": "000290862",
   "pi_start_date": "2016-07-05",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Amal",
   "pi_last_name": "Ahmed",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Amal Ahmed",
   "pi_email_addr": "amal@ccs.neu.edu",
   "nsf_id": "000573498",
   "pi_start_date": "2016-07-05",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Northeastern University",
  "inst_street_address": "360 HUNTINGTON AVE",
  "inst_street_address_2": "",
  "inst_city_name": "BOSTON",
  "inst_state_code": "MA",
  "inst_state_name": "Massachusetts",
  "inst_phone_num": "6173735600",
  "inst_zip_code": "021155005",
  "inst_country_name": "United States",
  "cong_dist_code": "07",
  "st_cong_dist_code": "MA07",
  "org_lgl_bus_name": "NORTHEASTERN UNIVERSITY",
  "org_prnt_uei_num": "",
  "org_uei_num": "HLTMVS2JZBS6"
 },
 "perf_inst": {
  "perf_inst_name": "Northeastern University",
  "perf_str_addr": "",
  "perf_city_name": "",
  "perf_st_code": "MA",
  "perf_st_name": "Massachusetts",
  "perf_zip_code": "021155005",
  "perf_ctry_code": "US",
  "perf_cong_dist": "07",
  "perf_st_cong_dist": "MA07",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7943",
   "pgm_ref_txt": "PROGRAMMING LANGUAGES"
  }
 ],
 "app_fund": [
  {
   "app_code": "0116",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001617DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2016,
   "fund_oblg_amt": 449831.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><div class=\"tinyMCEContent\">\n<p>Modern programming languages ranging from Java to Matlab rely on&nbsp;just-in-time compilation techniques to achieve performance competitive with&nbsp;traditional, compiled ahead-of-time, computer languages such as C or&nbsp;C++. What sets dynamic compilers apart from batch compilers is the&nbsp;availability of the run-time state of the ongoing computation. Knowledge of&nbsp;the program's state and past behavior, is a key for speculative&nbsp;optimizations that can greatly improve the performance of the running&nbsp;application. The soundness of such code transformations assumes&nbsp;that observed program properties are stable for&nbsp;the remainder of the computation. When one such assumption is violated and a&nbsp;property changes, for instance, due to updates performed by the program in&nbsp;the heap, the compiler is forced to undo all transformations&nbsp;that depend on the property in order to revert the program to a&nbsp;consistent state. This project investigated the foundations of&nbsp;just-in-time compilation following a two-pronged strategy that combines&nbsp;empirical and theoretical advances to the state of the art.&nbsp;</p>\n<p>&nbsp;We followed two main research lines. Firstly, we investigated the foundations of compiler correctness and the techniques for veryfying just-in-time compilers. Secondly, we put our ideas to the test by working on real-world compilers for a complex and widely used language. &nbsp;Our goals were to investigate the proof methodologies required for verify compilers that generate code during program execution and the implication of these choices on the architecture of modern compilers. &nbsp;&nbsp;</p>\n</div>\n<dl class=\"clearing\"><dt>The project's contributions included: (1) The study of real-world JIT to understand what elements of the compiler are key to performance. (2) &nbsp;The model of a JIT for a minimal dynamic language and its mechanized proof of correctness. (3) he verification of a key component in modern languages,namely &nbsp;a concurrent garbage collector. (4) The design of intermediate representations for JIT compilers based on LLVM and WebAsembly.</dt></dl><br>\n<p>\n\t\t\t\t      \tLast Modified: 10/15/2021<br>\n\t\t\t\t\tModified by: Jan&nbsp;Vitek</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\n\nModern programming languages ranging from Java to Matlab rely on just-in-time compilation techniques to achieve performance competitive with traditional, compiled ahead-of-time, computer languages such as C or C++. What sets dynamic compilers apart from batch compilers is the availability of the run-time state of the ongoing computation. Knowledge of the program's state and past behavior, is a key for speculative optimizations that can greatly improve the performance of the running application. The soundness of such code transformations assumes that observed program properties are stable for the remainder of the computation. When one such assumption is violated and a property changes, for instance, due to updates performed by the program in the heap, the compiler is forced to undo all transformations that depend on the property in order to revert the program to a consistent state. This project investigated the foundations of just-in-time compilation following a two-pronged strategy that combines empirical and theoretical advances to the state of the art. \n\n We followed two main research lines. Firstly, we investigated the foundations of compiler correctness and the techniques for veryfying just-in-time compilers. Secondly, we put our ideas to the test by working on real-world compilers for a complex and widely used language.  Our goals were to investigate the proof methodologies required for verify compilers that generate code during program execution and the implication of these choices on the architecture of modern compilers.   \n\nThe project's contributions included: (1) The study of real-world JIT to understand what elements of the compiler are key to performance. (2)  The model of a JIT for a minimal dynamic language and its mechanized proof of correctness. (3) he verification of a key component in modern languages,namely  a concurrent garbage collector. (4) The design of intermediate representations for JIT compilers based on LLVM and WebAsembly.\n\n\t\t\t\t\tLast Modified: 10/15/2021\n\n\t\t\t\t\tSubmitted by: Jan Vitek"
 }
}