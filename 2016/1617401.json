{
 "awd_id": "1617401",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Small: Design and Inference of Choreography Types to Reduce Concurrency Programming Errors",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927841",
 "po_email": "sgreensp@nsf.gov",
 "po_sign_block_name": "Sol Greenspan",
 "awd_eff_date": "2016-06-01",
 "awd_exp_date": "2020-05-31",
 "tot_intn_awd_amt": 500000.0,
 "awd_amount": 500000.0,
 "awd_min_amd_letter_date": "2016-05-19",
 "awd_max_amd_letter_date": "2016-05-19",
 "awd_abstract_narration": "With the growth of the web, cloud computing, sensor networks and\r\nmulticore programming, concurrency has become critical to software\r\napplications in the real world.  Because the Actor model of concurrent\r\ncomputation provides scalable concurrency, commercial software is\r\noften written using the Actor model.  Many concurrency related errors\r\nsuch as unprocessable messages, deadlocks, and livelocks result from a\r\nmismatch of component actors in a system.  The research develops\r\nchoreography types as a method to understand concurrency structures\r\nand detect concurrency related bugs.  The intuition behind the\r\nresearch is that combining symbolic execution with information from\r\nconcrete traces obtained during unit testing can provide a way to\r\ninfer and approximate choreography types.\r\n \r\nThe research would make concurrent and distributed programming\r\nsafer--increasing trust in applications such as cloud computing on\r\nwhich a large part of the US economy is dependent today.  Much as data\r\ntypes help programmers think about the interfaces of components in a\r\nsequential program, the research would provide ways in which\r\nprogrammers can think about the structure of parallel programs in\r\nterms of choreographing actors with evolving type structure.  The\r\neducational impact of the research is to facilitate teaching scalable\r\nparallel programming, creating tools that expose and facilitate the\r\nunderstanding of the structure of concurrent programs.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Gul",
   "pi_last_name": "Agha",
   "pi_mid_init": "A",
   "pi_sufx_name": "",
   "pi_full_name": "Gul A Agha",
   "pi_email_addr": "agha@cs.uiuc.edu",
   "nsf_id": "000461849",
   "pi_start_date": "2016-05-19",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Illinois at Urbana-Champaign",
  "inst_street_address": "506 S WRIGHT ST",
  "inst_street_address_2": "",
  "inst_city_name": "URBANA",
  "inst_state_code": "IL",
  "inst_state_name": "Illinois",
  "inst_phone_num": "2173332187",
  "inst_zip_code": "618013620",
  "inst_country_name": "United States",
  "cong_dist_code": "13",
  "st_cong_dist_code": "IL13",
  "org_lgl_bus_name": "UNIVERSITY OF ILLINOIS",
  "org_prnt_uei_num": "V2PHZ2CSCH63",
  "org_uei_num": "Y8CWNJRCNN91"
 },
 "perf_inst": {
  "perf_inst_name": "University of Illinois at Urbana-Champaign",
  "perf_str_addr": "",
  "perf_city_name": "",
  "perf_st_code": "IL",
  "perf_st_name": "Illinois",
  "perf_zip_code": "618207473",
  "perf_ctry_code": "US",
  "perf_cong_dist": "13",
  "perf_st_cong_dist": "IL13",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7944",
   "pgm_ref_txt": "SOFTWARE ENG & FORMAL METHODS"
  }
 ],
 "app_fund": [
  {
   "app_code": "0116",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001617DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2016,
   "fund_oblg_amt": 500000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Applications such as <em>mobile computing</em>, <em>cloud computing</em> and <em>the internet of things</em> require <em>concurrent and distributed programs</em>.&nbsp;&nbsp; Scalable commercial software is often written using <em>actor programming languages</em> such as Erlang, Akka, and the Orleans Actor Framework.&nbsp; Many bugs in concurrent and distributed systems are the result of errors caused by errors in synchronizing and coordinating actions across actors.&nbsp; Such problems including <em>unprocessable messages</em>, <em>deadlocks</em>, and <em>livelocks</em>, all of which result from mismatch in actions by different actors in a system.&nbsp; The project developed four new methods to discover and prevent such bugs:</p>\n<p><strong>Types for progress</strong>.&nbsp; A method to specify and statically guarantee that for a large class of interaction patterns that are common between groups of actors was developed.&nbsp; Specifically, a formal type system was developed to represent constraints on the order of messages (based on the types of messages) a group of actors sends and receives.&nbsp; For example, in an auction protocol, the order of messages between a seller and buyers follows order: (1) a seller asks for bids; (2) potential buyers may bid; (3) the seller accepts a bid from a specific buyer; (4) the accepted buyer must pay; and (5) the seller must ship the book.</p>\n<p>The sequences in which this ordering occurs are complicated by the fact that other messages and computations may be interleaved at the buyer and seller, there may be multiple buyers and sellers, etc. The type system was formalized for a simple actor language which captures the essential features of for practical actor languages. Sufficient conditions to establish that message requirements that arise during (fairly scheduled) executions of well-typed programs are always eventually satisfied were defined and proved correct.&nbsp; By checking properties of these types, programmers can guarantee that a deadlock will not result when actors with the correct local types are composed when the local types are compatible with a deadlock-free&nbsp; choreography type.</p>\n<p><strong>A method to discover concurrency bugs.</strong>&nbsp; A novel method combining program analysis and dynamic execution was developed to test for concurrency programs. The builds a <em>Message Flow Graph</em> (MFG) of an actor system and uses it to guide executions for testing.&nbsp; A tool for testing Akka programs was developed (Akka is an actor framework popular in commercial applications). &nbsp;The tool found previously undetected bugs in open-source programs and reference implementations for Savina benchmark of programs.</p>\n<p><strong>A method to understand the implicit concurrency structure of an actor program.</strong>&nbsp; Programmers write individual actors and the &nbsp;coordination between different actors is implicit in the code.&nbsp; This &nbsp;&nbsp;makes it hard to ensure that the concurrency structure of the program is correct, or that it is not destroyed by subsequent updates to individual actors (possibly done by other programmers). &nbsp;&nbsp;A method was developed to infer the concurrency structure of an actor program, where the concurrency structure is represented by <em>Specification Diagrams</em>&mdash;a formal graphical notation.&nbsp; A tool was developed to aid visualization.&nbsp; The tool was demonstrated on a set of benchmark actor programs.</p>\n<p><strong>A method to detect termination in a concurrent and distributed program.</strong>&nbsp; Actors in a distributed system represent active processes.&nbsp; When an actor has terminated, it needs to be garbage collected (deleted) to save resources.&nbsp; However, detecting that an actor has terminated is complicated because an inactive actor may eventually receive a message from another actor and become active.&nbsp; This eventuality is not bounded in a distributed system as messages may be generated in the future or arbitrarily delayed. Incorrect deletion is a source of bugs in concurrent and distributed programs.&nbsp; We developed an efficient and scalable method for detecting when an actor has terminated by tracking the evolving reference structure of an actor program.&nbsp; Of critical importance is the fact that the tracking is entirely decentralized and does not require expensive global communication protocols to be imposed as is the case in previous work.&nbsp; &nbsp;&nbsp;</p>\n<p>By some estimates, testing accounts for over half the cost of software development and maintenance in the real-world.&nbsp; Despite this, concurrency bugs are a major source of lost revenue and in some cases lost lives.&nbsp; The results in the project will help industry adopt more effective methods for analyzing programs, discovering, and preventing bugs.</p>\n<p>Two graduate students were supported and gained experience in research in concurrent programming languages.&nbsp; Three undergraduates also participated on the project.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 12/11/2020<br>\n\t\t\t\t\tModified by: Gul&nbsp;A&nbsp;Agha</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nApplications such as mobile computing, cloud computing and the internet of things require concurrent and distributed programs.   Scalable commercial software is often written using actor programming languages such as Erlang, Akka, and the Orleans Actor Framework.  Many bugs in concurrent and distributed systems are the result of errors caused by errors in synchronizing and coordinating actions across actors.  Such problems including unprocessable messages, deadlocks, and livelocks, all of which result from mismatch in actions by different actors in a system.  The project developed four new methods to discover and prevent such bugs:\n\nTypes for progress.  A method to specify and statically guarantee that for a large class of interaction patterns that are common between groups of actors was developed.  Specifically, a formal type system was developed to represent constraints on the order of messages (based on the types of messages) a group of actors sends and receives.  For example, in an auction protocol, the order of messages between a seller and buyers follows order: (1) a seller asks for bids; (2) potential buyers may bid; (3) the seller accepts a bid from a specific buyer; (4) the accepted buyer must pay; and (5) the seller must ship the book.\n\nThe sequences in which this ordering occurs are complicated by the fact that other messages and computations may be interleaved at the buyer and seller, there may be multiple buyers and sellers, etc. The type system was formalized for a simple actor language which captures the essential features of for practical actor languages. Sufficient conditions to establish that message requirements that arise during (fairly scheduled) executions of well-typed programs are always eventually satisfied were defined and proved correct.  By checking properties of these types, programmers can guarantee that a deadlock will not result when actors with the correct local types are composed when the local types are compatible with a deadlock-free  choreography type.\n\nA method to discover concurrency bugs.  A novel method combining program analysis and dynamic execution was developed to test for concurrency programs. The builds a Message Flow Graph (MFG) of an actor system and uses it to guide executions for testing.  A tool for testing Akka programs was developed (Akka is an actor framework popular in commercial applications).  The tool found previously undetected bugs in open-source programs and reference implementations for Savina benchmark of programs.\n\nA method to understand the implicit concurrency structure of an actor program.  Programmers write individual actors and the  coordination between different actors is implicit in the code.  This   makes it hard to ensure that the concurrency structure of the program is correct, or that it is not destroyed by subsequent updates to individual actors (possibly done by other programmers).   A method was developed to infer the concurrency structure of an actor program, where the concurrency structure is represented by Specification Diagrams&mdash;a formal graphical notation.  A tool was developed to aid visualization.  The tool was demonstrated on a set of benchmark actor programs.\n\nA method to detect termination in a concurrent and distributed program.  Actors in a distributed system represent active processes.  When an actor has terminated, it needs to be garbage collected (deleted) to save resources.  However, detecting that an actor has terminated is complicated because an inactive actor may eventually receive a message from another actor and become active.  This eventuality is not bounded in a distributed system as messages may be generated in the future or arbitrarily delayed. Incorrect deletion is a source of bugs in concurrent and distributed programs.  We developed an efficient and scalable method for detecting when an actor has terminated by tracking the evolving reference structure of an actor program.  Of critical importance is the fact that the tracking is entirely decentralized and does not require expensive global communication protocols to be imposed as is the case in previous work.    \n\nBy some estimates, testing accounts for over half the cost of software development and maintenance in the real-world.  Despite this, concurrency bugs are a major source of lost revenue and in some cases lost lives.  The results in the project will help industry adopt more effective methods for analyzing programs, discovering, and preventing bugs.\n\nTwo graduate students were supported and gained experience in research in concurrent programming languages.  Three undergraduates also participated on the project.\n\n\t\t\t\t\tLast Modified: 12/11/2020\n\n\t\t\t\t\tSubmitted by: Gul A Agha"
 }
}