{
 "awd_id": "1617586",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "III: Small: Just in Time Datastructures",
 "cfda_num": "47.070",
 "org_code": "05020000",
 "po_phone": "7032927347",
 "po_email": "sspengle@nsf.gov",
 "po_sign_block_name": "Sylvia Spengler",
 "awd_eff_date": "2016-07-15",
 "awd_exp_date": "2020-06-30",
 "tot_intn_awd_amt": 494274.0,
 "awd_amount": 502274.0,
 "awd_min_amd_letter_date": "2016-07-21",
 "awd_max_amd_letter_date": "2017-04-13",
 "awd_abstract_narration": "Indexes have always been a critical component of any database.  Now that \"big data\" is a household term, they're more crucial than ever before.  Indexes keep data organized, making it faster and easier for you to get at anything from the microblogs in your stream to the money in your bank account.  Of course, it's sometimes hard to figure out how to best keep data organized.  For example, online social media often needs to handle over a hundred thousand new messages in a single second.  That's a lot of data that needs to be organized, and it needs to be organized fast to keep up with the users' needs.  The Just-in-Time Data Structures project is exploring ways to make indexes smarter, better able to prioritize their work, and better able to adapt to changing workload patterns.\r\n\r\nSpecifically, we're generalizing a class of index data structures called adaptive indexes.  In an adaptive index, data is organized as a side-effect of query processing.  In a just-in-time data structure, user-defined policies specify how an index is to be transformed in reaction to queries and new data.  Like a just-in-time compiler, the index is adaptively optimized for the workload that is currently being presented to it.  In addition to laying the foundations for research on just-in-time data structures, we are exploring how to design workload-optimal policies, and how just-in-time data structures can be adapted for incremental view maintenance.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "IIS",
 "org_div_long_name": "Division of Information & Intelligent Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Oliver",
   "pi_last_name": "Kennedy",
   "pi_mid_init": "A",
   "pi_sufx_name": "",
   "pi_full_name": "Oliver A Kennedy",
   "pi_email_addr": "okennedy@buffalo.edu",
   "nsf_id": "000630848",
   "pi_start_date": "2016-07-21",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Lukasz",
   "pi_last_name": "Ziarek",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Lukasz Ziarek",
   "pi_email_addr": "lziarek@buffalo.edu",
   "nsf_id": "000627706",
   "pi_start_date": "2016-07-21",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "SUNY at Buffalo",
  "inst_street_address": "520 LEE ENTRANCE STE 211",
  "inst_street_address_2": "",
  "inst_city_name": "AMHERST",
  "inst_state_code": "NY",
  "inst_state_name": "New York",
  "inst_phone_num": "7166452634",
  "inst_zip_code": "142282577",
  "inst_country_name": "United States",
  "cong_dist_code": "26",
  "st_cong_dist_code": "NY26",
  "org_lgl_bus_name": "THE RESEARCH FOUNDATION FOR THE STATE UNIVERSITY OF NEW YORK",
  "org_prnt_uei_num": "GMZUKXFDJMA9",
  "org_uei_num": "LMCJKRFW5R81"
 },
 "perf_inst": {
  "perf_inst_name": "SUNY at Buffalo",
  "perf_str_addr": "338 Davis Hall",
  "perf_city_name": "Buffalo",
  "perf_st_code": "NY",
  "perf_st_name": "New York",
  "perf_zip_code": "142602500",
  "perf_ctry_code": "US",
  "perf_cong_dist": "26",
  "perf_st_cong_dist": "NY26",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "736400",
   "pgm_ele_name": "Info Integration & Informatics"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7364",
   "pgm_ref_txt": "INFO INTEGRATION & INFORMATICS"
  },
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  }
 ],
 "app_fund": [
  {
   "app_code": "0116",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001617DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0117",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001718DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2016,
   "fund_oblg_amt": 494274.0
  },
  {
   "fund_oblg_fiscal_yr": 2017,
   "fund_oblg_amt": 8000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Data structures offer a range of trade-offs, with some optimized for fast writes, others optimized for fast reads, and still others providing features like concurrent access, support for range queries, and more.&nbsp; While it's possible to pick a data structure for any fixed workload, many workloads change over time.&nbsp; This is especially true of interactive workloads like analysis of big-data or checking email on your phone.&nbsp; In this grant, we have developed a set of techniques that allow the creation of \"Just-in-Time Data Structures\" that evolve over time.&nbsp; Specifically, a Just-in-Time Data Structure is designed to adapt to changing workloads, continuously re-optimizing its organizational layout in the background as the structure is accessed. This makes data access faster and less power-intensive, whether it's someone analyzing protein structure, or simply someone playing candy crush.<br /><br />We developed a set of building-blocks for Just-in-Time Data Structures: Nodes (concrete representations of portions of the data), Mutators (a way to manipulate the data), Accessors (a way to access the data), Transforms (techniques for re-organizing the data for a new workload), and Policies (strategies for when and where to apply transforms).&nbsp; We have also developed a language for defining Nodes, Mutators, Accessors, Transforms, and Policies. We have also developed a set of \"primitive\" Nodes (with accompanying Mutators, Accessors, Transforms, and Policies), that can be used to define more complex nodes. Critically, this allows us to automatically synthesize accompanying building blocks for the resulting \"complex\" Node types, which in turn makes it significantly easier to create new Just-in-Time Data Structures for different data models.<br /><br />As part of realizing Just-in-Time Data Structures, we developed an efficient way to search for opportunities to re-organize the data structure through a technique called Incremental View Maintenance (IVM). Specifically, we developed an IVM approach tailored to the tree layouts that appear in Just-in-Time Data Structures. Even with minimal optimization, this approach is able to outperform state-of-the-art IVM systems. As similar search problems appear in most optimizing compilers (whether just-in-time or not), we expect these techniques to be applicable to the broader programming languages, databases, and compilers communities.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 07/23/2020<br>\n\t\t\t\t\tModified by: Oliver&nbsp;A&nbsp;Kennedy</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nData structures offer a range of trade-offs, with some optimized for fast writes, others optimized for fast reads, and still others providing features like concurrent access, support for range queries, and more.  While it's possible to pick a data structure for any fixed workload, many workloads change over time.  This is especially true of interactive workloads like analysis of big-data or checking email on your phone.  In this grant, we have developed a set of techniques that allow the creation of \"Just-in-Time Data Structures\" that evolve over time.  Specifically, a Just-in-Time Data Structure is designed to adapt to changing workloads, continuously re-optimizing its organizational layout in the background as the structure is accessed. This makes data access faster and less power-intensive, whether it's someone analyzing protein structure, or simply someone playing candy crush.\n\nWe developed a set of building-blocks for Just-in-Time Data Structures: Nodes (concrete representations of portions of the data), Mutators (a way to manipulate the data), Accessors (a way to access the data), Transforms (techniques for re-organizing the data for a new workload), and Policies (strategies for when and where to apply transforms).  We have also developed a language for defining Nodes, Mutators, Accessors, Transforms, and Policies. We have also developed a set of \"primitive\" Nodes (with accompanying Mutators, Accessors, Transforms, and Policies), that can be used to define more complex nodes. Critically, this allows us to automatically synthesize accompanying building blocks for the resulting \"complex\" Node types, which in turn makes it significantly easier to create new Just-in-Time Data Structures for different data models.\n\nAs part of realizing Just-in-Time Data Structures, we developed an efficient way to search for opportunities to re-organize the data structure through a technique called Incremental View Maintenance (IVM). Specifically, we developed an IVM approach tailored to the tree layouts that appear in Just-in-Time Data Structures. Even with minimal optimization, this approach is able to outperform state-of-the-art IVM systems. As similar search problems appear in most optimizing compilers (whether just-in-time or not), we expect these techniques to be applicable to the broader programming languages, databases, and compilers communities.\n\n\t\t\t\t\tLast Modified: 07/23/2020\n\n\t\t\t\t\tSubmitted by: Oliver A Kennedy"
 }
}