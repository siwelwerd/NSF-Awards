{
 "awd_id": "1617487",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "CSR: Small: Operating Systems Kernels in High-Level Languages",
 "cfda_num": "47.070",
 "org_code": "05050000",
 "po_phone": "7032925197",
 "po_email": "mmcclure@nsf.gov",
 "po_sign_block_name": "Marilyn McClure",
 "awd_eff_date": "2016-10-01",
 "awd_exp_date": "2019-09-30",
 "tot_intn_awd_amt": 500000.0,
 "awd_amount": 500000.0,
 "awd_min_amd_letter_date": "2016-08-10",
 "awd_max_amd_letter_date": "2016-08-10",
 "awd_abstract_narration": "Most software depends on the correctness and efficiency of the underlying operating system kernel, since the kernel mediates access to resources such as storage, network, and memory. Kernels are typically implemented in low-level languages, for example, the Linux kernel is written in the C language; such languages are efficient but difficult to use correctly. In contrast, implementing kernels in high-level languages could in principle result in both reduced programmer effort and reduced incidence of bugs. This research will explore the costs and benefits of implementing kernels in high-level languages.\r\n\r\nThe main reason kernels use C is performance. C allows a kernel to define its own high-performance mechanisms for memory management, thread scheduling, interrupts, etc. In contrast, high-level languages tend to prescribe specific particular mechanisms in these areas, which are difficult to change. One potential problem is that high-level languages are often garbage-collected to improve safety, but garbage collection is widely viewed as too slow to use in kernels.\r\n\r\nThis project will first investigate performance: whether a kernel written in a high-level language can be as fast as a kernel written in C. The project will implement a kernel using the Go language, a type-safe, garbage-collected language with good support for threads. Then, the plan is to compare performance with existing C kernels such as Linux, OpenBSD, and FreeBSD. It is expected there will be a need to face efficiency and functionality challenges, particularly in the use of garbage collection for large kernel data structures such as file and page caches.\r\n\r\nThe project's second area of focus will be to exploit the high-level language to achieve multi-core in-kernel parallelism in situations that are not practical when using C. C impedes flexible use of transient threads, since the programmer must supply the logic to decide when the last thread has finished using each shared object, which can then be freed. Extensive use of threads is much easier when a garbage collector automates this task. The plan is to exploit Go's garbage collection by implementing complex system calls such as fork and exec using internal worker threads on multiple cores. The team will evaluate whether the resulting performance and scalability improvement can be made to outweigh the costs of garbage collection and thread overhead.\r\n\r\nIntellectual merit.\r\nThis work will shed quantitative light on the effect of language choice on kernel performance, a question that is currently understood mostly anecdotally. The interaction of garbage collection with the specific ways kernels use memory is particularly worth understanding. The investigation of in-kernel parallelism will exploit high-level language support to harness techniques that are impractical in C kernels.\r\n\r\nBroader impacts.\r\nThe work has the potential for broad impact because most software depends critically on services provided by the operating system kernel. Using a better language for the kernel would likely reduce the prevalence of bugs and increase the ease with which kernel developers can provide desirable new features. Providing solid evidence to support an eventual switch to language technology which ought to make kernels more reliable and easier to develop is the intended outcome.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CNS",
 "org_div_long_name": "Division Of Computer and Network Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Robert",
   "pi_last_name": "Morris",
   "pi_mid_init": "T",
   "pi_sufx_name": "",
   "pi_full_name": "Robert T Morris",
   "pi_email_addr": "rtm@csail.mit.edu",
   "nsf_id": "000471357",
   "pi_start_date": "2016-08-10",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Marinus",
   "pi_last_name": "Kaashoek",
   "pi_mid_init": "F",
   "pi_sufx_name": "",
   "pi_full_name": "Marinus F Kaashoek",
   "pi_email_addr": "kaashoek@lcs.mit.edu",
   "nsf_id": "000098539",
   "pi_start_date": "2016-08-10",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Nickolai",
   "pi_last_name": "Zeldovich",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Nickolai Zeldovich",
   "pi_email_addr": "nickolai@csail.mit.edu",
   "nsf_id": "000520788",
   "pi_start_date": "2016-08-10",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Massachusetts Institute of Technology",
  "inst_street_address": "77 MASSACHUSETTS AVE",
  "inst_street_address_2": "",
  "inst_city_name": "CAMBRIDGE",
  "inst_state_code": "MA",
  "inst_state_name": "Massachusetts",
  "inst_phone_num": "6172531000",
  "inst_zip_code": "021394301",
  "inst_country_name": "United States",
  "cong_dist_code": "07",
  "st_cong_dist_code": "MA07",
  "org_lgl_bus_name": "MASSACHUSETTS INSTITUTE OF TECHNOLOGY",
  "org_prnt_uei_num": "E2NYLCDML6V1",
  "org_uei_num": "E2NYLCDML6V1"
 },
 "perf_inst": {
  "perf_inst_name": "Massachusetts Institute of Technology",
  "perf_str_addr": "77 Massachusetts Ave",
  "perf_city_name": "Cambridge",
  "perf_st_code": "MA",
  "perf_st_name": "Massachusetts",
  "perf_zip_code": "021394301",
  "perf_ctry_code": "US",
  "perf_cong_dist": "07",
  "perf_st_cong_dist": "MA07",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "735400",
   "pgm_ele_name": "CSR-Computer Systems Research"
  },
  {
   "pgm_ele_code": "735900",
   "pgm_ele_name": "CCRI-CISE Cmnty Rsrch Infrstrc"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  }
 ],
 "app_fund": [
  {
   "app_code": "0116",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001617DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2016,
   "fund_oblg_amt": 500000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>The project's goal is to explore whether high-level programming languages are practical for operating systems kernel development. This is an important question because most software systems rely on kernels for many services, and the choice of programming language can have a significant effect on their robustness, efficiency, and maintainability.<br />The usual programming language for operating system kernels is C: Linux, OS X, and Windows all use C. C is popular for kernels because it can deliver high performance via flexible low-level access to memory and control over memory management (allocation and freeing). C, however, requires care and experience to use safely, and even then low-level bugs are common. For example, in 2016 five Linux kernel security vulnerabilities were reported that involved buffer overflows in C code.<br />High-level languages (HLLs) provide type- and memory-safety and convenient abstractions such as threads. Many HLLs provide garbage collection (automated freeing of unused memory) to further reduce programmer burden and memory bugs. But operating system designers have been skeptical that garbage collection and restrictions imposed by HLLs are compatible with high-performance kernels. Because the non-performance benefits of garbage collection and HLLs are significant, it seems worthwhile to decide whether to use them in kernels based on measurements of their costs in that context. Although kernels have been written in HLLs in the past, there are no studies exploring their effect on kernel performance.<br />In order to conduct such a study, we implemented a new operating system (called Biscuit) in the Go language. Go features garbage collection, memory- and type-safety, and built-in support for high-level constructs such as threads and communication channels. Biscuit provides a POSIX-subset system call interface so that it can run many existing applications. We compared Biscuit's performance with that of Linux.&nbsp;<br />If a programmer has the choice of writing a new kernel (or virtual machine monitor) in C or Go, our results indicate the following:<br />- If performance is paramount, C is a good choice, since a C kernel is up to 15% faster;<br />- If low memory usage is paramount, C is a good choice, since Go needs roughly a factor of 3 slack memory to keep garbage collection costs low;<br />- If safety is paramount, Go is a good choice.&nbsp; 40 CVEs that resulted in Linux kernel exploits in 2017 are impossible in Go, because of Go's HLL features;<br />- If performance is merely important, Go is a good choice.&nbsp; A Go kernel is somewhat slower and needs more memory, but is more secure and simplifies development effort.<br />The papers reporting the findings and the code for Biscuit are at: https://pdos.csail.mit.edu/projects/biscuit.html</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 12/10/2019<br>\n\t\t\t\t\tModified by: M. Frans&nbsp;Kaashoek</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nThe project's goal is to explore whether high-level programming languages are practical for operating systems kernel development. This is an important question because most software systems rely on kernels for many services, and the choice of programming language can have a significant effect on their robustness, efficiency, and maintainability.\nThe usual programming language for operating system kernels is C: Linux, OS X, and Windows all use C. C is popular for kernels because it can deliver high performance via flexible low-level access to memory and control over memory management (allocation and freeing). C, however, requires care and experience to use safely, and even then low-level bugs are common. For example, in 2016 five Linux kernel security vulnerabilities were reported that involved buffer overflows in C code.\nHigh-level languages (HLLs) provide type- and memory-safety and convenient abstractions such as threads. Many HLLs provide garbage collection (automated freeing of unused memory) to further reduce programmer burden and memory bugs. But operating system designers have been skeptical that garbage collection and restrictions imposed by HLLs are compatible with high-performance kernels. Because the non-performance benefits of garbage collection and HLLs are significant, it seems worthwhile to decide whether to use them in kernels based on measurements of their costs in that context. Although kernels have been written in HLLs in the past, there are no studies exploring their effect on kernel performance.\nIn order to conduct such a study, we implemented a new operating system (called Biscuit) in the Go language. Go features garbage collection, memory- and type-safety, and built-in support for high-level constructs such as threads and communication channels. Biscuit provides a POSIX-subset system call interface so that it can run many existing applications. We compared Biscuit's performance with that of Linux. \nIf a programmer has the choice of writing a new kernel (or virtual machine monitor) in C or Go, our results indicate the following:\n- If performance is paramount, C is a good choice, since a C kernel is up to 15% faster;\n- If low memory usage is paramount, C is a good choice, since Go needs roughly a factor of 3 slack memory to keep garbage collection costs low;\n- If safety is paramount, Go is a good choice.  40 CVEs that resulted in Linux kernel exploits in 2017 are impossible in Go, because of Go's HLL features;\n- If performance is merely important, Go is a good choice.  A Go kernel is somewhat slower and needs more memory, but is more secure and simplifies development effort.\nThe papers reporting the findings and the code for Biscuit are at: https://pdos.csail.mit.edu/projects/biscuit.html\n\n\t\t\t\t\tLast Modified: 12/10/2019\n\n\t\t\t\t\tSubmitted by: M. Frans Kaashoek"
 }
}