{
 "awd_id": "1619275",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "TWC: Small: Trustworthy Code Generation for the LLVM Compiler Infrastructure",
 "cfda_num": "47.070",
 "org_code": "05050000",
 "po_phone": "7032927841",
 "po_email": "sgreensp@nsf.gov",
 "po_sign_block_name": "Sol Greenspan",
 "awd_eff_date": "2016-06-01",
 "awd_exp_date": "2020-05-31",
 "tot_intn_awd_amt": 500000.0,
 "awd_amount": 500000.0,
 "awd_min_amd_letter_date": "2016-05-31",
 "awd_max_amd_letter_date": "2016-05-31",
 "awd_abstract_narration": "It is becoming widespread practice for software applications to be shipped in the form of a virtual instruction set (i.e,. as \"virtual code\") and translated to the instruction set of a physical computer (\"machine code\") after shipping, e.g., when downloading an app to an iPhone or just before execution for code embedded in many Web pages. Increasingly the LLVM virtual instruction set (developed by the principal investigator under prior NSF funding) is being used by various industries. A serious problem with this model is that application developers are unable to test the final computer code that is generated for their applications: they are only able to test the virtual code.\r\n\r\nThis project is developing new techniques that allow application developers to have much higher confidence in the final code for applications that ship as virtual code.  The basic approach, called \"translation validation,\" allows the translation process from virtual to machine code to also generate a formal proof that the machine code preserves all the correct behaviors of the virtual code, and does not introduce any unexpected incorrect behaviors.  Unlike existing work on translation validation, this work can generate proofs for translation between two very different languages, as well as formal guarantees in the presence of possible incorrect behaviors in the virtual code.  Besides these reliability benefits, the strategy also improves the security of software because virtual code is widely used today as a means to enforce security requirements of important systems, e.g., Web browsers, operating systems, and database systems.  Such systems rely on correct translations of virtual code to machine code to enforce security, and formally verified translations will prevent security vulnerabilities that might otherwise be introduced by bugs in complex (and so, inherently bug-prone) translators.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CNS",
 "org_div_long_name": "Division Of Computer and Network Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Vikram",
   "pi_last_name": "Adve",
   "pi_mid_init": "S",
   "pi_sufx_name": "",
   "pi_full_name": "Vikram S Adve",
   "pi_email_addr": "vadve@cs.uiuc.edu",
   "nsf_id": "000334755",
   "pi_start_date": "2016-05-31",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Grigore",
   "pi_last_name": "Rosu",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Grigore Rosu",
   "pi_email_addr": "grosu@illinois.edu",
   "nsf_id": "000488532",
   "pi_start_date": "2016-05-31",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Illinois at Urbana-Champaign",
  "inst_street_address": "506 S WRIGHT ST",
  "inst_street_address_2": "",
  "inst_city_name": "URBANA",
  "inst_state_code": "IL",
  "inst_state_name": "Illinois",
  "inst_phone_num": "2173332187",
  "inst_zip_code": "618013620",
  "inst_country_name": "United States",
  "cong_dist_code": "13",
  "st_cong_dist_code": "IL13",
  "org_lgl_bus_name": "UNIVERSITY OF ILLINOIS",
  "org_prnt_uei_num": "V2PHZ2CSCH63",
  "org_uei_num": "Y8CWNJRCNN91"
 },
 "perf_inst": {
  "perf_inst_name": "University of Illinois at Urbana-Champaign",
  "perf_str_addr": "",
  "perf_city_name": "",
  "perf_st_code": "IL",
  "perf_st_name": "Illinois",
  "perf_zip_code": "618207473",
  "perf_ctry_code": "US",
  "perf_cong_dist": "13",
  "perf_st_cong_dist": "IL13",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "806000",
   "pgm_ele_name": "Secure &Trustworthy Cyberspace"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7434",
   "pgm_ref_txt": "CNCI"
  },
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  }
 ],
 "app_fund": [
  {
   "app_code": "0116",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001617DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2016,
   "fund_oblg_amt": 500000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Software applications are widely used for security-critical tasks today: financial transactions, legal contracts, health care data, military command and control, transportation systems, and many others. It is then essential that such software is trustworthy, meaning it will operate according to its specification, and secure, meaning it cannot be manipulated by malicious attackers for harmful purposes. &nbsp;The scientific community has dedicated a lot of resources into designing techniques for providing guarantees of software correctness and security as well as for extensive software testing to detect errors and security vulnerabilities. &nbsp;Unfortunately most of this research applies to software at the source code level, that is software written in a human-readable programming language such as C/C++, Fortran, Rust, Swift, Go, etc. &nbsp;On the other hand, software is actually executed using a binary, machine-understandable representation of the code. &nbsp;The tools that translate software from the source level to the binary level, known as compilers, are themselves extremely complicated pieces of software that not only perform the translation but also transform the code extensively to make it more efficient (e.g. maximizing speed, minimizing memory requirements, and minimizing energy consumption). &nbsp;The compilation step makes correctness and security guarantees that have been verified at the source level void for the binary level, unless there is high trust in the compiler itself. &nbsp;This is not a desirable outcome, since compilers are similarly plagued by errors as any other complicated software tool. &nbsp;However, if the binary code generated from source programs could be proved equivalent to the original source, then it would suffice to apply sophisticated correctness and security checking tools to source programs in order to obtain the corresponding guarantees for the binary code.</p>\n<p>Our research aims to develop new and improved techniques to prove the equivalence of source code and generated binary code, a widely studied approach known as Translation Validation (TV). &nbsp;A key advantage of the TV approach, in general, is that it requires only limited internal information from the compiler, and so it can be retrofitted relatively easily to complex and constantly evolving production compilers. &nbsp;In our research, we advance the state of the art in Translation Validation in three ways. &nbsp;First, we design a TV-based verifier that can be reused across transformations, while separating out the parts of the verifier that must be transformation-specific. &nbsp;This enables a common TV-based verifier to be reused across most of the major phases of a modern compiler, greatly reducing the effort for developing an end-to-end TV system for such a compiler. &nbsp;Second, we design our verifier algorithm so that it can work for any pair of input and output languages (technically, these languages can be specified as inputs to the algorithm, along with the input and output programs). &nbsp;This is important because compilers translate programs through a sequence of intermediate languages on the way to generating the final binary code, with as many as four to eight different languages in modern production compilers. &nbsp;In contrast, all previous TV algorithms were specific to a particular language pair and, therefore, could be used for only a single phase of a compiler. &nbsp;Third, we use these algorithms to prove formally the correctness of two of the most important and complex phases of the widely-used LLVM Compiler Infrastructure, namely, Instruction Selection (which translates a mid-level, machine independent program representation to the machine instructions of a target machine) and Register Allocation (which assigns variables of the input program to the physical registers of the target machine). &nbsp;In our ongoing work, we are further using our algorithms to prove the correctness of other phases of LLVM-based compilers. &nbsp;The eventual goal of our work is an end-to-end system capable of proving correctness of an LLVM-based compiler system, which would have major theoretical implications (because the modularity and language-independence of our techniques make them easy to reuse for other production compilers) and practical benefits (because LLVM is used for important real-world compilers, including ones from Apple, Google, Intel, IBM, NVIDIA, Cray, and many other companies).</p>\n<p>&nbsp;</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 12/20/2020<br>\n\t\t\t\t\tModified by: Vikram&nbsp;S&nbsp;Adve</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nSoftware applications are widely used for security-critical tasks today: financial transactions, legal contracts, health care data, military command and control, transportation systems, and many others. It is then essential that such software is trustworthy, meaning it will operate according to its specification, and secure, meaning it cannot be manipulated by malicious attackers for harmful purposes.  The scientific community has dedicated a lot of resources into designing techniques for providing guarantees of software correctness and security as well as for extensive software testing to detect errors and security vulnerabilities.  Unfortunately most of this research applies to software at the source code level, that is software written in a human-readable programming language such as C/C++, Fortran, Rust, Swift, Go, etc.  On the other hand, software is actually executed using a binary, machine-understandable representation of the code.  The tools that translate software from the source level to the binary level, known as compilers, are themselves extremely complicated pieces of software that not only perform the translation but also transform the code extensively to make it more efficient (e.g. maximizing speed, minimizing memory requirements, and minimizing energy consumption).  The compilation step makes correctness and security guarantees that have been verified at the source level void for the binary level, unless there is high trust in the compiler itself.  This is not a desirable outcome, since compilers are similarly plagued by errors as any other complicated software tool.  However, if the binary code generated from source programs could be proved equivalent to the original source, then it would suffice to apply sophisticated correctness and security checking tools to source programs in order to obtain the corresponding guarantees for the binary code.\n\nOur research aims to develop new and improved techniques to prove the equivalence of source code and generated binary code, a widely studied approach known as Translation Validation (TV).  A key advantage of the TV approach, in general, is that it requires only limited internal information from the compiler, and so it can be retrofitted relatively easily to complex and constantly evolving production compilers.  In our research, we advance the state of the art in Translation Validation in three ways.  First, we design a TV-based verifier that can be reused across transformations, while separating out the parts of the verifier that must be transformation-specific.  This enables a common TV-based verifier to be reused across most of the major phases of a modern compiler, greatly reducing the effort for developing an end-to-end TV system for such a compiler.  Second, we design our verifier algorithm so that it can work for any pair of input and output languages (technically, these languages can be specified as inputs to the algorithm, along with the input and output programs).  This is important because compilers translate programs through a sequence of intermediate languages on the way to generating the final binary code, with as many as four to eight different languages in modern production compilers.  In contrast, all previous TV algorithms were specific to a particular language pair and, therefore, could be used for only a single phase of a compiler.  Third, we use these algorithms to prove formally the correctness of two of the most important and complex phases of the widely-used LLVM Compiler Infrastructure, namely, Instruction Selection (which translates a mid-level, machine independent program representation to the machine instructions of a target machine) and Register Allocation (which assigns variables of the input program to the physical registers of the target machine).  In our ongoing work, we are further using our algorithms to prove the correctness of other phases of LLVM-based compilers.  The eventual goal of our work is an end-to-end system capable of proving correctness of an LLVM-based compiler system, which would have major theoretical implications (because the modularity and language-independence of our techniques make them easy to reuse for other production compilers) and practical benefits (because LLVM is used for important real-world compilers, including ones from Apple, Google, Intel, IBM, NVIDIA, Cray, and many other companies).\n\n \n\n\t\t\t\t\tLast Modified: 12/20/2020\n\n\t\t\t\t\tSubmitted by: Vikram S Adve"
 }
}